<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005-Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>计算机相关 on 桃园</title>
    <link>/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/</link>
    <description>Recent content in 计算机相关 on 桃园</description>
    <image>
      <title>桃园</title>
      <url>%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 05 Sep 2021 15:30:00 +0000</lastBuildDate><atom:link href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>git commit 规范和 如何在 commit 里使用 emoji</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/2021-09-05-git-commit%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sun, 05 Sep 2021 15:30:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/2021-09-05-git-commit%E8%A7%84%E8%8C%83/</guid>
      <description>前言 大家好，我是桃翁，今天给大家带来的是关于 git commit 那些事儿，希望大家喜欢。
对于规范 git commit message 我是分成了两种类型去看待。
对于通用库、开源项目这类多人维护，而且极大可能别人会来看这份代码的，一定要规范，特别是对于开源项目，往往会要列 Change Log，规范好 commit 节省自己整理 log 的时间，也方便了用户。
对于业务代码，特别是那种一个人维护的，其实不搞问题也不大，因为极小可能会有人来看你的 commit message。但是我依然还是建议规范一下，不然一旦后面想去看就会花费很多的力气，毕竟规范一下也不麻烦。
通过本篇文章你讲了解到三部分内容：
了解 git commit 规范 学到用工具 Commitizen 来规范 commit 学到如何在 commit message 里加上好看的 emoji 规范 现在主流的 commit message 规范就是 Angular 团队所用的准则，继而衍生了 Conventional Commits specification. 很多工具也是基于此规范。
每次提交，Commit message 都包括三个部分：header，body 和 footer，其中 header 有一个特殊的格式，包括了 type、scope、subject。
&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt; &amp;lt;BLANK LINE&amp;gt; &amp;lt;body&amp;gt; &amp;lt;BLANK LINE&amp;gt; &amp;lt;footer&amp;gt; 其中 header 是必选的，但是 header 里的 scope 是可选的，另外提交的 message 长度不要超过 100 个字符，太长了不易阅读。</description>
    </item>
    
    <item>
      <title>每个前端工程师都应该了解的图片知识</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/264/</link>
      <pubDate>Mon, 20 May 2019 21:44:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/264/</guid>
      <description>前言 随着web的发展，网站资源的流量也变得越来越大。据统计，60% 的网站流量均来自网站图片，可见对图片合理优化可以大幅影响网站流量，减小带宽消耗和服务器压力。
有时候你花大力气去配置 webpack 使打包体积减少，不如好好优化几张图片，这篇文章就是让你明白如何选择正确的图片，并且让你明白这么多图片格式，在什么场景下使用什么格式，如果想看答案，那么直接滑到文末看图即可。
我的更多文章可以看 GitHub博客,
基本概念 在进入正题之前，先聊聊一些图片相关的基本概念。
一张照片（位图）不断放大之后，会看到一个个小格子，这些小格子，叫像素。
一个格子（像素），在计算机中，用二进制来表示，使用的二进制位数越多，像素的色彩就越丰富。
举个例子，如果一个像素用一位二进制数表示，能有多少种颜色呢？
两种，一个二进制位，要不放 0（表示黑色），要不放 1（表示白色）
下图展示了一个像素二进制的位数最多可以展示多少种颜色。
在对图片有了基本的了解之后，接下来对图片进行分下类，有利于理解各种格式图片的特点。
根据图的类型分类 点阵图(位图) 矢量图 位图(点阵图) 位图，也叫做点阵图，像素图。构成点阵图的最小单位是像素，位图就是由像素阵列的排列来实现其显示效果的，每个像素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个像素，我们可以改变图像的色相、饱和度、透明度，从而改变图像的显示效果。
前面介绍中的那种不断放大会有小格子的图就是属于位图。
常见的比如：jpg、png、webp等，我们平时遇到的大多数都是位图。
矢量图 矢量图，也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一幅矢量图的时候，软件对图形对应的函数进行运算，将运算结果图形的形状和颜色显示给你看。
无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同(不失真)。
常见的就是 svg 格式的。
根据压缩分类 无压缩。 无损压缩。 有损压缩。 无压缩 无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。BMP 格式就是其中之一。
有损压缩 指在压缩文件大小的过程中，损失了一部分图片的信息，也即降低了图片的质量，并且这种损失是不可逆的，我们不可能从有一个有损压缩过的图片中恢复出原来的图片。
常见的有损压缩手段，是按照一定的算法将临近的像素点进行合并。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸。其中的代表是 jpg。
无损压缩 在压缩图片的过程中，图片的质量没有任何损耗。我们任何时候都可以从无损压缩过的图片中恢复出原来的信息。
压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸。
png 是其中的代表。
小结 使用有损压缩处理图像，是去除某些像素数据，无法找回原图。 使用无损处理图像，是对像素数据进行压缩，可以找回原图。 常见的图片格式解析 GIF 关键词：无损压缩、索引色、透明、动画
GIF(Graphics Interchange Format) 的原义是“图像互换格式”，是一种基于 LZW 算法连续色调的无损的基于索引色的压缩格式。其压缩率一般在 50% 左右，它不属于任何应用程序所以几乎所有相关软件都支持它，公共领域有大量的软件在使用 GIF 图像文件。
GIF 是一种无损压缩，所以它只是对像素数据进行压缩，其实 LZW 算法只是一个压缩数据的算法，如果你懂哈夫曼算法的话，可能就比较好理解压缩数据是怎么回事儿了。
GIF 的特性是帧动画。</description>
    </item>
    
    <item>
      <title>pm2 使用教程</title>
      <link>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/238/</link>
      <pubDate>Wed, 30 Jan 2019 10:10:00 +0000</pubDate>
      
      <guid>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/238/</guid>
      <description>简介 PM2 是 node 进程管理工具，可以利用它来简化很多 node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。
安装 npm install -g pm2 快速使用 pm2 start app.js 常用命令 启动 参数说明：
--watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。 -i --instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。 --ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如--ignore-watch=&amp;quot;test node_modules &amp;quot;some scripts&amp;quot;&amp;quot; -n --name：应用的名称。查看应用信息的时候可以用到。 -o --output &amp;lt;path&amp;gt;：标准输出日志文件的路径。 -e --error &amp;lt;path&amp;gt;：错误输出日志文件的路径。 --interpreter &amp;lt;interpreter&amp;gt;：the interpreter pm2 should use for executing app (bash, python&amp;hellip;)。比如你用的coffee script来编写应用。 重启 pm2 restart app.js 3.3 停止 停止特定的应用。可以先通过pm2 list获取应用的名字（&amp;ndash;name指定的）或者进程id。
pm2 stop app_name|app_id 如果要停止所有应用，可以
pm2 stop all 停止 类似pm2 stop，如下
pm2 stop app_name|app_id pm2 stop all 从进程列表删除进程 // pm2 delete [appname] | id pm2 delete app // 指定进程名删除 pm2 delete 0 // 指定进程id删除 删除进程列表中所有进程 pm2 delete all 查看进程状态 pm2 list // 或者 pm2 ls 查看某个进程的信息 pm2 describe 0 负载均衡 命令如下，表示开启三个进程。如果-i 0，则会根据机器当前核数自动开启尽可能多的进程。</description>
    </item>
    
    <item>
      <title>git 之修改 commit 以及 rebase 的使用</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/228/</link>
      <pubDate>Tue, 22 Jan 2019 18:27:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/228/</guid>
      <description>我在提交中犯了一个错误，我该如何解决？
我的提交历史一团遭，我改如何让它整洁？
如果您有过上述问题，那么这篇文章适合您。这篇文章介绍了一个让你成为 Git 专家的主题列表。
如果您不了解 Git 基础知识，请单击此处查看我的 Git 基础知识博客。您必须了解 Git 的基础知识才能充分利用本文。
我的提交中犯了一个错误。我该怎么办？ 情景 1 假设您已经提交了一堆文件并意识到您输入的提交消息实际上并不清楚。现在您要更改提交消息。为此，您可以使用 git commit --amend
git commit --amend -m “新提交消息” 情景 2 假设您想提交六个文件，但是，错误地，您最终只提交了五个文件。您可能认为可以创建新提交并将第6个文件添加到该提交。
这种方法没有错。但是，为了保持整洁的提交历史，如果你真的可以以某种方式将此文件添加到您之前的提交本身，那会不会更好？这也可以通过以下方式完成 git commit --amend：
git add file6 git commit --amend --no-edit --no-edit 表示提交消息不会更改
场景3 无论何时在 Git 中进行提交，提交都会附上作者姓名和作者电子邮件。通常，当您第一次设置 Git 时，您需要设置作者姓名和电子邮件。您无需担心每次提交的作者详细信息。
也就是说，对于特定项目，您可能希望使用不同的电子邮件 ID。您需要使用以下命令为该项目配置电子邮件 ID：
git config user.email “你的电子邮件ID” 假设您忘记配置电子邮件，并且已经完成了第一次提交。Amend 也可用于更改先前提交的作者。可以使用以下命令更改提交的作者：
git commit --amend --author“作者姓名&amp;lt;作者电子邮件&amp;gt;” 注意：仅在本地存储库中使用该 amend 命令。使用远程存储库可能会造成很多混乱 amend
我的提交历史是一团糟。我该如何处理？ 假设您正在处理一段代码。您知道代码大约需要十天才能完成。在这十天内，其他开发人员也将提交代码到远程存储库。
将本地存储库代码与远程存储库中的代码保持同步是一种很好的做法。这会在您提出拉取请求时避免很多合并冲突。因此，您决定每两天从远程存储库中提取一次更改。
每次将代码从远程存储库提取到本地存储库时，都会在本地存储库中创建新的合并提交。这意味着您的本地提交历史记录将会进行大量的合并提交，这会使审阅者感到困惑。
如何使提交历史看起来更整洁？ 这就是 rebase 拯救的地方。</description>
    </item>
    
    <item>
      <title>像素相关概念：PPI、DPI、设备像素、独立像素</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/146/</link>
      <pubDate>Fri, 30 Mar 2018 15:19:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/146/</guid>
      <description>欢迎访问我的个人站点
前言 我相信对于像素，英文「pixel」，缩写「px」，这个概念并不陌生吧，不管是设计师设计图片用的单位 px，还是前端工程师在 css 里面的单位 px等等，很多领域都会用到这个单位，但是当我问他们一些问题的时候，基本上都答得不好。
比如：
iPhone 6 的分辨率是 750 x 1334 像素，然而我们我们在写 css 的时候是以 375 x 667 来调的； 为什么我们做的一个网页在 pc 端可以正常显示，在移动端也可以正常显示，但是有时候又不正常显示； 我们如果在 pc 端把浏览器的宽度调到只有 200px 宽，里面写一个 100px 宽的 div ，然后再调整浏览器的放大为 200%，然后这个 div 可以充满整个显示器。 如果都能答上来，已经很不错了哦！
像素 定义：是指在由一个数字序列表示的图像中的一个最小单位，称为像素。 &amp;mdash;- 百度百科
注意: 我觉得这里最关键的是『单位』，像素是一个单位，而不是一个点，我认为理解为一个长度单位比较好理解，后面我会解释为什么我会觉得是一个长度单位比较好理解。
我在很多文章里看到的定义是，像素就是组成图像的一个一个的点，这会让人感觉像素是个面积单位，我觉得这样有点不妥，并不是不对，要根据上下文而定。
比如 设备像素比(device pixels ratio)，简称 DPR，DPR = 设备像素 / 设备独立像素。现在我们就拿 iPhone 6 来做例子，我们可以通过 window.devicePixelRatio 获取设备的 DPR 为 2，设备独立像素，在这里可以认为是 css 像素，整个 iPhone 6 的像素点就有 375 * 667 个。</description>
    </item>
    
    <item>
      <title>如何将多个 maven 项目统一管理</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/51/</link>
      <pubDate>Thu, 22 Mar 2018 10:21:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/51/</guid>
      <description>简介 在我们一个人采用微服务构架的时候，我们会创建很多个 maven 项目。然后如果从 IDE 里面导入项目就要导入很多次，为了方便统一管理，我们可以将多个 maven 放在一个 项目里统一管理，然后我们导入项目的时候就可以直接导入一个项目就 OK。
操作方法 在多个项目的父目录建立一个文件夹，创建一个 pox.xml 文件 代码规则 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001-XMLSchema-instance&amp;#34;xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;&amp;lt;groupId&amp;gt;com.lxr&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;maiba_be&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;&amp;lt;!-- packaging 把 jar 改成 pox --&amp;gt;&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;&amp;lt;!-- 这里面放每个微服务的 artifactId--&amp;gt;&amp;lt;modules&amp;gt;&amp;lt;module&amp;gt;goodsService&amp;lt;/module&amp;gt;&amp;lt;/modules&amp;gt;&amp;lt;!-- 为了解决依赖版本问题 --&amp;gt;&amp;lt;dependencyManagement&amp;gt;&amp;lt;dependencies&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;Camden.SR3&amp;lt;/version&amp;gt;&amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;&amp;lt;/dependencyManagement&amp;gt;&amp;lt;properties&amp;gt;&amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;&amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;&amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;&amp;lt;/properties&amp;gt;&amp;lt;parent&amp;gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;1.4.2.RELEASE&amp;lt;/version&amp;gt;&amp;lt;/parent&amp;gt;&amp;lt;build&amp;gt;&amp;lt;plugins&amp;gt;&amp;lt;plugin&amp;gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;&amp;lt;/plugin&amp;gt;&amp;lt;/plugins&amp;gt;&amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt; 每个微服务项目的 pox.</description>
    </item>
    
    <item>
      <title>vim 入门指南</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/50/</link>
      <pubDate>Tue, 20 Mar 2018 23:28:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/50/</guid>
      <description>个人站点：桃园
0. 前言 0.1 简介 vim 被誉为『编辑器之神』，与之同时代的 emacs 被誉为『神之编辑器』。可以看得出 vim 在编辑器的地位是很高的，得益于 vim 的指法，敲起代码来如行云流水。特别膜拜创始人创始出这么方便的敲代码的指法，这篇文章就是来带你入坑 vim 指法操作。
0.2 前端的我为什么要学习 vim 在当今前端开发工具百花齐放的时代（VS Code、Sublime、Atom 以及 IDE Webstorm），我为什么还要介绍 20 多年前开发的一个老古董呢？在这里我想说的是出身虽然老，但是所带来的价值并没有减,一旦习惯了 vim 的指法之后，你会觉得不用 vim 操作写代码会觉得很不习惯，甚至不知道怎么操作。然而用在支持 vim 指法的编辑上写代码你会觉得如行云流水，如果再配个机械键盘，简直是享受，特别符合极客的风格。
一旦学会了 vim 的指法，会让你终身受益，至少在你敲代码的年代会收益，毫无夸张, 它会让你摆脱烦人的，在敲代码的时候频繁的移动鼠标，这也是 vim 的设计理念之一 &amp;ndash; 脱离鼠标。
0.3 文章适用读者 本篇文章比较适合前端开发者，因为我也只是用 vim 在前端领域做过一些开发，其他领域我没有发言权。
0.4 Q&amp;amp;A Q：你推荐 vim 是要我们完全放弃以前的编辑器而投入 vim 的怀抱吗？
A：当然不是。首先 vim 的学习成本还是很高的，因为他跟平时我们用的编辑器敲代码的方式根本不同，因为它是不用鼠标的，纯键盘操作。你想想如果你在你的 vs code 上不用鼠标操作，你上下左右全靠方向键，那敲代码的速度得有多慢。而且初学者想把 vim 打造成一个自己的 IDE 还是很有难度的。所以我这里推荐的是，不管是你的 vs code、sublime等，装一个 vim 插件。我在 vs code 上试过，很爽，只不过现在投身到 emacs 的怀抱了。</description>
    </item>
    
    <item>
      <title>在spacemacs中支持editorconfig</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/37/</link>
      <pubDate>Mon, 29 Jan 2018 16:15:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/37/</guid>
      <description>editorconfig 是在项目存储库中有一个名为 .editorconfig 的文件，这样参与的开发者的编辑和 ide 可以自动调整。
有一个 emacs/spacemacs 模式，可以很容易地在以下步骤中进行集成：
将 editorconfig 添加到 dotspacemacs-additional-packages。 将（editorconfig-mode 1）添加到 dotspacemacs/user-config。 更多的细节记录在插件库的 README。
源码片段 第一步：添加插件到 additional packages:
dotspacemacs-additional-packages &amp;#39;( editorconfig ) 第二步：从你的 user-config 激活插件：
(defun dotspacemacs/user-config () (editorconfig-mode 1) ) </description>
    </item>
    
    <item>
      <title>数据库基础知识</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/19/</link>
      <pubDate>Fri, 05 Jan 2018 19:43:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/19/</guid>
      <description>&lt;p&gt;数据库基础知识&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>cenos下安装node.js和mongodb</title>
      <link>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/17/</link>
      <pubDate>Fri, 05 Jan 2018 19:20:00 +0000</pubDate>
      
      <guid>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/17/</guid>
      <description>&lt;h2 id=&#34;nodejs安装&#34;&gt;node.js安装&lt;/h2&gt;
&lt;p&gt;下载源码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /usr/local/src/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget https://nodejs.org/dist/v8.6.0/node-v8.6.0.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>认识函数式编程</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/190/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/190/</guid>
      <description>最开始接触函数式编程的时候是在小米工作的时候，那个时候看老大以前写的代码各种 compose，然后一些 ramda 的一些工具函数，看着很吃力，然后极力吐槽函数式编程，现在回想起来，那个时候的自己真的是见识短浅，只想说,&amp;lsquo;真香&amp;rsquo;。
最近在研究函数式编程，真的是在学习的过程中感觉自己的思维提升了很多，抽象能力大大的提高了，让我深深的感受到了函数式编程的魅力。所以我打算后面用 5 到 8 篇的篇幅，详细的介绍一下函数式编程的思想，基础、如何设计、测试等。
今天这篇文章主要介绍函数式编程的思想。
函数式编程有用吗？ 什么是函数式编程？ 函数式编程的优点。 面向对象编程(OOP)通过封装变化使得代码更易理解。 函数式编程(FP)通过最小化变化使得代码更易理解。 &amp;ndash; Michacel Feathers（Twitter）
总所周知 JavaScript 是一种拥有很多共享状态的动态语言，慢慢的，代码就会积累足够的复杂性，变得笨拙难以维护。面向对象设计能帮我们在一定程度上解决这个问题，但是还不够。
由于有很多的状态，所以处理数据流和变化的传递显得尤为重要，不知道你们知道响应式编程与否，这种编程范式有助于处理 JavaScript 的异步或者事件响应。总之，当我们在设计应用程序的时候，我们应该考虑是否遵守了以下的设计原则。
可扩展性&amp;ndash;我是否需要不断地重构代码来支持额外的功能？ 易模块化&amp;ndash;如果我更改了一个文件，另一个文件是否会受到影响？ 可重用性&amp;ndash;是否有很多重复的代码？ 可测性&amp;ndash;给这些函数添加单元测试是否让我纠结？ 易推理性&amp;ndash;我写的代码是否非结构化严重并难以推理？ 我这能这么跟你说，一旦你学会了函数式编程，这些问题迎刃而解，本来函数式编程就是这个思想，一旦你掌握了函数式，然后你再学习响应式编程那就比较容易懂了，这是我亲身体会的。我之前在学 Rxjs 的时候是真的痛苦，说实话，Rxjs 是我学过最难的库了，没有之一。在经历过痛苦的一两个月之后，有些东西还是不能融会贯通，知道我最近研究函数式编程，才觉得是理所当然。毫无夸张，我也尽量在后面的文章中给大家介绍一下 Rxjs，这个话题我也在公司分享过。
什么是函数式编程？ 简单来说，函数式编程是一种强调以函数使用为主的软件开发风格。看到这句我想你还是一脸懵逼，不知道函数式编程是啥，不要着急，看到最后我相信你会明白的。
还有一点你要记住，函数式编程的目的是使用函数来抽象作用在数据之上的控制流和操作，从而在系统中消除副作用并减少对状态的改变。
下面我们通过例子来简单的演示一下函数式编程的魅力。
现在的需求就是输出在网页上输出 “Hello World”。
可能初学者会这么写。
document.querySelector(&amp;#39;#msg&amp;#39;).innerHTML = &amp;#39;&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;&amp;#39; 这个程序很简单，但是所有代码都是死的，不能重用，如果想改变消息的格式、内容等就需要重写整个表达式，所以可能有经验的前端开发者会这么写。
function printMessage(elementId, format, message) { document.querySelector(elementId).innerHTML = `&amp;lt;${format}&amp;gt;${message}&amp;lt;/${format}&amp;gt;` } printMessage(&amp;#39;msg&amp;#39;, &amp;#39;h1&amp;#39;, &amp;#39;Hello World&amp;#39;) 这样确实有所改进，但是任然不是一段可重用的代码，如果是要将文本写入文件，不是非 HTML，或者我想重复的显示 Hello World。
那么作为一个函数式开发者会怎么写这段代码呢？
const printMessage = compose(addToDom(&amp;#39;msg&amp;#39;), h1, echo) printMessage(&amp;#39;Hello World&amp;#39;) 解释一下这段代码，其中的 h1 和 echo 都是函数，addToDom 很明显也能看出它是函数，那么我们为什么要写成这样呢？看起来多了很多函数一样。</description>
    </item>
    
  </channel>
</rss>
