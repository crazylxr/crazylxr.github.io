<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>你可能不知道的 React Hooks | 桃园</title><meta name=keywords content="react,译文"><meta name=description content="本文是译文，原文地址是：https://medium.com/@sdolidze/the-iceberg-of-react-hooks-af0b588f43fb
React Hooks 与类组件不同，它提供了用于优化和组合应用程序的简单方式，并且使用了最少的样板文件。
如果没有深入的知识，由于微妙的 bug 和抽象层漏洞，可能会出现性能问题，代码复杂性也会增加。
我已经创建了12个案例研究来演示常见的问题以及解决它们的方法。 我还编写了 React Hooks Radar 和 React Hooks Checklist，来推荐和快速参考。
案例研究： 实现 Interval 目标是实现计数器，从 0 开始，每 500 毫秒增加一次。 应提供三个控制按钮: 启动、停止和清除。
Level 0：Hello World export default function Level00() { console.log('renderLevel00'); const [count, setCount] = useState(0); return ( <div> count => {count} <button onClick={() => setCount(count + 1)}>+</button> <button onClick={() => setCount(count - 1)}>-</button> </div> ); } 这是一个简单的、正确实现的计数器，用户单击时计数器的增加或减少。
Level 1：setInterval export default function Level01() { console."><meta name=author content="桃翁"><link rel=canonical href=/posts/%E8%AF%91%E6%96%87/296/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.355db47b48ce042e543348876cce64165399cee8651ce7514d3c4b076b02f0aa.css integrity="sha256-NV20e0jOBC5UM0iHbM5kFlOZzuhlHOdRTTxLB2sC8Ko=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="你可能不知道的 React Hooks"><meta property="og:description" content="本文是译文，原文地址是：https://medium.com/@sdolidze/the-iceberg-of-react-hooks-af0b588f43fb
React Hooks 与类组件不同，它提供了用于优化和组合应用程序的简单方式，并且使用了最少的样板文件。
如果没有深入的知识，由于微妙的 bug 和抽象层漏洞，可能会出现性能问题，代码复杂性也会增加。
我已经创建了12个案例研究来演示常见的问题以及解决它们的方法。 我还编写了 React Hooks Radar 和 React Hooks Checklist，来推荐和快速参考。
案例研究： 实现 Interval 目标是实现计数器，从 0 开始，每 500 毫秒增加一次。 应提供三个控制按钮: 启动、停止和清除。
Level 0：Hello World export default function Level00() { console.log('renderLevel00'); const [count, setCount] = useState(0); return ( <div> count => {count} <button onClick={() => setCount(count + 1)}>+</button> <button onClick={() => setCount(count - 1)}>-</button> </div> ); } 这是一个简单的、正确实现的计数器，用户单击时计数器的增加或减少。
Level 1：setInterval export default function Level01() { console."><meta property="og:type" content="article"><meta property="og:url" content="/posts/%E8%AF%91%E6%96%87/296/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-01-07T21:50:00+00:00"><meta property="article:modified_time" content="2020-01-07T21:50:00+00:00"><meta property="og:site_name" content="桃园"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="你可能不知道的 React Hooks"><meta name=twitter:description content="本文是译文，原文地址是：https://medium.com/@sdolidze/the-iceberg-of-react-hooks-af0b588f43fb
React Hooks 与类组件不同，它提供了用于优化和组合应用程序的简单方式，并且使用了最少的样板文件。
如果没有深入的知识，由于微妙的 bug 和抽象层漏洞，可能会出现性能问题，代码复杂性也会增加。
我已经创建了12个案例研究来演示常见的问题以及解决它们的方法。 我还编写了 React Hooks Radar 和 React Hooks Checklist，来推荐和快速参考。
案例研究： 实现 Interval 目标是实现计数器，从 0 开始，每 500 毫秒增加一次。 应提供三个控制按钮: 启动、停止和清除。
Level 0：Hello World export default function Level00() { console.log('renderLevel00'); const [count, setCount] = useState(0); return ( <div> count => {count} <button onClick={() => setCount(count + 1)}>+</button> <button onClick={() => setCount(count - 1)}>-</button> </div> ); } 这是一个简单的、正确实现的计数器，用户单击时计数器的增加或减少。
Level 1：setInterval export default function Level01() { console."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"你可能不知道的 React Hooks","item":"/posts/%E8%AF%91%E6%96%87/296/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"你可能不知道的 React Hooks","name":"你可能不知道的 React Hooks","description":"本文是译文，原文地址是：https://medium.com/@sdolidze/the-iceberg-of-react-hooks-af0b588f43fb\nReact Hooks 与类组件不同，它提供了用于优化和组合应用程序的简单方式，并且使用了最少的样板文件。\n如果没有深入的知识，由于微妙的 bug 和抽象层漏洞，可能会出现性能问题，代码复杂性也会增加。\n我已经创建了12个案例研究来演示常见的问题以及解决它们的方法。 我还编写了 React Hooks Radar 和 React Hooks Checklist，来推荐和快速参考。\n案例研究： 实现 Interval 目标是实现计数器，从 0 开始，每 500 毫秒增加一次。 应提供三个控制按钮: 启动、停止和清除。\nLevel 0：Hello World export default function Level00() { console.log(\u0026#39;renderLevel00\u0026#39;); const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; count =\u0026gt; {count} \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count - 1)}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 这是一个简单的、正确实现的计数器，用户单击时计数器的增加或减少。\nLevel 1：setInterval export default function Level01() { console.","keywords":["react","译文"],"articleBody":" 本文是译文，原文地址是：https://medium.com/@sdolidze/the-iceberg-of-react-hooks-af0b588f43fb\nReact Hooks 与类组件不同，它提供了用于优化和组合应用程序的简单方式，并且使用了最少的样板文件。\n如果没有深入的知识，由于微妙的 bug 和抽象层漏洞，可能会出现性能问题，代码复杂性也会增加。\n我已经创建了12个案例研究来演示常见的问题以及解决它们的方法。 我还编写了 React Hooks Radar 和 React Hooks Checklist，来推荐和快速参考。\n案例研究： 实现 Interval 目标是实现计数器，从 0 开始，每 500 毫秒增加一次。 应提供三个控制按钮: 启动、停止和清除。\nLevel 0：Hello World export default function Level00() { console.log('renderLevel00'); const [count, setCount] = useState(0); return ( \u003cdiv\u003e count =\u003e {count} \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e+\u003c/button\u003e \u003cbutton onClick={() =\u003e setCount(count - 1)}\u003e-\u003c/button\u003e \u003c/div\u003e ); } 这是一个简单的、正确实现的计数器，用户单击时计数器的增加或减少。\nLevel 1：setInterval export default function Level01() { console.log('renderLevel01'); const [count, setCount] = useState(0); setInterval(() =\u003e { setCount(count + 1); }, 500); return \u003cdiv\u003ecount =\u003e {count}\u003c/div\u003e; } 此代码的目的是每 500 毫秒增加计数器。 这段代码存在巨大的内存泄漏并且实现不正确。 它很容易让浏览器标签崩溃。 由于 Level01 函数在每次渲染发生时被调用，所以每次触发渲染时这个组件都会创建新的 interval。\n突变、订阅、计时器、日志记录和其他副作用不允许出现在函数组件的主体中(称为 React 的 render 阶段)。 这样做会导致用户界面中的错误和不一致。\nHooks API Reference: useEffect\nLevel 2：useEffect export default function Level02() { console.log('renderLevel02'); const [count, setCount] = useState(0); useEffect(() =\u003e { setInterval(() =\u003e { setCount(count + 1); }, 500); }); return \u003cdiv\u003eLevel 2: count =\u003e {count}\u003c/div\u003e; } 大多数副作用放在 useEffect 内部。 但是此代码还有巨大的资源泄漏，并且实现不正确。 useEffect 的默认行为是在每次渲染后运行，所以每次计数更改都会创建新的 Interval。\nHooks API Reference: useEffect, Timing of Effects.\nLevel 3: 只运行一次 export default function Level03() { console.log('renderLevel03'); const [count, setCount] = useState(0); useEffect(() =\u003e { setInterval(() =\u003e { setCount(count + 1); }, 300); }, []); return \u003cdiv\u003ecount =\u003e {count}\u003c/div\u003e; } 将**[]**作为 useEffect 的第二个参数，将在 mount 之后只调用一次 function。，即使只调用一次 setInterval，这段代码的实现也是不正确的。\n虽然 count 会从 0 增加到 1，但是不会再增加，只会保持成 1。 因为箭头函数只被创建一次，所以箭头函数里面的 count 会一直为 0.\n这段代码也存在微妙的资源泄漏。 即使在组件卸载之后，仍将调用 setCount。\nHooks API Reference: useEffect, Conditionally firing an effect.\nLevel 4：清理 useEffect(() =\u003e { const interval = setInterval(() =\u003e { setCount(count + 1); }, 300); return () =\u003e clearInterval(interval); }, []); 为了防止资源泄漏，Hooks 的生命周期结束时，必须清理所有内容。 在这种情况下，组件卸载后将调用返回的函数。\n这段代码没有资源泄漏，但是实现不正确，就像之前的代码一样。\nHooks API Reference: Cleaning up an effect.\nLevel 5：使用 count 作为依赖项 useEffect(() =\u003e { const interval = setInterval(() =\u003e { setCount(count + 1); }, 500); return () =\u003e clearInterval(interval); }, [count]); 给 useEffect 提供依赖数组会改变它的生命周期。 在这个例子中，useEffect 在 mount 之后会被调用一次，并且每次 count 都会改变。 清理函数将在每次 count 更改时被调用以释放前面的资源。\n这段代码工作正常，没有任何错误，但是还是有点不好，每 500 毫秒创建和释放 setInterval， 每个 setInterval 总是调用一次。\nHooks API Reference: useEffect, Conditionally firing an effect.\nLevel 6：setTimeout useEffect(() =\u003e { const timeout = setTimeout(() =\u003e { setCount(count + 1); }, 500); return () =\u003e clearTimeout(timeout); }, [count]); 这段代码和上面的代码可以正常工作。 因为 useEffect 是在每次 count 更改时调用的，所以使用 setTimeout 与调用 setInterval 具有相同的效果。\n这个例子效率很低，每次渲染发生时都会创建新的 setTimeout，React 有一个更好的方式来解决问题。\nLevel 7：useState 的函数更新 useEffect(() =\u003e { const interval = setInterval(() =\u003e { setCount(c =\u003e c + 1); }, 500); return () =\u003e clearInterval(interval); }, []); 在前面的例子中，我们对每次 count 更改运行 useEffect，这是必要的，因为我们需要始终保持最新的当前值。\nuseState 提供 API 来更新以前的状态，而不用捕获当前值。 要做到这一点，我们需要做的就是向 setState 提供 lambda(匿名函数)。\n这段代码工作正常，效率更高。 在组件的生命周期中，我们使用单个 setInterval， clearInterval 只会在卸载组件之后调用一次。\nHooks API Reference: useState, Functional updates.\nLevel 8：局部变量 export default function Level08() { console.log('renderLevel08'); const [count, setCount] = useState(0); let interval = null; const start = () =\u003e { interval = setInterval(() =\u003e { setCount(c =\u003e c + 1); }, 500); }; const stop = () =\u003e { clearInterval(interval); }; return ( \u003cdiv\u003e count =\u003e {count} \u003cbutton onClick={start}\u003estart\u003c/button\u003e \u003cbutton onClick={stop}\u003estop\u003c/button\u003e \u003c/div\u003e ); } 我们增加了 start 和 stop 按钮。 此代码实现不正确，因为 stop 按钮不工作。 因为在每次渲染期间都会创建新的引用(指 interval 的引用)，因此 stop 函数里面 clearInterval 里面的 interval 是 null。\nHooks API Reference: Is there something like instance variables?\nLevel 9：useRef export default function Level09() { console.log('renderLevel09'); const [count, setCount] = useState(0); const intervalRef = useRef(null); const start = () =\u003e { intervalRef.current = setInterval(() =\u003e { setCount(c =\u003e c + 1); }, 500); }; const stop = () =\u003e { clearInterval(intervalRef.current); }; return ( \u003cdiv\u003e count =\u003e {count} \u003cbutton onClick={start}\u003estart\u003c/button\u003e \u003cbutton onClick={stop}\u003estop\u003c/button\u003e \u003c/div\u003e ); } 如果需要变量，useRef 是首选的 Hook。 与局部变量不同，React 确保在每次渲染期间返回相同的引用。\n这个代码看起来是正确的，但是有一个微妙的错误。 如果 start 被多次调用，那么 setInterval 将被多次调用，从而触发资源泄漏。\nHooks API Reference: useRef\nLevel 10: useCallback export default function Level10() { console.log('renderLevel10'); const [count, setCount] = useState(0); const intervalRef = useRef(null); const start = () =\u003e { if (intervalRef.current !== null) { return; } intervalRef.current = setInterval(() =\u003e { setCount(c =\u003e c + 1); }, 500); }; const stop = () =\u003e { if (intervalRef.current === null) { return; } clearInterval(intervalRef.current); intervalRef.current = null; }; return ( \u003cdiv\u003e count =\u003e {count} \u003cbutton onClick={start}\u003estart\u003c/button\u003e \u003cbutton onClick={stop}\u003estop\u003c/button\u003e \u003c/div\u003e ); } 为了避免资源泄漏，如果 interval 已经启动，我们只需忽略调用。 尽管调用 clearInterval (null) 不会触发任何错误，但是只释放一次资源仍然是一个很好的实践。\n此代码没有资源泄漏，实现正确，但可能存在性能问题。\nmemoization 是 React 中主要的性能优化工具。 React.memo 进行浅比较，如果引用相同，则跳过 render 阶段。\n如果 start 函数 和 stop 函数被传递给一个 memoized 组件，整个优化就会失败，因为在每次渲染之后都会返回新的引用。\nReact Hooks: Memoization\nLevel 11: useCallback const intervalRef = useRef(null); const start = useCallback(() =\u003e { if (intervalRef.current !== null) { return; } intervalRef.current = setInterval(() =\u003e { setCount(c =\u003e c + 1); }, 500); }, []); const stop = useCallback(() =\u003e { if (intervalRef.current === null) { return; } clearInterval(intervalRef.current); intervalRef.current = null; }, []); return ( \u003cdiv\u003e count =\u003e {count} \u003cbutton onClick={start}\u003estart\u003c/button\u003e \u003cbutton onClick={stop}\u003estop\u003c/button\u003e \u003c/div\u003e ); } 为了使 React.memo 能够正常工作，我们需要做的就是使用 useCallback 来记忆(memoize)函数。 这样，每次渲染后都会提供相同的函数引用。\n此代码没有资源泄漏，实现正确，没有性能问题，但代码相当复杂，即使对于简单的计数器也是如此。\nHooks API Reference: useCallback\nLevel 12: 自定义 Hook function useCounter(initialValue, ms) { const [count, setCount] = useState(initialValue); const intervalRef = useRef(null); const start = useCallback(() =\u003e { if (intervalRef.current !== null) { return; } intervalRef.current = setInterval(() =\u003e { setCount(c =\u003e c + 1); }, ms); }, []); const stop = useCallback(() =\u003e { if (intervalRef.current === null) { return; } clearInterval(intervalRef.current); intervalRef.current = null; }, []); const reset = useCallback(() =\u003e { setCount(0); }, []); return { count, start, stop, reset }; } 为了简化代码，我们需要将所有复杂性封装在 useCounter 自定义钩子中，并暴露 api: { count，start，stop，reset }。\nexport default function Level12() { console.log('renderLevel12'); const { count, start, stop, reset } = useCounter(0, 500); return ( \u003cdiv\u003e count =\u003e {count} \u003cbutton onClick={start}\u003estart\u003c/button\u003e \u003cbutton onClick={stop}\u003estop\u003c/button\u003e \u003cbutton onClick={reset}\u003ereset\u003c/button\u003e \u003c/div\u003e ); } Hooks API Reference: Using a Custom Hook\nReact Hooks Radar Green 绿色 hooks 是现代 React 应用程序的主要构件。 它们几乎在任何地方都可以安全地使用，而不需要太多的思考\nuseReducer useState useContext Yellow 黄色 hooks 通过使用记忆(memoize)提供了有用的性能优化。 管理生命周期和输入应该谨慎地进行。\nuseCallback useMemo Red 红色 hooks 与易变的世界相互作用，使用副作用。 它们是最强大的，应该极其谨慎地使用。 自定义 hooks 被推荐用于所有重要用途的情况。\nuseRef useEffect useLayoutEffect 用好 React Hooks 的清单 服从Rules of Hooks 钩子的规则. 不要在主渲染函数中做任何副作用 取消订阅 / 弃置 / 销毁所有已使用的资源 Prefer 更喜欢useReducer or functional updates for 或功能更新useStateto prevent reading and writing same value in a hook. 防止在钩子上读写相同的数值 不要在渲染函数中使用可变变量，而应该使用useRef 如果你保存在useRef 的值的生命周期小于组件本身，在处理资源时不要忘记取消设置值 谨慎使用无限递归导致资源衰竭 在需要的时候使用 Memoize 函数和对象来提高性能 正确捕获输入依赖项(undefined=\u003e 每一次渲染,[a, b] =\u003e 当a or 或b改变的时候渲染, 改变,[] =\u003e 只改变一次) 对于复杂的用例可以通过自定义 Hooks 来实现。 ","wordCount":"923","inLanguage":"en","datePublished":"2020-01-07T21:50:00Z","dateModified":"2020-01-07T21:50:00Z","author":{"@type":"Person","name":"桃翁"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E8%AF%91%E6%96%87/296/"},"publisher":{"@type":"Organization","name":"桃园","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/archives/ title=Archives><span>Archives</span></a></li><li><a href=/categories/ title=Categories><span>Categories</span></a></li><li><a href=search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>你可能不知道的 React Hooks</h1><div class=post-meta><span title='2020-01-07 21:50:00 +0000 UTC'>January 7, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;923 words&nbsp;·&nbsp;桃翁&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/%e8%af%91%e6%96%87/2020-01-07-%e4%bd%a0%e5%8f%af%e8%83%bd%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84_React_Hooks_.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%a1%88%e4%be%8b%e7%a0%94%e7%a9%b6-%e5%ae%9e%e7%8e%b0-interval aria-label="案例研究： 实现 Interval">案例研究： 实现 Interval</a><ul><li><a href=#level-0hello-world aria-label="Level 0：Hello World">Level 0：Hello World</a></li><li><a href=#level-1setinterval aria-label="Level 1：setInterval">Level 1：setInterval</a></li><li><a href=#level-2useeffect aria-label="Level 2：useEffect">Level 2：useEffect</a></li><li><a href=#level-3-%e5%8f%aa%e8%bf%90%e8%a1%8c%e4%b8%80%e6%ac%a1 aria-label="Level 3: 只运行一次">Level 3: 只运行一次</a></li><li><a href=#level-4%e6%b8%85%e7%90%86 aria-label="Level 4：清理">Level 4：清理</a></li><li><a href=#level-5%e4%bd%bf%e7%94%a8-count-%e4%bd%9c%e4%b8%ba%e4%be%9d%e8%b5%96%e9%a1%b9 aria-label="Level 5：使用 count 作为依赖项">Level 5：使用 count 作为依赖项</a></li><li><a href=#level-6settimeout aria-label="Level 6：setTimeout">Level 6：setTimeout</a></li><li><a href=#level-7usestate-%e7%9a%84%e5%87%bd%e6%95%b0%e6%9b%b4%e6%96%b0 aria-label="Level 7：useState 的函数更新">Level 7：useState 的函数更新</a></li><li><a href=#level-8%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f aria-label="Level 8：局部变量">Level 8：局部变量</a></li><li><a href=#level-9useref aria-label="Level 9：useRef">Level 9：useRef</a></li><li><a href=#level-10-usecallback aria-label="Level 10: useCallback">Level 10: useCallback</a></li><li><a href=#level-11-usecallback aria-label="Level 11: useCallback">Level 11: useCallback</a></li><li><a href=#level-12-%e8%87%aa%e5%ae%9a%e4%b9%89-hook aria-label="Level 12: 自定义 Hook">Level 12: 自定义 Hook</a></li></ul></li><li><a href=#react-hooks-radar aria-label="React Hooks Radar">React Hooks Radar</a><ul><li><a href=#green aria-label=Green>Green</a></li><li><a href=#yellow aria-label=Yellow>Yellow</a></li><li><a href=#red aria-label=Red>Red</a></li></ul></li><li><a href=#%e7%94%a8%e5%a5%bd-react-hooks-%e7%9a%84%e6%b8%85%e5%8d%95 aria-label="用好 React Hooks 的清单">用好 React Hooks 的清单</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>本文是译文，原文地址是：https://medium.com/@sdolidze/the-iceberg-of-react-hooks-af0b588f43fb</p></blockquote><p><strong>React Hooks</strong> 与类组件不同，它提供了用于优化和组合应用程序的简单方式，并且使用了最少的样板文件。</p><p>如果没有深入的知识，由于微妙的 bug 和抽象层漏洞，可能会出现性能问题，代码复杂性也会增加。</p><p>我已经创建了12个案例研究来演示常见的问题以及解决它们的方法。 我还编写了 <strong>React Hooks Radar</strong> 和 <strong>React Hooks Checklist</strong>，来推荐和快速参考。</p><h2 id=案例研究-实现-interval>案例研究： 实现 Interval<a hidden class=anchor aria-hidden=true href=#案例研究-实现-interval>#</a></h2><p>目标是实现计数器，从 0 开始，每 500 毫秒增加一次。 应提供三个控制按钮: 启动、停止和清除。</p><p><img loading=lazy src=http://imgs.taoweng.site/2020-01-05-134726.gif alt></p><h3 id=level-0hello-world>Level 0：Hello World<a hidden class=anchor aria-hidden=true href=#level-0hello-world>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>Level00</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;renderLevel00&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>count</span><span class=p>,</span> <span class=nx>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nx>count</span> <span class=p>=&gt;</span> <span class=p>{</span><span class=nx>count</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=p>=&gt;</span> <span class=nx>setCount</span><span class=p>(</span><span class=nx>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)}</span><span class=o>&gt;+&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=p>=&gt;</span> <span class=nx>setCount</span><span class=p>(</span><span class=nx>count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)}</span><span class=o>&gt;-&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这是一个简单的、正确实现的计数器，用户单击时计数器的增加或减少。</p><h3 id=level-1setinterval>Level 1：setInterval<a hidden class=anchor aria-hidden=true href=#level-1setinterval>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>Level01</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;renderLevel01&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>count</span><span class=p>,</span> <span class=nx>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setCount</span><span class=p>(</span><span class=nx>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span><span class=nx>count</span> <span class=p>=&gt;</span> <span class=p>{</span><span class=nx>count</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/div&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>此代码的目的是每 500 毫秒增加计数器。 这段代码存在巨大的<strong>内存泄漏</strong>并且实现不正确。 它很容易让浏览器标签崩溃。 由于 Level01 函数在每次渲染发生时被调用，所以每次触发渲染时这个组件都会创建新的 interval。</p><blockquote><p><em>突变、订阅、计时器、日志记录和其他副作用不允许出现在函数组件的主体中(称为 React 的 render 阶段)。 这样做会导致用户界面中的错误和不一致。</em></p></blockquote><p><a href=https://reactjs.org/docs/hooks-reference.html>Hooks API Reference</a>: <a href=https://reactjs.org/docs/hooks-reference.html#useeffect>useEffect</a></p><h3 id=level-2useeffect>Level 2：useEffect<a hidden class=anchor aria-hidden=true href=#level-2useeffect>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>Level02</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;renderLevel02&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>count</span><span class=p>,</span> <span class=nx>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>useEffect</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>setCount</span><span class=p>(</span><span class=nx>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span><span class=nx>Level</span> <span class=mi>2</span><span class=o>:</span> <span class=nx>count</span> <span class=p>=&gt;</span> <span class=p>{</span><span class=nx>count</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/div&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>大多数副作用放在 <code>useEffect</code> 内部。 但是此代码还有巨大的资源泄漏，并且实现不正确。 <code>useEffect</code> 的默认行为是在每次渲染后运行，所以每次计数更改都会创建新的 <strong>Interval</strong>。</p><p><a href=https://reactjs.org/docs/hooks-reference.html>Hooks API Reference</a>: <a href=https://reactjs.org/docs/hooks-reference.html#useeffect>useEffect</a>, <a href=https://reactjs.org/docs/hooks-reference.html#timing-of-effects>Timing of Effects</a>.</p><h3 id=level-3-只运行一次>Level 3: 只运行一次<a hidden class=anchor aria-hidden=true href=#level-3-只运行一次>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>Level03</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;renderLevel03&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>count</span><span class=p>,</span> <span class=nx>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>useEffect</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>setCount</span><span class=p>(</span><span class=nx>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>300</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[]);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span><span class=nx>count</span> <span class=p>=&gt;</span> <span class=p>{</span><span class=nx>count</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/div&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>将**[]**作为 <code>useEffect</code> 的第二个参数，将在 mount 之后只调用一次 function。，即使只调用一次 setInterval，这段代码的实现也是不正确的。</p><p>虽然 <strong>count</strong> 会从 <strong>0</strong> 增加到 <strong>1</strong>，但是不会再增加，只会保持成 <strong>1</strong>。 因为箭头函数只被创建一次，所以箭头函数里面的 <strong>count</strong> 会一直为 0.</p><p>这段代码也存在微妙的资源泄漏。 即使在组件卸载之后，仍将调用 setCount。</p><p><a href=https://reactjs.org/docs/hooks-reference.html>Hooks API Reference</a>: <a href=https://reactjs.org/docs/hooks-reference.html#useeffect>useEffect</a>, <a href=https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect>Conditionally firing an effect</a>.</p><h3 id=level-4清理>Level 4：清理<a hidden class=anchor aria-hidden=true href=#level-4清理>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>useEffect</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>interval</span> <span class=o>=</span> <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>setCount</span><span class=p>(</span><span class=nx>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>300</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>clearInterval</span><span class=p>(</span><span class=nx>interval</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[]);</span>
</span></span></code></pre></div><p>为了防止资源泄漏，Hooks 的生命周期结束时，必须清理所有内容。 在这种情况下，组件卸载后将调用返回的函数。</p><p>这段代码没有资源泄漏，但是实现不正确，就像之前的代码一样。</p><p><a href=https://reactjs.org/docs/hooks-reference.html>Hooks API Reference</a>: <a href=https://reactjs.org/docs/hooks-reference.html#cleaning-up-an-effect>Cleaning up an effect</a>.</p><h3 id=level-5使用-count-作为依赖项>Level 5：使用 count 作为依赖项<a hidden class=anchor aria-hidden=true href=#level-5使用-count-作为依赖项>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>useEffect</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>interval</span> <span class=o>=</span> <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setCount</span><span class=p>(</span><span class=nx>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>clearInterval</span><span class=p>(</span><span class=nx>interval</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=p>[</span><span class=nx>count</span><span class=p>]);</span>
</span></span></code></pre></div><p>给 <strong>useEffect</strong> 提供依赖数组会改变它的生命周期。 在这个例子中，<strong>useEffect</strong> 在 <strong>mount</strong> 之后会被调用一次，并且每次 <code>count</code> 都会改变。 清理函数将在每次 <code>count</code> 更改时被调用以释放前面的资源。</p><p>这段代码工作正常，没有任何错误，但是还是有点不好，每 500 毫秒创建和释放 setInterval， 每个 setInterval 总是调用一次。</p><p><a href=https://reactjs.org/docs/hooks-reference.html>Hooks API Reference</a>: <a href=https://reactjs.org/docs/hooks-reference.html#useeffect>useEffect</a>, <a href=https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect>Conditionally firing an effect</a>.</p><h3 id=level-6settimeout>Level 6：setTimeout<a hidden class=anchor aria-hidden=true href=#level-6settimeout>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>useEffect</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>timeout</span> <span class=o>=</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setCount</span><span class=p>(</span><span class=nx>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>clearTimeout</span><span class=p>(</span><span class=nx>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=p>[</span><span class=nx>count</span><span class=p>]);</span>
</span></span></code></pre></div><p>这段代码和上面的代码可以正常工作。 因为 useEffect 是在每次 count 更改时调用的，所以使用 setTimeout 与调用 setInterval 具有相同的效果。</p><p>这个例子效率很低，每次渲染发生时都会创建新的 setTimeout，React 有一个更好的方式来解决问题。</p><h3 id=level-7usestate-的函数更新>Level 7：useState 的函数更新<a hidden class=anchor aria-hidden=true href=#level-7usestate-的函数更新>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>useEffect</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>interval</span> <span class=o>=</span> <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setCount</span><span class=p>(</span><span class=nx>c</span> <span class=p>=&gt;</span> <span class=nx>c</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>clearInterval</span><span class=p>(</span><span class=nx>interval</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=p>[]);</span>
</span></span></code></pre></div><p>在前面的例子中，我们对每次 <strong>count</strong> 更改运行 <strong>useEffect</strong>，这是必要的，因为我们需要始终保持最新的当前值。</p><p><strong>useState</strong> 提供 API 来更新以前的状态，而不用捕获当前值。 要做到这一点，我们需要做的就是向 setState 提供 lambda(匿名函数)。</p><p>这段代码工作正常，效率更高。 在组件的生命周期中，我们使用单个 <code>setInterval</code>， <code>clearInterval</code> 只会在卸载组件之后调用一次。</p><p><a href=https://reactjs.org/docs/hooks-reference.html>Hooks API Reference</a>: <a href=https://reactjs.org/docs/hooks-reference.html#usestate>useState</a>, <a href=https://reactjs.org/docs/hooks-reference.html#functional-updates>Functional updates</a>.</p><h3 id=level-8局部变量>Level 8：局部变量<a hidden class=anchor aria-hidden=true href=#level-8局部变量>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>Level08</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;renderLevel08&#39;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>count</span><span class=p>,</span> <span class=nx>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>interval</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>start</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>interval</span> <span class=o>=</span> <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>setCount</span><span class=p>(</span><span class=nx>c</span> <span class=p>=&gt;</span> <span class=nx>c</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>stop</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>clearInterval</span><span class=p>(</span><span class=nx>interval</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nx>count</span> <span class=p>=&gt;</span> <span class=p>{</span><span class=nx>count</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>start</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>start</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>stop</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>stop</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们增加了 start 和 stop 按钮。 此代码实现不正确，因为 stop 按钮不工作。 因为在每次渲染期间都会创建新的引用(指 interval 的引用)，因此 stop 函数里面 clearInterval 里面的 interval 是 null。</p><p><a href=https://reactjs.org/docs/hooks-reference.html>Hooks API Reference</a>: <a href=https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables>Is there something like instance variables?</a></p><h3 id=level-9useref>Level 9：useRef<a hidden class=anchor aria-hidden=true href=#level-9useref>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>Level09</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;renderLevel09&#39;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>count</span><span class=p>,</span> <span class=nx>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>intervalRef</span> <span class=o>=</span> <span class=nx>useRef</span><span class=p>(</span><span class=kc>null</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>start</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>setCount</span><span class=p>(</span><span class=nx>c</span> <span class=p>=&gt;</span> <span class=nx>c</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>stop</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>clearInterval</span><span class=p>(</span><span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nx>count</span> <span class=p>=&gt;</span> <span class=p>{</span><span class=nx>count</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>start</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>start</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>stop</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>stop</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果需要变量，useRef 是首选的 Hook。 与局部变量不同，React 确保在每次渲染期间返回相同的引用。</p><p>这个代码看起来是正确的，但是有一个微妙的错误。 如果 start 被多次调用，那么 setInterval 将被多次调用，从而触发资源泄漏。</p><p><a href=https://reactjs.org/docs/hooks-reference.html>Hooks API Reference</a>: <a href=https://reactjs.org/docs/hooks-reference.html#useref>useRef</a></p><h3 id=level-10-usecallback>Level 10: useCallback<a hidden class=anchor aria-hidden=true href=#level-10-usecallback>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>Level10</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;renderLevel10&#39;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>count</span><span class=p>,</span> <span class=nx>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>intervalRef</span> <span class=o>=</span> <span class=nx>useRef</span><span class=p>(</span><span class=kc>null</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>start</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>    
</span></span><span class=line><span class=cl>    <span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>setCount</span><span class=p>(</span><span class=nx>c</span> <span class=p>=&gt;</span> <span class=nx>c</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>stop</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>===</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>    
</span></span><span class=line><span class=cl>    <span class=nx>clearInterval</span><span class=p>(</span><span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nx>count</span> <span class=p>=&gt;</span> <span class=p>{</span><span class=nx>count</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>start</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>start</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>stop</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>stop</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>为了避免资源泄漏，如果 <code>interval</code> 已经启动，我们只需忽略调用。 尽管调用 <code>clearInterval (null)</code> 不会触发任何错误，但是只释放一次资源仍然是一个很好的实践。</p><p>此代码没有资源泄漏，实现正确，但可能存在性能问题。</p><p><strong>memoization</strong> 是 <strong>React</strong> 中主要的性能优化工具。 <strong>React.memo</strong> 进行浅比较，如果引用相同，则跳过 render 阶段。</p><p>如果 <strong>start</strong> 函数 和 <strong>stop</strong> 函数被传递给一个 <strong>memoized</strong> 组件，整个优化就会失败，因为在每次渲染之后都会返回新的引用。</p><p><a href=https://medium.com/@sdolidze/react-hooks-memoization-99a9a91c8853><strong>React Hooks: Memoization</strong></a></p><h3 id=level-11-usecallback>Level 11: useCallback<a hidden class=anchor aria-hidden=true href=#level-11-usecallback>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>intervalRef</span> <span class=o>=</span> <span class=nx>useRef</span><span class=p>(</span><span class=kc>null</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>start</span> <span class=o>=</span> <span class=nx>useCallback</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>    
</span></span><span class=line><span class=cl>    <span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>setCount</span><span class=p>(</span><span class=nx>c</span> <span class=p>=&gt;</span> <span class=nx>c</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[]);</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>stop</span> <span class=o>=</span> <span class=nx>useCallback</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>===</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>    
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>clearInterval</span><span class=p>(</span><span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nx>count</span> <span class=p>=&gt;</span> <span class=p>{</span><span class=nx>count</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>start</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>start</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>stop</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>stop</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>为了使 <strong>React.memo</strong> 能够正常工作，我们需要做的就是使用 <strong>useCallback</strong> 来记忆(memoize)函数。 这样，每次渲染后都会提供相同的函数引用。</p><p>此代码没有资源泄漏，实现正确，没有性能问题，但代码相当复杂，即使对于简单的计数器也是如此。</p><p><a href=https://reactjs.org/docs/hooks-reference.html>Hooks API Reference</a>: <a href=https://reactjs.org/docs/hooks-reference.html#usecallback>useCallback</a></p><h3 id=level-12-自定义-hook>Level 12: 自定义 Hook<a hidden class=anchor aria-hidden=true href=#level-12-自定义-hook>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>useCounter</span><span class=p>(</span><span class=nx>initialValue</span><span class=p>,</span> <span class=nx>ms</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>count</span><span class=p>,</span> <span class=nx>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=nx>initialValue</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>intervalRef</span> <span class=o>=</span> <span class=nx>useRef</span><span class=p>(</span><span class=kc>null</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>start</span> <span class=o>=</span> <span class=nx>useCallback</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>    
</span></span><span class=line><span class=cl>    <span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>setCount</span><span class=p>(</span><span class=nx>c</span> <span class=p>=&gt;</span> <span class=nx>c</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=nx>ms</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[]);</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>stop</span> <span class=o>=</span> <span class=nx>useCallback</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>===</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>    
</span></span><span class=line><span class=cl>    <span class=nx>clearInterval</span><span class=p>(</span><span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>intervalRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[]);</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>reset</span> <span class=o>=</span> <span class=nx>useCallback</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setCount</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=p>[]);</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>{</span> <span class=nx>count</span><span class=p>,</span> <span class=nx>start</span><span class=p>,</span> <span class=nx>stop</span><span class=p>,</span> <span class=nx>reset</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>为了简化代码，我们需要将所有复杂性封装在 <strong>useCounter</strong> 自定义钩子中，并暴露 api: <strong>{ count，start，stop，reset }。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>Level12</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;renderLevel12&#39;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>{</span> <span class=nx>count</span><span class=p>,</span> <span class=nx>start</span><span class=p>,</span> <span class=nx>stop</span><span class=p>,</span> <span class=nx>reset</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>useCounter</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>500</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nx>count</span> <span class=p>=&gt;</span> <span class=p>{</span><span class=nx>count</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>start</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>start</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>stop</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>stop</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>reset</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>reset</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://reactjs.org/docs/hooks-reference.html>Hooks API Reference</a>: <a href=https://reactjs.org/docs/hooks-custom.html#using-a-custom-hook>Using a Custom Hook</a></p><h2 id=react-hooks-radar>React Hooks Radar<a hidden class=anchor aria-hidden=true href=#react-hooks-radar>#</a></h2><p><img loading=lazy src=https://miro.medium.com/max/3840/0*Px-sg5tvCOOlPcJb.jpeg alt></p><h3 id=green>Green<a hidden class=anchor aria-hidden=true href=#green>#</a></h3><p>绿色 hooks 是现代 React 应用程序的主要构件。 它们几乎在任何地方都可以安全地使用，而不需要太多的思考</p><ol><li><code>useReducer</code></li><li><code>useState</code></li><li><code>useContext</code></li></ol><h3 id=yellow>Yellow<a hidden class=anchor aria-hidden=true href=#yellow>#</a></h3><p>黄色 hooks 通过使用记忆(memoize)提供了有用的性能优化。 管理生命周期和输入应该谨慎地进行。</p><ol><li><code>useCallback</code></li><li><code>useMemo</code></li></ol><h3 id=red>Red<a hidden class=anchor aria-hidden=true href=#red>#</a></h3><p>红色 hooks 与易变的世界相互作用，使用副作用。 它们是最强大的，应该极其谨慎地使用。 自定义 hooks 被推荐用于所有重要用途的情况。</p><ol><li><code>useRef</code></li><li><code>useEffect</code></li><li><code>useLayoutEffect</code></li></ol><h2 id=用好-react-hooks-的清单>用好 React Hooks 的清单<a hidden class=anchor aria-hidden=true href=#用好-react-hooks-的清单>#</a></h2><ol><li>服从<a href=https://reactjs.org/docs/hooks-rules.html>Rules of Hooks 钩子的规则</a>.</li><li>不要在主渲染函数中做任何副作用</li><li>取消订阅 / 弃置 / 销毁所有已使用的资源</li><li>Prefer 更喜欢<code>useReducer</code> or functional updates for 或功能更新<code>useState</code>to prevent reading and writing same value in a hook. 防止在钩子上读写相同的数值</li><li>不要在渲染函数中使用可变变量，而应该使用<code>useRef</code></li><li>如果你保存在<code>useRef</code> 的值的生命周期小于组件本身，在处理资源时不要忘记取消设置值</li><li>谨慎使用无限递归导致资源衰竭</li><li>在需要的时候使用 Memoize 函数和对象来提高性能</li><li>正确捕获输入依赖项(<code>undefined</code>=> 每一次渲染,<code>[a, b]</code> => 当<code>a</code> or 或<code>b</code>改变的时候渲染, 改变,<code>[]</code> => 只改变一次)</li><li>对于复杂的用例可以通过自定义 Hooks 来实现。</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/react/>react</a></li><li><a href=/tags/%E8%AF%91%E6%96%87/>译文</a></li></ul><nav class=paginav><a class=prev href=/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/299/><span class=title>« Prev</span><br><span>读者问题|关于如何学习的讨论</span></a>
<a class=next href=/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/295/><span class=title>Next »</span><br><span>2019 个人深度总结</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 你可能不知道的 React Hooks on twitter" href="https://twitter.com/intent/tweet/?text=%e4%bd%a0%e5%8f%af%e8%83%bd%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%20React%20Hooks&url=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f296%2f&hashtags=react%2c%e8%af%91%e6%96%87"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 你可能不知道的 React Hooks on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f296%2f&title=%e4%bd%a0%e5%8f%af%e8%83%bd%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%20React%20Hooks&summary=%e4%bd%a0%e5%8f%af%e8%83%bd%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%20React%20Hooks&source=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f296%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 你可能不知道的 React Hooks on reddit" href="https://reddit.com/submit?url=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f296%2f&title=%e4%bd%a0%e5%8f%af%e8%83%bd%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%20React%20Hooks"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 你可能不知道的 React Hooks on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f296%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 你可能不知道的 React Hooks on whatsapp" href="https://api.whatsapp.com/send?text=%e4%bd%a0%e5%8f%af%e8%83%bd%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%20React%20Hooks%20-%20%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f296%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 你可能不知道的 React Hooks on telegram" href="https://telegram.me/share/url?text=%e4%bd%a0%e5%8f%af%e8%83%bd%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%20React%20Hooks&url=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f296%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href>桃园</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>