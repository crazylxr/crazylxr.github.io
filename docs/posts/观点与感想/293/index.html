<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>根据 React 历史来聊如何理解虚拟 DOM | 桃园</title><meta name=keywords content="react"><meta name=description content="最近我发现很多面试题里面都有「如何理解虚拟 DOM」这个题，我觉得这个题应该没有想象中那么好答，因为很多人没有真正理解虚拟 DOM 它的价值所在，我这篇从虚拟 DOM 的诞生过程来引出它的价值以及历史地位，帮助你深入的理解它。
什么是虚拟DOM 本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述。
对，就是这么简单！
就是一个复杂一点的对象而已，没什么好说的，重点是为什么要有这个东西，以及有了这个描述有什么好处才是我们今天要介绍的内容。
为什么要有虚拟DOM 再谈为什么要用虚拟 DOM 之前，先来聊一聊 React 是怎么诞生的，毕竟在了解历史背景，再去思考他的诞生，就知道是必然会出现的。
再查了很多关于 React 的历史相关的文章，这篇文章我感觉比较值得令我信服：React 是怎样炼成的。
众所周知，Facebook 是 PHP 大户，所以 React 最开始的灵感就来至于 PHP。
字符串拼接时代 - 2004 在 2004 年这个时候，大家都还在用 PHP 的字符串拼接来开发网站：
$str = '<ul>'; foreach ($talks as $talk) { $str += '<li>' . $talk->name . '</li>'; } $str += '</ul>'; 这种方式代码写出来不好看不说，还容易造成 XSS 等安全问题。
应对方法是对用户的任何输入都进行转义（Escape）。但是如果对字符串进行多次转义，那么反转义的次数也必须是相同的，否则会无法得到原内容。如果又不小心把 HTML 标签（Markup）给转义了，那么 HTML 标签会直接显示给用户，从而导致很差的用户体验。
XHP 时代 - 2010 到了 2010 年，为了更加高效的编码，同时也避免转义 HTML 标签的错误，Facebook 开发了 XHP 。XHP 是对 PHP 的语法拓展，它允许开发者直接在 PHP 中使用 HTML 标签，而不再使用字符串。"><meta name=author content="桃翁"><link rel=canonical href=/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/293/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.355db47b48ce042e543348876cce64165399cee8651ce7514d3c4b076b02f0aa.css integrity="sha256-NV20e0jOBC5UM0iHbM5kFlOZzuhlHOdRTTxLB2sC8Ko=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="根据 React 历史来聊如何理解虚拟 DOM"><meta property="og:description" content="最近我发现很多面试题里面都有「如何理解虚拟 DOM」这个题，我觉得这个题应该没有想象中那么好答，因为很多人没有真正理解虚拟 DOM 它的价值所在，我这篇从虚拟 DOM 的诞生过程来引出它的价值以及历史地位，帮助你深入的理解它。
什么是虚拟DOM 本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述。
对，就是这么简单！
就是一个复杂一点的对象而已，没什么好说的，重点是为什么要有这个东西，以及有了这个描述有什么好处才是我们今天要介绍的内容。
为什么要有虚拟DOM 再谈为什么要用虚拟 DOM 之前，先来聊一聊 React 是怎么诞生的，毕竟在了解历史背景，再去思考他的诞生，就知道是必然会出现的。
再查了很多关于 React 的历史相关的文章，这篇文章我感觉比较值得令我信服：React 是怎样炼成的。
众所周知，Facebook 是 PHP 大户，所以 React 最开始的灵感就来至于 PHP。
字符串拼接时代 - 2004 在 2004 年这个时候，大家都还在用 PHP 的字符串拼接来开发网站：
$str = '<ul>'; foreach ($talks as $talk) { $str += '<li>' . $talk->name . '</li>'; } $str += '</ul>'; 这种方式代码写出来不好看不说，还容易造成 XSS 等安全问题。
应对方法是对用户的任何输入都进行转义（Escape）。但是如果对字符串进行多次转义，那么反转义的次数也必须是相同的，否则会无法得到原内容。如果又不小心把 HTML 标签（Markup）给转义了，那么 HTML 标签会直接显示给用户，从而导致很差的用户体验。
XHP 时代 - 2010 到了 2010 年，为了更加高效的编码，同时也避免转义 HTML 标签的错误，Facebook 开发了 XHP 。XHP 是对 PHP 的语法拓展，它允许开发者直接在 PHP 中使用 HTML 标签，而不再使用字符串。"><meta property="og:type" content="article"><meta property="og:url" content="/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/293/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="og:site_name" content="桃园"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="根据 React 历史来聊如何理解虚拟 DOM"><meta name=twitter:description content="最近我发现很多面试题里面都有「如何理解虚拟 DOM」这个题，我觉得这个题应该没有想象中那么好答，因为很多人没有真正理解虚拟 DOM 它的价值所在，我这篇从虚拟 DOM 的诞生过程来引出它的价值以及历史地位，帮助你深入的理解它。
什么是虚拟DOM 本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述。
对，就是这么简单！
就是一个复杂一点的对象而已，没什么好说的，重点是为什么要有这个东西，以及有了这个描述有什么好处才是我们今天要介绍的内容。
为什么要有虚拟DOM 再谈为什么要用虚拟 DOM 之前，先来聊一聊 React 是怎么诞生的，毕竟在了解历史背景，再去思考他的诞生，就知道是必然会出现的。
再查了很多关于 React 的历史相关的文章，这篇文章我感觉比较值得令我信服：React 是怎样炼成的。
众所周知，Facebook 是 PHP 大户，所以 React 最开始的灵感就来至于 PHP。
字符串拼接时代 - 2004 在 2004 年这个时候，大家都还在用 PHP 的字符串拼接来开发网站：
$str = '<ul>'; foreach ($talks as $talk) { $str += '<li>' . $talk->name . '</li>'; } $str += '</ul>'; 这种方式代码写出来不好看不说，还容易造成 XSS 等安全问题。
应对方法是对用户的任何输入都进行转义（Escape）。但是如果对字符串进行多次转义，那么反转义的次数也必须是相同的，否则会无法得到原内容。如果又不小心把 HTML 标签（Markup）给转义了，那么 HTML 标签会直接显示给用户，从而导致很差的用户体验。
XHP 时代 - 2010 到了 2010 年，为了更加高效的编码，同时也避免转义 HTML 标签的错误，Facebook 开发了 XHP 。XHP 是对 PHP 的语法拓展，它允许开发者直接在 PHP 中使用 HTML 标签，而不再使用字符串。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"根据 React 历史来聊如何理解虚拟 DOM","item":"/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/293/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"根据 React 历史来聊如何理解虚拟 DOM","name":"根据 React 历史来聊如何理解虚拟 DOM","description":"最近我发现很多面试题里面都有「如何理解虚拟 DOM」这个题，我觉得这个题应该没有想象中那么好答，因为很多人没有真正理解虚拟 DOM 它的价值所在，我这篇从虚拟 DOM 的诞生过程来引出它的价值以及历史地位，帮助你深入的理解它。\n什么是虚拟DOM 本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述。\n对，就是这么简单！\n就是一个复杂一点的对象而已，没什么好说的，重点是为什么要有这个东西，以及有了这个描述有什么好处才是我们今天要介绍的内容。\n为什么要有虚拟DOM 再谈为什么要用虚拟 DOM 之前，先来聊一聊 React 是怎么诞生的，毕竟在了解历史背景，再去思考他的诞生，就知道是必然会出现的。\n再查了很多关于 React 的历史相关的文章，这篇文章我感觉比较值得令我信服：React 是怎样炼成的。\n众所周知，Facebook 是 PHP 大户，所以 React 最开始的灵感就来至于 PHP。\n字符串拼接时代 - 2004 在 2004 年这个时候，大家都还在用 PHP 的字符串拼接来开发网站：\n$str = \u0026#39;\u0026lt;ul\u0026gt;\u0026#39;; foreach ($talks as $talk) { $str += \u0026#39;\u0026lt;li\u0026gt;\u0026#39; . $talk-\u0026gt;name . \u0026#39;\u0026lt;/li\u0026gt;\u0026#39;; } $str += \u0026#39;\u0026lt;/ul\u0026gt;\u0026#39;; 这种方式代码写出来不好看不说，还容易造成 XSS 等安全问题。\n应对方法是对用户的任何输入都进行转义（Escape）。但是如果对字符串进行多次转义，那么反转义的次数也必须是相同的，否则会无法得到原内容。如果又不小心把 HTML 标签（Markup）给转义了，那么 HTML 标签会直接显示给用户，从而导致很差的用户体验。\nXHP 时代 - 2010 到了 2010 年，为了更加高效的编码，同时也避免转义 HTML 标签的错误，Facebook 开发了 XHP 。XHP 是对 PHP 的语法拓展，它允许开发者直接在 PHP 中使用 HTML 标签，而不再使用字符串。","keywords":["react"],"articleBody":"最近我发现很多面试题里面都有「如何理解虚拟 DOM」这个题，我觉得这个题应该没有想象中那么好答，因为很多人没有真正理解虚拟 DOM 它的价值所在，我这篇从虚拟 DOM 的诞生过程来引出它的价值以及历史地位，帮助你深入的理解它。\n什么是虚拟DOM 本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述。\n对，就是这么简单！\n就是一个复杂一点的对象而已，没什么好说的，重点是为什么要有这个东西，以及有了这个描述有什么好处才是我们今天要介绍的内容。\n为什么要有虚拟DOM 再谈为什么要用虚拟 DOM 之前，先来聊一聊 React 是怎么诞生的，毕竟在了解历史背景，再去思考他的诞生，就知道是必然会出现的。\n再查了很多关于 React 的历史相关的文章，这篇文章我感觉比较值得令我信服：React 是怎样炼成的。\n众所周知，Facebook 是 PHP 大户，所以 React 最开始的灵感就来至于 PHP。\n字符串拼接时代 - 2004 在 2004 年这个时候，大家都还在用 PHP 的字符串拼接来开发网站：\n$str = ''; foreach ($talks as $talk) { $str += '' . $talk-\u003ename . ''; } $str += ''; 这种方式代码写出来不好看不说，还容易造成 XSS 等安全问题。\n应对方法是对用户的任何输入都进行转义（Escape）。但是如果对字符串进行多次转义，那么反转义的次数也必须是相同的，否则会无法得到原内容。如果又不小心把 HTML 标签（Markup）给转义了，那么 HTML 标签会直接显示给用户，从而导致很差的用户体验。\nXHP 时代 - 2010 到了 2010 年，为了更加高效的编码，同时也避免转义 HTML 标签的错误，Facebook 开发了 XHP 。XHP 是对 PHP 的语法拓展，它允许开发者直接在 PHP 中使用 HTML 标签，而不再使用字符串。\n$content = \u003cul /\u003e; foreach ($talks as $talk) { $content-\u003eappendChild(\u003cli\u003e{$talk-\u003ename}\u003c/li\u003e); } 这样的话，所有的 HTML 标签都使用不同于 PHP 的语法，我们可以轻易的分辨哪些需要转义哪些不需要转义。\n不久的后来，Facebook 的工程师又发现他们还可以创建自定义标签，而且通过组合自定义标签有助于构建大型应用。\nJSX - 2013 到了 2013 年，前端工程师 Jordan Walke 向他的经理提出了一个大胆的想法：把 XHP 的拓展功能迁移到 JS 中。首要任务是需要一个拓展来让 JS 支持 XML 语法，该拓展称为 JSX。因为当时由于 Node.js 在 Facebook 已经有很多实践，所以很快就实现了 JSX。\n可以猜想一下为什么要迁移到 js 中，我猜想应该是前后端分离导致的。\nconst content = ( \u003cTalkList\u003e { talks.map(talk =\u003e \u003cTalk talk={talk} /\u003e)} \u003c/TalkList\u003e ); React 在这个时候，就有另外一个很棘手的问题，那就是在进行更新的时候，需要去操作 DOM，传统 DOM API 细节太多，操作复杂，所以就很容易出现 Bug，而且代码难以维护。\n然后就想到了 PHP 时代的更新机制，每当有数据改变时，只需要跳到一个由 PHP 全新渲染的新页面即可。\n从开发者的角度来看的话，这种方式开发应用是非常简单的，因为它不需要担心变更，且界面上用户数据改变时所有内容都是同步的。\n为此 React 提出了一个新的思想，即始终整体“刷新”页面\n当发生前后状态变化时，React 会自动更新 UI，让我们从复杂的 UI 操作中解放出来，使我们只需关于状态以及最终 UI 长什么样。\n下面看看局部刷新和整体刷新的区别。\n图片来自于极客时间王沛老师的《React进阶与实战》\n局部刷新：\n// 下面是伪代码 var ul = find(ul) // 先找到 ul ul.append(`${message3}`) //然后再将message3插到最后 // 想想如果是不插到最后一个，而是插到中间的第n个 var ul = find(ul) // 先找到 ul var preli = find(li(n-1)) // 再找到 n-1 的一个 li preli.next(`${message3}`) // 再插入到 n-1 个的后面 整体刷新：\nUI = f(messages) // 整体刷新 3 条消息，只需要调用 f 函数 // 这个是在初始渲染的时候就定义好的，更新的时候不用去管 function f(messages) { return \u003cul\u003e {messages.map(message =\u003e \u003cli\u003e{ message }\u003c/li\u003e)} \u003c/ul\u003e } 这个时候，我只需要关系我的状态（数据是什么），以及 UI 长什么样（布局），不再需要关系操作细节。\n这种方式虽然简单粗暴，但是很明显的缺点，就是很慢。\n另外还有一个问题就是这样无法包含节点的状态。比如它会失去当前聚焦的元素和光标，以及文本选择和页面滚动位置，这些都是页面的当前状态。\nDiff 为了解决上面说的问题，对于没有改变的 DOM 节点，让它保持原样不动，仅仅创建并替换变更过的 DOM 节点。这种方式实现了 DOM 节点复用（Reuse）。\n至此，只要能够识别出哪些节点改变了，那么就可以实现对 DOM 的更新。于是问题就转化为如何比对两个 DOM 的差异。\n说道对比差异，可能很容易想到版本控制(git)。\nDOM 是树形结构，所以 diff 算法必须是针对树形结构的。目前已知的完整树形结构 diff 算法复杂度为 O(n^3) 。\n完整的 Tree diff 实现算法。\n但是时间复杂度 O(n^3) 太高了，所以Facebook工程师考虑到组件的特殊情况，然后将复杂度降低到了 O(n)。\n附：详细的 diff 理解：不可思议的 react diff 。\nVirtual DOM 前面说到，React 其实实现了对 DOM 节点的版本控制。\n做过 JS 应用优化的人可能都知道，DOM 是复杂的，对它的操作（尤其是查询和创建）是非常慢非常耗费资源的。看下面的例子，仅创建一个空白的 div，其实例属性就达到 231 个。\n// Chrome v63 const div = document.createElement('div'); let m = 0; for (let k in div) { m++; } console.log(m); // 231 对于 DOM 这么多属性，其实大部分属性对于做 Diff 是没有任何用处的，所以如果用更轻量级的 JS 对象来代替复杂的 DOM 节点，然后把对 DOM 的 diff 操作转移到 JS 对象，就可以避免大量对 DOM 的查询操作。这个更轻量级的 JS 对象就称为 Virtual DOM 。\n那么现在的过程就是这样：\n维护一个使用 JS 对象表示的 Virtual DOM，与真实 DOM 一一对应 对前后两个 Virtual DOM 做 diff ，生成变更（Mutation） 把变更应用于真实 DOM，生成最新的真实 DOM 可以看出，因为要把变更应用到真实 DOM 上，所以还是避免不了要直接操作 DOM ，但是 React 的 diff 算法会把 DOM 改动次数降到最低。\n剩下的历史就不谈了，已经引出这篇文章的重点：虚拟 DOM。详细的历史可见：React 是怎样炼成的，文中历史部分内容很多摘抄与此。\n总结 传统前端的编程方式是命令式的，直接操纵DOM，告诉浏览器该怎么干。这样的问题就是，大量的代码被用于操作 DOM 元素，且代码可读性差，可维护性低。\nReact 的出现，将命令式变成了声明式，摒弃了直接操作 DOM 的细节，只关注数据的变动，DOM 操作由框架来完成，从而大幅度提升了代码的可读性和可维护性。\n在初期我们可以看到，数据的变动导致整个页面的刷新，这种效率很低，因为可能是局部的数据变化，但是要刷新整个页面，造成了不必要的开销。\n所以就有了 Diff 过程，将数据变动前后的 DOM 结构先进行比较，找出两者的不同处，然后再对不同之处进行更新渲染。\n但是由于整个 DOM 结构又太大，所以采用了更轻量级的对 DOM 的描述—虚拟 DOM。\n不过需要注意的是，虚拟 DOM 和 Diff 算法的出现是为了解决由命令式编程转变为声明式编程、数据驱动后所带来的性能问题的。换句话说，直接操作 DOM 的性能并不会低于虚拟 DOM 和 Diff 算法，甚至还会优于。\n这么说的原因是因为 Diff 算法的比较过程，比较是为了找出不同从而有的放矢的更新页面。但是比较也是要消耗性能的。而直接操作 DOM 就是有的放矢，我们知道该更新什么不该更新什么，所以不需要有比较的过程。所以直接操作 DOM 效率可能更高。\nReact 厉害的地方并不是说它比 DOM 快，而是说不管你数据怎么变化，我都可以以最小的代价来进行更新 DOM。 方法就是我在内存里面用新的数据刷新一个虚拟 DOM 树，然后新旧 DOM 进行比较，找出差异，再更新到 DOM 树上。\n框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。\n如果你想了解更多的虚拟 DOM 与性能的关系，请看下面公众号里面的两篇文章和那个知乎话题，会让你对虚拟 DOM 又更深层次的理解。\n别再说虚拟 DOM 快了，要被打脸的 深入理解虚拟 DOM，它真的不快 网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么 另外再提一个点，很多人会把 Diff 、数据更新、提升性能等概念绑定起来，但是你想想这个问题：React 由于只触发更新,而不能知道精确变化的数据,所以需要 diff 来找出差异然后 patch 差异队列。Vue 采用数据劫持的手段可以精准拿到变化的数据,为什么还要用虚拟DOM？\n虚拟DOM 的作用 要想回答上面那个问题，真的不要仅仅以为虚拟 DOM 或者 React 是来解决性能问题的，好处可还有很多呢。下面我总结了一些虚拟 DOM 好作用。\nVirtual DOM 在牺牲(牺牲很关键)部分性能的前提下，增加了可维护性，这也是很多框架的通性。 实现了对 DOM 的集中化操作，在数据改变时先对虚拟 DOM 进行修改，再反映到真实的 DOM中，用最小的代价来更新DOM，提高效率(提升效率要想想是跟哪个阶段比提升了效率，别只记住了这一条)。 打开了函数式 UI 编程的大门。 可以渲染到 DOM 以外的端，使得框架跨平台，比如 ReactNative，React VR 等。 可以更好的实现 SSR，同构渲染等。这条其实是跟上面一条差不多的。 组件的高度抽象化。 既然虚拟 DOM 有这么多作用，那么上面的问题，Vue 采用虚拟 DOM 的原因是什么呢？\nVue 2.0 引入 vdom 的主要原因是 vdom 把渲染过程抽象化了，从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标。 来自尤大文章：Vue 的理念问题\n虚拟 DOM 的缺点 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。 虚拟 DOM 需要在内存中的维护一份 DOM 的副本(更上面一条其实也差不多，上面一条是从速度上，这条是空间上)。 如果虚拟 DOM 大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。所以，如果你有一个DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢。但对于大多数单页面应用，这应该都会更快。 总结 本文在介绍虚拟 DOM 并没有像其他文章一样去解释它的实现以及相关的 Diff 算法，关于 Diff 算法可以看这篇 虚拟 DOM 到底是什么？文中介绍了很多库的 diff 算法，可见其实 React 的 diff 算法并不算太快。\n而是通过历史来得出他的价值体现，从历史怎么看大牛们是怎么一步一步的去解决问题，从历史中看为什么别人能做出这么伟大的东西，而我们不能？\n每个伟大的产品都会有非常多的背景支持，都是一步一步发展而来的。\n另外洗清了一个错误观念：很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。\n虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。\n最后希望大家多思考，跟随者浪潮站在浪潮之巅。\n参考链接 虚拟DOM为何出现以及性能问题？ React 是怎样炼成的 ","wordCount":"550","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"桃翁"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/293/"},"publisher":{"@type":"Organization","name":"桃园","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/archives/ title=Archives><span>Archives</span></a></li><li><a href=/categories/ title=Categories><span>Categories</span></a></li><li><a href=search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>根据 React 历史来聊如何理解虚拟 DOM</h1><div class=post-meta>3 min&nbsp;·&nbsp;550 words&nbsp;·&nbsp;桃翁&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/%e8%a7%82%e7%82%b9%e4%b8%8e%e6%84%9f%e6%83%b3/2019-12-22-%e6%a0%b9%e6%8d%ae_React_%e5%8e%86%e5%8f%b2%e6%9d%a5%e8%81%8a%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3%e8%99%9a%e6%8b%9f_DOM.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e8%99%9a%e6%8b%9fdom aria-label=什么是虚拟DOM>什么是虚拟DOM</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%9c%89%e8%99%9a%e6%8b%9fdom aria-label=为什么要有虚拟DOM>为什么要有虚拟DOM</a><ul><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%8b%bc%e6%8e%a5%e6%97%b6%e4%bb%a3---2004 aria-label="字符串拼接时代 - 2004">字符串拼接时代 - 2004</a></li><li><a href=#xhp-%e6%97%b6%e4%bb%a3---2010 aria-label="XHP 时代 - 2010">XHP 时代 - 2010</a></li><li><a href=#jsx---2013 aria-label="JSX - 2013">JSX - 2013</a></li><li><a href=#react aria-label=React>React</a></li></ul></li><li><a href=#diff aria-label=Diff>Diff</a><ul><li><a href=#virtual-dom aria-label="Virtual DOM">Virtual DOM</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li><li><a href=#%e8%99%9a%e6%8b%9fdom-%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label="虚拟DOM 的作用">虚拟DOM 的作用</a></li><li><a href=#%e8%99%9a%e6%8b%9f-dom-%e7%9a%84%e7%bc%ba%e7%82%b9 aria-label="虚拟 DOM 的缺点">虚拟 DOM 的缺点</a></li><li><a href=#%e6%80%bb%e7%bb%93-1 aria-label=总结>总结</a></li><li><a href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5 aria-label=参考链接>参考链接</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>最近我发现很多面试题里面都有「如何理解虚拟 DOM」这个题，我觉得这个题应该没有想象中那么好答，因为很多人没有真正理解虚拟 DOM 它的价值所在，我这篇从虚拟 DOM 的诞生过程来引出它的价值以及历史地位，帮助你深入的理解它。</p><h2 id=什么是虚拟dom>什么是虚拟DOM<a hidden class=anchor aria-hidden=true href=#什么是虚拟dom>#</a></h2><p><strong>本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述。</strong></p><p>对，就是这么简单！</p><p>就是一个复杂一点的对象而已，没什么好说的，重点是为什么要有这个东西，以及有了这个描述有什么好处才是我们今天要介绍的内容。</p><h2 id=为什么要有虚拟dom>为什么要有虚拟DOM<a hidden class=anchor aria-hidden=true href=#为什么要有虚拟dom>#</a></h2><p>再谈为什么要用虚拟 DOM 之前，先来聊一聊 React 是怎么诞生的，毕竟在了解历史背景，再去思考他的诞生，就知道是必然会出现的。</p><p>再查了很多关于 React 的历史相关的文章，这篇文章我感觉比较值得令我信服：<a href=https://segmentfault.com/a/1190000013365426#item-4>React 是怎样炼成的</a>。</p><p>众所周知，Facebook 是 PHP 大户，所以 React 最开始的灵感就来至于 PHP。</p><h3 id=字符串拼接时代---2004>字符串拼接时代 - 2004<a hidden class=anchor aria-hidden=true href=#字符串拼接时代---2004>#</a></h3><p>在 2004 年这个时候，大家都还在用 PHP 的字符串拼接来开发网站：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>$str</span> <span class=o>=</span> <span class=s1>&#39;&lt;ul&gt;&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>foreach</span> <span class=p>(</span><span class=nx>$talks</span> <span class=nx>as</span> <span class=nx>$talk</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>$str</span> <span class=o>+=</span> <span class=s1>&#39;&lt;li&gt;&#39;</span> <span class=p>.</span> <span class=nx>$talk</span><span class=o>-&gt;</span><span class=nx>name</span> <span class=p>.</span> <span class=s1>&#39;&lt;/li&gt;&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>$str</span> <span class=o>+=</span> <span class=s1>&#39;&lt;/ul&gt;&#39;</span><span class=p>;</span>
</span></span></code></pre></div><p>这种方式代码写出来不好看不说，还容易造成 XSS 等安全问题。</p><p>应对方法是对用户的任何输入都进行转义（Escape）。但是如果对字符串进行多次转义，那么反转义的次数也必须是相同的，否则会无法得到原内容。如果又不小心把 HTML 标签（Markup）给转义了，那么 HTML 标签会直接显示给用户，从而导致很差的用户体验。</p><h3 id=xhp-时代---2010>XHP 时代 - 2010<a hidden class=anchor aria-hidden=true href=#xhp-时代---2010>#</a></h3><p>到了 2010 年，为了更加高效的编码，同时也避免转义 HTML 标签的错误，Facebook 开发了 XHP 。XHP 是对 PHP 的语法拓展，它允许开发者直接在 PHP 中使用 HTML 标签，而不再使用字符串。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$content</span> <span class=o>=</span> <span class=o>&lt;</span><span class=nx>ul</span> <span class=o>/&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>foreach</span> <span class=p>(</span><span class=nv>$talks</span> <span class=k>as</span> <span class=nv>$talk</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>$content</span><span class=o>-&gt;</span><span class=na>appendChild</span><span class=p>(</span><span class=o>&lt;</span><span class=nx>li</span><span class=o>&gt;</span><span class=p>{</span><span class=nv>$talk</span><span class=o>-&gt;</span><span class=na>name</span><span class=p>}</span><span class=o>&lt;/</span><span class=nx>li</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这样的话，所有的 HTML 标签都使用不同于 PHP 的语法，我们可以轻易的分辨哪些需要转义哪些不需要转义。</p><p>不久的后来，Facebook 的工程师又发现他们还可以创建自定义标签，而且通过组合自定义标签有助于构建大型应用。</p><h3 id=jsx---2013>JSX - 2013<a hidden class=anchor aria-hidden=true href=#jsx---2013>#</a></h3><p>到了 2013 年，前端工程师 Jordan Walke 向他的经理提出了一个大胆的想法：把 XHP 的拓展功能迁移到 JS 中。首要任务是需要一个拓展来让 JS 支持 XML 语法，该拓展称为 JSX。因为当时由于 Node.js 在 Facebook 已经有很多实践，所以很快就实现了 JSX。</p><blockquote><p>可以猜想一下为什么要迁移到 js 中，我猜想应该是前后端分离导致的。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>content</span> <span class=o>=</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nx>TalkList</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=nx>talks</span><span class=p>.</span><span class=nx>map</span><span class=p>(</span><span class=nx>talk</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>Talk</span> <span class=nx>talk</span><span class=o>=</span><span class=p>{</span><span class=nx>talk</span><span class=p>}</span> <span class=o>/&gt;</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=err>/TalkList&gt;</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><h3 id=react>React<a hidden class=anchor aria-hidden=true href=#react>#</a></h3><p>在这个时候，就有另外一个很棘手的问题，那就是在进行更新的时候，需要去操作 DOM，传统 DOM API 细节太多，操作复杂，所以就很容易出现 Bug，而且代码难以维护。</p><p>然后就想到了 PHP 时代的更新机制，每当有数据改变时，只需要跳到一个由 PHP 全新渲染的新页面即可。</p><p>从开发者的角度来看的话，这种方式开发应用是非常简单的，因为它不需要担心变更，且界面上用户数据改变时所有内容都是同步的。</p><p>为此 React 提出了一个新的思想，即<strong>始终整体“刷新”页面</strong></p><p><strong>当发生前后状态变化时，React 会自动更新 UI</strong>，让我们从复杂的 UI 操作中解放出来，使我们只需关于状态以及最终 UI 长什么样。</p><p>下面看看局部刷新和整体刷新的区别。</p><p><img loading=lazy src=http://imgs.taoweng.site/2019-12-22-155012.png alt></p><blockquote><p>图片来自于极客时间王沛老师的《React进阶与实战》</p></blockquote><p>局部刷新：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 下面是伪代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>ul</span> <span class=o>=</span> <span class=nx>find</span><span class=p>(</span><span class=nx>ul</span><span class=p>)</span> <span class=c1>// 先找到 ul
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ul</span><span class=p>.</span><span class=nx>append</span><span class=p>(</span><span class=sb>`&lt;li&gt;</span><span class=si>${</span><span class=nx>message3</span><span class=si>}</span><span class=sb>&lt;/li&gt;`</span><span class=p>)</span> <span class=c1>//然后再将message3插到最后
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 想想如果是不插到最后一个，而是插到中间的第n个
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>ul</span> <span class=o>=</span> <span class=nx>find</span><span class=p>(</span><span class=nx>ul</span><span class=p>)</span> <span class=c1>// 先找到 ul
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>preli</span> <span class=o>=</span> <span class=nx>find</span><span class=p>(</span><span class=nx>li</span><span class=p>(</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span> <span class=c1>// 再找到 n-1 的一个 li
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>preli</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=sb>`&lt;li&gt;</span><span class=si>${</span><span class=nx>message3</span><span class=si>}</span><span class=sb>&lt;/li&gt;`</span><span class=p>)</span> <span class=c1>// 再插入到 n-1 个的后面
</span></span></span></code></pre></div><p>整体刷新：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>UI</span> <span class=o>=</span> <span class=nx>f</span><span class=p>(</span><span class=nx>messages</span><span class=p>)</span> <span class=c1>// 整体刷新 3 条消息，只需要调用 f 函数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 这个是在初始渲染的时候就定义好的，更新的时候不用去管
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>f</span><span class=p>(</span><span class=nx>messages</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&lt;</span><span class=nx>ul</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>messages</span><span class=p>.</span><span class=nx>map</span><span class=p>(</span><span class=nx>message</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>li</span><span class=o>&gt;</span><span class=p>{</span> <span class=nx>message</span> <span class=p>}</span><span class=o>&lt;</span><span class=err>/li&gt;)}</span>
</span></span><span class=line><span class=cl>	<span class=o>&lt;</span><span class=err>/ul&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个时候，我<strong>只需要关系我的状态（数据是什么），以及 UI 长什么样（布局），不再需要关系操作细节。</strong></p><p>这种方式虽然简单粗暴，但是很明显的缺点，<strong>就是很慢。</strong></p><p>另外还有一个问题就是这样无法包含节点的状态。比如它会失去当前聚焦的元素和光标，以及文本选择和页面滚动位置，这些都是页面的当前状态。</p><h2 id=diff>Diff<a hidden class=anchor aria-hidden=true href=#diff>#</a></h2><p>为了解决上面说的问题，对于没有改变的 DOM 节点，让它保持原样不动，仅仅创建并替换变更过的 DOM 节点。这种方式实现了 DOM 节点<strong>复用</strong>（Reuse）。</p><p>至此，只要能够<strong>识别</strong>出哪些节点改变了，那么就可以实现对 DOM 的更新。于是问题就转化为<strong>如何比对两个 DOM 的差异</strong>。</p><p>说道对比差异，可能很容易想到<strong>版本控制(git)。</strong></p><p>DOM 是树形结构，所以 diff 算法必须是针对树形结构的。目前已知的完整树形结构 diff 算法复杂度为 O(n^3) 。</p><blockquote><p><a href=https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf>完整的 Tree diff 实现算法。</a></p></blockquote><p>但是时间复杂度 O(n^3) 太高了，所以Facebook工程师考虑到组件的特殊情况，然后将复杂度降低到了 O(n)。</p><blockquote><p>附：详细的 diff 理解：<a href=https://zhuanlan.zhihu.com/p/20346379>不可思议的 react diff 。</a></p></blockquote><h3 id=virtual-dom>Virtual DOM<a hidden class=anchor aria-hidden=true href=#virtual-dom>#</a></h3><p>前面说到，React 其实实现了对 DOM 节点的版本控制。</p><p>做过 JS 应用优化的人可能都知道，DOM 是复杂的，对它的操作（尤其是查询和创建）是非常慢非常耗费资源的。看下面的例子，仅创建一个空白的 div，其实例属性就达到 231 个。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Chrome v63
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>div</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>createElement</span><span class=p>(</span><span class=s1>&#39;div&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>m</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>k</span> <span class=k>in</span> <span class=nx>div</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>m</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>m</span><span class=p>);</span> <span class=c1>// 231
</span></span></span></code></pre></div><p>对于 DOM 这么多属性，其实大部分属性对于做 Diff 是没有任何用处的，所以如果用更轻量级的 JS 对象来代替复杂的 DOM 节点，然后把对 DOM 的 diff 操作转移到 JS 对象，就可以避免大量对 DOM 的查询操作。这个更轻量级的 JS 对象就称为 Virtual DOM 。</p><p>那么现在的过程就是这样：</p><ol><li>维护一个使用 JS 对象表示的 Virtual DOM，与真实 DOM 一一对应</li><li>对前后两个 Virtual DOM 做 diff ，生成<strong>变更</strong>（Mutation）</li><li>把变更应用于真实 DOM，生成最新的真实 DOM</li></ol><p>可以看出，因为要把变更应用到真实 DOM 上，所以还是避免不了要直接操作 DOM ，但是 React 的 diff 算法会把 DOM 改动次数降到最低。</p><p>剩下的历史就不谈了，已经引出这篇文章的重点：虚拟 DOM。详细的历史可见：<a href=https://segmentfault.com/a/1190000013365426>React 是怎样炼成的</a>，文中历史部分内容很多摘抄与此。</p><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>传统前端的编程方式是命令式的，直接操纵DOM，告诉浏览器该怎么干。这样的问题就是，大量的代码被用于操作 DOM 元素，且代码可读性差，可维护性低。</p><p>React 的出现，将命令式变成了声明式，摒弃了直接操作 DOM 的细节，只关注数据的变动，DOM 操作由框架来完成，从而大幅度提升了代码的可读性和可维护性。</p><p>在初期我们可以看到，数据的变动导致整个页面的刷新，这种效率很低，因为可能是局部的数据变化，但是要刷新整个页面，造成了不必要的开销。</p><p>所以就有了 Diff 过程，将数据变动前后的 DOM 结构先进行比较，找出两者的不同处，然后再对不同之处进行更新渲染。</p><p>但是由于整个 DOM 结构又太大，所以采用了更轻量级的对 DOM 的描述—虚拟 DOM。</p><p>不过需要注意的是，虚拟 DOM 和 Diff 算法的出现是为了解决由命令式编程转变为声明式编程、数据驱动后所带来的性能问题的。换句话说，<strong>直接操作 DOM 的性能并不会低于虚拟 DOM 和 Diff 算法，甚至还会优于。</strong></p><p>这么说的原因是因为 Diff 算法的比较过程，比较是为了找出不同从而有的放矢的更新页面。但是比较也是要消耗性能的。而直接操作 DOM 就是有的放矢，我们知道该更新什么不该更新什么，所以不需要有比较的过程。所以直接操作 DOM 效率可能更高。</p><p>React 厉害的地方并不是说它比 DOM 快，而是说不管你数据怎么变化，我都可以以最小的代价来进行更新 DOM。 方法就是我在内存里面用新的数据刷新一个虚拟 DOM 树，然后新旧 DOM 进行比较，找出差异，再更新到 DOM 树上。</p><p>框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。</p><p>如果你想了解更多的虚拟 DOM 与性能的关系，请看下面公众号里面的两篇文章和那个知乎话题，会让你对虚拟 DOM 又更深层次的理解。</p><ul><li><a href=https://mp.weixin.qq.com/s/XR3-3MNCYY2pg6yVwVQohQ>别再说虚拟 DOM 快了，要被打脸的</a></li><li><a href=https://mp.weixin.qq.com/s/cz5DBpqFiadL4IQofiWY3A>深入理解虚拟 DOM，它真的不快</a></li><li><a href=https://www.zhihu.com/question/31809713>网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么</a></li></ul><blockquote><p>另外再提一个点，很多人会把 Diff 、数据更新、提升性能等概念绑定起来，但是你想想这个问题：React 由于只触发更新,而不能知道精确变化的数据,所以需要 diff 来找出差异然后 patch 差异队列。Vue 采用数据劫持的手段可以精准拿到变化的数据,为什么还要用虚拟DOM？</p></blockquote><h2 id=虚拟dom-的作用>虚拟DOM 的作用<a hidden class=anchor aria-hidden=true href=#虚拟dom-的作用>#</a></h2><p>要想回答上面那个问题，真的不要仅仅以为虚拟 DOM 或者 React 是来解决性能问题的，好处可还有很多呢。下面我总结了一些虚拟 DOM 好作用。</p><ul><li><strong>Virtual DOM 在牺牲(牺牲很关键)部分性能</strong>的前提下，增加了可维护性，这也是很多框架的通性。</li><li>实现了对 DOM 的集中化操作，在数据改变时先对虚拟 DOM 进行修改，再反映到真实的 DOM中，用最小的代价来更新DOM，提高效率(提升效率要想想是跟哪个阶段比提升了效率，别只记住了这一条)。</li><li>打开了函数式 UI 编程的大门。</li><li>可以渲染到 DOM 以外的端，使得框架跨平台，比如 ReactNative，React VR 等。</li><li>可以更好的实现 SSR，同构渲染等。这条其实是跟上面一条差不多的。</li><li>组件的高度抽象化。</li></ul><p>既然虚拟 DOM 有这么多作用，那么上面的问题，Vue 采用虚拟 DOM 的原因是什么呢？</p><blockquote><p>Vue 2.0 引入 vdom 的主要原因是 vdom 把渲染过程抽象化了，从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标。 来自尤大文章：<a href=https://zhuanlan.zhihu.com/p/23752826>Vue 的理念问题</a></p></blockquote><h2 id=虚拟-dom-的缺点>虚拟 DOM 的缺点<a hidden class=anchor aria-hidden=true href=#虚拟-dom-的缺点>#</a></h2><ul><li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。</li><li>虚拟 DOM 需要在内存中的维护一份 DOM 的副本(更上面一条其实也差不多，上面一条是从速度上，这条是空间上)。</li><li>如果虚拟 DOM 大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。所以，如果你有一个DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢。但对于大多数单页面应用，这应该都会更快。</li></ul><h2 id=总结-1>总结<a hidden class=anchor aria-hidden=true href=#总结-1>#</a></h2><p>本文在介绍虚拟 DOM 并没有像其他文章一样去解释它的实现以及相关的 Diff 算法，关于 Diff 算法可以看这篇 <a href=https://mp.weixin.qq.com/s/oAlVmZ4Hbt2VhOwFEkNEhw>虚拟 DOM 到底是什么？</a>文中介绍了很多库的 diff 算法，可见其实 React 的 diff 算法并不算太快。</p><p>而是通过历史来得出他的价值体现，从历史怎么看大牛们是怎么一步一步的去解决问题，从历史中看为什么别人能做出这么伟大的东西，而我们不能？</p><p>每个伟大的产品都会有非常多的背景支持，都是一步一步发展而来的。</p><p>另外洗清了一个错误观念：<strong>很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。</strong></p><p>虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。</p><p>最后希望大家多思考，跟随者浪潮站在浪潮之巅。</p><h2 id=参考链接>参考链接<a hidden class=anchor aria-hidden=true href=#参考链接>#</a></h2><ul><li><a href=https://blog.csdn.net/hjc256/article/details/97135687>虚拟DOM为何出现以及性能问题？</a></li><li><a href=https://segmentfault.com/a/1190000013365426>React 是怎样炼成的</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/react/>react</a></li></ul><nav class=paginav><a class=prev href=/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/301/><span class=title>« Prev</span><br><span>我也想做自己喜欢做的事儿</span></a>
<a class=next href=/posts/%E6%8A%80%E6%9C%AF/190/><span class=title>Next »</span><br><span>认识函数式编程</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 根据 React 历史来聊如何理解虚拟 DOM on twitter" href="https://twitter.com/intent/tweet/?text=%e6%a0%b9%e6%8d%ae%20React%20%e5%8e%86%e5%8f%b2%e6%9d%a5%e8%81%8a%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3%e8%99%9a%e6%8b%9f%20DOM&url=%2fposts%2f%25E8%25A7%2582%25E7%2582%25B9%25E4%25B8%258E%25E6%2584%259F%25E6%2583%25B3%2f293%2f&hashtags=react"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 根据 React 历史来聊如何理解虚拟 DOM on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fposts%2f%25E8%25A7%2582%25E7%2582%25B9%25E4%25B8%258E%25E6%2584%259F%25E6%2583%25B3%2f293%2f&title=%e6%a0%b9%e6%8d%ae%20React%20%e5%8e%86%e5%8f%b2%e6%9d%a5%e8%81%8a%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3%e8%99%9a%e6%8b%9f%20DOM&summary=%e6%a0%b9%e6%8d%ae%20React%20%e5%8e%86%e5%8f%b2%e6%9d%a5%e8%81%8a%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3%e8%99%9a%e6%8b%9f%20DOM&source=%2fposts%2f%25E8%25A7%2582%25E7%2582%25B9%25E4%25B8%258E%25E6%2584%259F%25E6%2583%25B3%2f293%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 根据 React 历史来聊如何理解虚拟 DOM on reddit" href="https://reddit.com/submit?url=%2fposts%2f%25E8%25A7%2582%25E7%2582%25B9%25E4%25B8%258E%25E6%2584%259F%25E6%2583%25B3%2f293%2f&title=%e6%a0%b9%e6%8d%ae%20React%20%e5%8e%86%e5%8f%b2%e6%9d%a5%e8%81%8a%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3%e8%99%9a%e6%8b%9f%20DOM"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 根据 React 历史来聊如何理解虚拟 DOM on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2f%25E8%25A7%2582%25E7%2582%25B9%25E4%25B8%258E%25E6%2584%259F%25E6%2583%25B3%2f293%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 根据 React 历史来聊如何理解虚拟 DOM on whatsapp" href="https://api.whatsapp.com/send?text=%e6%a0%b9%e6%8d%ae%20React%20%e5%8e%86%e5%8f%b2%e6%9d%a5%e8%81%8a%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3%e8%99%9a%e6%8b%9f%20DOM%20-%20%2fposts%2f%25E8%25A7%2582%25E7%2582%25B9%25E4%25B8%258E%25E6%2584%259F%25E6%2583%25B3%2f293%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 根据 React 历史来聊如何理解虚拟 DOM on telegram" href="https://telegram.me/share/url?text=%e6%a0%b9%e6%8d%ae%20React%20%e5%8e%86%e5%8f%b2%e6%9d%a5%e8%81%8a%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3%e8%99%9a%e6%8b%9f%20DOM&url=%2fposts%2f%25E8%25A7%2582%25E7%2582%25B9%25E4%25B8%258E%25E6%2584%259F%25E6%2583%25B3%2f293%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href>桃园</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>