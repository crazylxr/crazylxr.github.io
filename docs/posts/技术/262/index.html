<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Deep In React 之浅谈 React Fiber 架构（一） | 桃园</title><meta name=keywords content="react,JavaScript"><meta name=description content="文章首发于个人博客
前言 2016 年都已经透露出来的概念，这都 9102 年了，我才开始写 Fiber 的文章，表示惭愧呀。不过现在好的是关于 Fiber 的资料已经很丰富了，在写文章的时候参考资料比较多，比较容易深刻的理解。
React 作为我最喜欢的框架，没有之一，我愿意花很多时间来好好的学习他，我发现对于学习一门框架会有四种感受，刚开始没使用过，可能有一种很神奇的感觉；然后接触了，遇到了不熟悉的语法，感觉这是什么垃圾东西，这不是反人类么；然后当你熟悉了之后，真香，设计得挺好的，这个时候它已经改变了你编程的思维方式了；再到后来，看过他的源码，理解他的设计之后，设计得确实好，感觉自己也能写一个的样子。
所以我今年(对，没错，就是一年)就是想完全的学透 React，所以开了一个 Deep In React 的系列，把一些新手在使用 API 的时候不知道为什么的点，以及一些为什么有些东西要这么设计写出来，与大家共同探讨 React 的奥秘。
我的思路是自上而下的介绍，先理解整体的 Fiber 架构，然后再细挖每一个点，所以这篇文章主要是谈 Fiber 架构的。
介绍 在详细介绍 Fiber 之前，先了解一下 Fiber 是什么，以及为什么 React 团队要话两年时间重构协调算法。
React 的核心思想 内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中。
React 16 之前的不足 首先我们了解一下 React 的工作过程，当我们通过render() 和 setState() 进行组件渲染和更新的时候，React 主要有两个阶段：
调和阶段(Reconciler)：官方解释。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。
渲染阶段(Renderer)：遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。"><meta name=author content="桃翁"><link rel=canonical href=/posts/%E6%8A%80%E6%9C%AF/262/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.355db47b48ce042e543348876cce64165399cee8651ce7514d3c4b076b02f0aa.css integrity="sha256-NV20e0jOBC5UM0iHbM5kFlOZzuhlHOdRTTxLB2sC8Ko=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Deep In React 之浅谈 React Fiber 架构（一）"><meta property="og:description" content="文章首发于个人博客
前言 2016 年都已经透露出来的概念，这都 9102 年了，我才开始写 Fiber 的文章，表示惭愧呀。不过现在好的是关于 Fiber 的资料已经很丰富了，在写文章的时候参考资料比较多，比较容易深刻的理解。
React 作为我最喜欢的框架，没有之一，我愿意花很多时间来好好的学习他，我发现对于学习一门框架会有四种感受，刚开始没使用过，可能有一种很神奇的感觉；然后接触了，遇到了不熟悉的语法，感觉这是什么垃圾东西，这不是反人类么；然后当你熟悉了之后，真香，设计得挺好的，这个时候它已经改变了你编程的思维方式了；再到后来，看过他的源码，理解他的设计之后，设计得确实好，感觉自己也能写一个的样子。
所以我今年(对，没错，就是一年)就是想完全的学透 React，所以开了一个 Deep In React 的系列，把一些新手在使用 API 的时候不知道为什么的点，以及一些为什么有些东西要这么设计写出来，与大家共同探讨 React 的奥秘。
我的思路是自上而下的介绍，先理解整体的 Fiber 架构，然后再细挖每一个点，所以这篇文章主要是谈 Fiber 架构的。
介绍 在详细介绍 Fiber 之前，先了解一下 Fiber 是什么，以及为什么 React 团队要话两年时间重构协调算法。
React 的核心思想 内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中。
React 16 之前的不足 首先我们了解一下 React 的工作过程，当我们通过render() 和 setState() 进行组件渲染和更新的时候，React 主要有两个阶段：
调和阶段(Reconciler)：官方解释。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。
渲染阶段(Renderer)：遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。"><meta property="og:type" content="article"><meta property="og:url" content="/posts/%E6%8A%80%E6%9C%AF/262/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="og:site_name" content="桃园"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Deep In React 之浅谈 React Fiber 架构（一）"><meta name=twitter:description content="文章首发于个人博客
前言 2016 年都已经透露出来的概念，这都 9102 年了，我才开始写 Fiber 的文章，表示惭愧呀。不过现在好的是关于 Fiber 的资料已经很丰富了，在写文章的时候参考资料比较多，比较容易深刻的理解。
React 作为我最喜欢的框架，没有之一，我愿意花很多时间来好好的学习他，我发现对于学习一门框架会有四种感受，刚开始没使用过，可能有一种很神奇的感觉；然后接触了，遇到了不熟悉的语法，感觉这是什么垃圾东西，这不是反人类么；然后当你熟悉了之后，真香，设计得挺好的，这个时候它已经改变了你编程的思维方式了；再到后来，看过他的源码，理解他的设计之后，设计得确实好，感觉自己也能写一个的样子。
所以我今年(对，没错，就是一年)就是想完全的学透 React，所以开了一个 Deep In React 的系列，把一些新手在使用 API 的时候不知道为什么的点，以及一些为什么有些东西要这么设计写出来，与大家共同探讨 React 的奥秘。
我的思路是自上而下的介绍，先理解整体的 Fiber 架构，然后再细挖每一个点，所以这篇文章主要是谈 Fiber 架构的。
介绍 在详细介绍 Fiber 之前，先了解一下 Fiber 是什么，以及为什么 React 团队要话两年时间重构协调算法。
React 的核心思想 内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中。
React 16 之前的不足 首先我们了解一下 React 的工作过程，当我们通过render() 和 setState() 进行组件渲染和更新的时候，React 主要有两个阶段：
调和阶段(Reconciler)：官方解释。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。
渲染阶段(Renderer)：遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"Deep In React 之浅谈 React Fiber 架构（一）","item":"/posts/%E6%8A%80%E6%9C%AF/262/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Deep In React 之浅谈 React Fiber 架构（一）","name":"Deep In React 之浅谈 React Fiber 架构（一）","description":"文章首发于个人博客\n前言 2016 年都已经透露出来的概念，这都 9102 年了，我才开始写 Fiber 的文章，表示惭愧呀。不过现在好的是关于 Fiber 的资料已经很丰富了，在写文章的时候参考资料比较多，比较容易深刻的理解。\nReact 作为我最喜欢的框架，没有之一，我愿意花很多时间来好好的学习他，我发现对于学习一门框架会有四种感受，刚开始没使用过，可能有一种很神奇的感觉；然后接触了，遇到了不熟悉的语法，感觉这是什么垃圾东西，这不是反人类么；然后当你熟悉了之后，真香，设计得挺好的，这个时候它已经改变了你编程的思维方式了；再到后来，看过他的源码，理解他的设计之后，设计得确实好，感觉自己也能写一个的样子。\n所以我今年(对，没错，就是一年)就是想完全的学透 React，所以开了一个 Deep In React 的系列，把一些新手在使用 API 的时候不知道为什么的点，以及一些为什么有些东西要这么设计写出来，与大家共同探讨 React 的奥秘。\n我的思路是自上而下的介绍，先理解整体的 Fiber 架构，然后再细挖每一个点，所以这篇文章主要是谈 Fiber 架构的。\n介绍 在详细介绍 Fiber 之前，先了解一下 Fiber 是什么，以及为什么 React 团队要话两年时间重构协调算法。\nReact 的核心思想 内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中。\nReact 16 之前的不足 首先我们了解一下 React 的工作过程，当我们通过render() 和 setState() 进行组件渲染和更新的时候，React 主要有两个阶段：\n调和阶段(Reconciler)：官方解释。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。\n渲染阶段(Renderer)：遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。","keywords":["react","JavaScript"],"articleBody":" 文章首发于个人博客\n前言 2016 年都已经透露出来的概念，这都 9102 年了，我才开始写 Fiber 的文章，表示惭愧呀。不过现在好的是关于 Fiber 的资料已经很丰富了，在写文章的时候参考资料比较多，比较容易深刻的理解。\nReact 作为我最喜欢的框架，没有之一，我愿意花很多时间来好好的学习他，我发现对于学习一门框架会有四种感受，刚开始没使用过，可能有一种很神奇的感觉；然后接触了，遇到了不熟悉的语法，感觉这是什么垃圾东西，这不是反人类么；然后当你熟悉了之后，真香，设计得挺好的，这个时候它已经改变了你编程的思维方式了；再到后来，看过他的源码，理解他的设计之后，设计得确实好，感觉自己也能写一个的样子。\n所以我今年(对，没错，就是一年)就是想完全的学透 React，所以开了一个 Deep In React 的系列，把一些新手在使用 API 的时候不知道为什么的点，以及一些为什么有些东西要这么设计写出来，与大家共同探讨 React 的奥秘。\n我的思路是自上而下的介绍，先理解整体的 Fiber 架构，然后再细挖每一个点，所以这篇文章主要是谈 Fiber 架构的。\n介绍 在详细介绍 Fiber 之前，先了解一下 Fiber 是什么，以及为什么 React 团队要话两年时间重构协调算法。\nReact 的核心思想 内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中。\nReact 16 之前的不足 首先我们了解一下 React 的工作过程，当我们通过render() 和 setState() 进行组件渲染和更新的时候，React 主要有两个阶段：\n调和阶段(Reconciler)：官方解释。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。\n渲染阶段(Renderer)：遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。\n在协调阶段阶段，由于是采用的递归的遍历方式，这种也被成为 Stack Reconciler，主要是为了区别 Fiber Reconciler 取的一个名字。这种方式有一个特点：一旦任务开始进行，就无法中断，那么 js 将一直占用主线程， 一直要等到整棵 Virtual DOM 树计算完成之后，才能把执行权交给渲染引擎，那么这就会导致一些用户交互、动画等任务无法立即得到处理，就会有卡顿，非常的影响用户体验。\n如何解决之前的不足 之前的问题主要的问题是任务一旦执行，就无法中断，js 线程一直占用主线程，导致卡顿。\n可能有些接触前端不久的不是特别理解上面为什么 js 一直占用主线程就会卡顿，我这里还是简单的普及一下。\n浏览器每一帧都需要完成哪些工作？ 页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。\n1s 60 帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。\n浏览器一帧内的工作\n通过上图可看到，一帧内需要完成如下六个步骤的任务：\n处理用户的交互 JS 解析执行 帧开始。窗口尺寸变更，页面滚去等的处理 rAF(requestAnimationFrame) 布局 绘制 如果这六个步骤中，任意一个步骤所占用的时间过长，总时间超过 16ms 了之后，用户也许就能看到卡顿。\n而在上一小节提到的调和阶段花的时间过长，也就是 js 执行的时间过长，那么就有可能在用户有交互的时候，本来应该是渲染下一帧了，但是在当前一帧里还在执行 JS，就导致用户交互不能麻烦得到反馈，从而产生卡顿感。\n解决方案 **把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行。**这种策略叫做 Cooperative Scheduling（合作式调度），操作系统常用任务调度策略之一。\n补充知识，操作系统常用任务调度策略：先来先服务（FCFS）调度算法、短作业（进程）优先调度算法（SJ/PF）、最高优先权优先调度算法（FPF）、高响应比优先调度算法（HRN）、时间片轮转法（RR）、多级队列反馈法。\n合作式调度主要就是用来分配任务的，当有更新任务来的时候，不会马上去做 Diff 操作，而是先把当前的更新送入一个 Update Queue 中，然后交给 Scheduler 去处理，Scheduler 会根据当前主线程的使用情况去处理这次 Update。为了实现这种特性，使用了requestIdelCallbackAPI。对于不支持这个API 的浏览器，React 会加上 pollyfill。\n在上面我们已经知道浏览器是一帧一帧执行的，在两个执行帧之间，主线程通常会有一小段空闲时间，requestIdleCallback可以在这个空闲期（Idle Period）调用空闲期回调（Idle Callback），执行一些任务。\n低优先级任务由requestIdleCallback处理；\n高优先级任务，如动画相关的由requestAnimationFrame处理；\nrequestIdleCallback 可以在多个空闲期调用空闲期回调，执行任务；\nrequestIdleCallback 方法提供 deadline，即任务执行限制时间，以切分任务，避免长时间执行，阻塞UI渲染而导致掉帧；\n这个方案看似确实不错，但是怎么实现可能会遇到几个问题：\n如何拆分成子任务？ 一个子任务多大合适？ 怎么判断是否还有剩余时间？ 有剩余时间怎么去调度应该执行哪一个任务？ 没有剩余时间之前的任务怎么办？ 接下里整个 Fiber 架构就是来解决这些问题的。\n什么是 Fiber 为了解决之前提到解决方案遇到的问题，提出了以下几个目标：\n暂停工作，稍后再回来。 为不同类型的工作分配优先权。 重用以前完成的工作。 如果不再需要，则中止工作。 为了做到这些，我们首先需要一种方法将任务分解为单元。从某种意义上说，这就是 Fiber，Fiber 代表一种工作单元。\n但是仅仅是分解为单元也无法做到中断任务，因为函数调用栈就是这样，每个函数为一个工作，每个工作被称为堆栈帧，它会一直工作，直到堆栈为空，无法中断。\n所以我们需要一种增量渲染的调度，那么就需要重新实现一个堆栈帧的调度，这个堆栈帧可以按照自己的调度算法执行他们。另外由于这些堆栈是可以自己控制的，所以可以加入并发或者错误边界等功能。\n因此 Fiber 就是重新实现的堆栈帧，本质上 Fiber 也可以理解为是一个虚拟的堆栈帧，将可中断的任务拆分成多个子任务，通过按照优先级来自由调度子任务，分段更新，从而将之前的同步渲染改为异步渲染。\n所以我们可以说 Fiber 是一种数据结构(堆栈帧)，也可以说是一种解决可中断的调用任务的一种解决方案，它的特性就是时间分片(time slicing)和暂停(supense)。\n如果了解协程的可能会觉得 Fiber 的这种解决方案，跟协程有点像(区别还是很大的)，是可以中断的，可以控制执行顺序。在 JS 里的 generator 其实就是一种协程的使用方式，不过颗粒度更小，可以控制函数里面的代码调用的顺序，也可以中断。\nFiber 是如何工作的 ReactDOM.render() 和 setState 的时候开始创建更新。 将创建的更新加入任务队列，等待调度。 在 requestIdleCallback 空闲时执行任务。 从根节点开始遍历 Fiber Node，并且构建 WokeInProgress Tree。 生成 effectList。 根据 EffectList 更新 DOM。 下面是一个详细的执行过程图：\n第一部分从 ReactDOM.render() 方法开始，把接收的 React Element 转换为 Fiber 节点，并为其设置优先级，创建 Update，加入到更新队列，这部分主要是做一些初始数据的准备。 第二部分主要是三个函数：scheduleWork、requestWork、performWork，即安排工作、申请工作、正式工作三部曲，React 16 新增的异步调用的功能则在这部分实现，这部分就是 Schedule 阶段，前面介绍的 Cooperative Scheduling 就是在这个阶段，只有在这个解决获取到可执行的时间片，第三部分才会继续执行。具体是如何调度的，后面文章再介绍，这是 React 调度的关键过程。 第三部分是一个大循环，遍历所有的 Fiber 节点，通过 Diff 算法计算所有更新工作，产出 EffectList 给到 commit 阶段使用，这部分的核心是 beginWork 函数，这部分基本就是 Fiber Reconciler ，包括 reconciliation 和 commit 阶段。 Fiber Node FIber Node，承载了非常关键的上下文信息，可以说是贯彻整个创建和更新的流程，下来分组列了一些重要的 Fiber 字段。\n{ ... // 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点） stateNode: any, // 单链表树结构 return: Fiber | null,// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回 child: Fiber | null,// 指向自己的第一个子节点 sibling: Fiber | null, // 指向自己的兄弟结构，兄弟节点的return指向同一个父节点 // 更新相关 pendingProps: any, // 新的变动带来的新的props memoizedProps: any, // 上一次渲染完成之后的props updateQueue: UpdateQueue\u003cany\u003e | null, // 该Fiber对应的组件产生的Update会存放在这个队列里面 memoizedState: any, // 上一次渲染的时候的state // Scheduler 相关 expirationTime: ExpirationTime, // 代表任务在未来的哪个时间点应该被完成，不包括他的子树产生的任务 // 快速确定子树中是否有不在等待的变化 childExpirationTime: ExpirationTime, // 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber // 我们称他为`current \u003c==\u003e workInProgress` // 在渲染完成之后他们会交换位置 alternate: Fiber | null, // Effect 相关的 effectTag: SideEffectTag, // 用来记录Side Effect nextEffect: Fiber | null, // 单链表用来快速查找下一个side effect firstEffect: Fiber | null, // 子树中第一个side effect lastEffect: Fiber | null, // 子树中最后一个side effect .... }; Fiber Reconciler 在第二部分，进行 Schedule 完，获取到时间片之后，就开始进行 reconcile。\nFiber Reconciler 是 React 里的调和器，这也是任务调度完成之后，如何去执行每个任务，如何去更新每一个节点的过程，对应上面的第三部分。\nreconcile 过程分为2个阶段（phase）：\n（可中断）render/reconciliation 通过构造 WorkInProgress Tree 得出 Change。 （不可中断）commit 应用这些DOM change。 reconciliation 阶段 在 reconciliation 阶段的每个工作循环中，每次处理一个 Fiber，处理完可以中断/挂起整个工作循环。通过每个节点更新结束时向上归并 Effect List 来收集任务结果，reconciliation 结束后，根节点的 Effect List里记录了包括 DOM change 在内的所有 Side Effect。\nrender 阶段可以理解为就是 Diff 的过程，得出 Change(Effect List)，会执行声明如下的声明周期方法：\n[UNSAFE_]componentWillMount（弃用） [UNSAFE_]componentWillReceiveProps（弃用） getDerivedStateFromProps shouldComponentUpdate [UNSAFE_]componentWillUpdate（弃用） render 由于 reconciliation 阶段是可中断的，一旦中断之后恢复的时候又会重新执行，所以很可能 reconciliation 阶段的生命周期方法会被多次调用，所以在 reconciliation 阶段的生命周期的方法是不稳定的，我想这也是 React 为什么要废弃 componentWillMount 和 componentWillReceiveProps方法而改为静态方法 getDerivedStateFromProps 的原因吧。\ncommit 阶段 commit 阶段可以理解为就是将 Diff 的结果反映到真实 DOM 的过程。\n在 commit 阶段，在 commitRoot 里会根据 effect 的 effectTag，具体 effectTag 见源码 ，进行对应的插入、更新、删除操作，根据 tag 不同，调用不同的更新方法。\ncommit 阶段会执行如下的声明周期方法：\ngetSnapshotBeforeUpdate componentDidMount componentDidUpdate componentWillUnmount P.S：注意区别 reconciler、reconcile 和 reconciliation，reconciler 是调和器，是一个名词，可以说是 React 工作的一个模块，协调模块；reconcile 是调和器调和的动作，是一个动词；而 reconciliation 只是 reconcile 过程的第一个阶段。\nFiber Tree 和 WorkInProgress Tree React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。它反映了用于渲染 UI 的应用程序的状态。这棵树通常被称为 current 树（当前树，记录当前页面的状态）。\n在后续的更新过程中（setState），每次重新渲染都会重新创建 Element, 但是 Fiber 不会，Fiber 只会使用对应的 Element 中的数据来更新自己必要的属性，\nFiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。\n这个链接的结构是怎么构成的呢，这就要主要到之前 Fiber Node 的节点的这几个字段：\n// 单链表树结构 { return: Fiber | null, // 指向父节点 child: Fiber | null,// 指向自己的第一个子节点 sibling: Fiber | null,// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点 } 每一个 Fiber Node 节点与 Virtual Dom 一一对应，所有 Fiber Node 连接起来形成 Fiber tree, 是个单链表树结构，如下图所示：\n对照图来看，是不是可以知道 Fiber Node 是如何联系起来的呢，Fiber Tree 就是这样一个单链表。\n当 render 的时候有了这么一条单链表，当调用 setState 的时候又是如何 Diff 得到 change 的呢？\n采用的是一种叫双缓冲技术（double buffering），这个时候就需要另外一颗树：WorkInProgress Tree，它反映了要刷新到屏幕的未来状态。\nWorkInProgress Tree 构造完毕，得到的就是新的 Fiber Tree，然后喜新厌旧（把 current 指针指向WorkInProgress Tree，丢掉旧的 Fiber Tree）就好了。\n这样做的好处：\n能够复用内部对象（fiber） 节省内存分配、GC的时间开销 就算运行中有错误，也不会影响 View 上的数据 每个 Fiber上都有个alternate属性，也指向一个 Fiber，创建 WorkInProgress 节点时优先取alternate，没有的话就创建一个。\n创建 WorkInProgress Tree 的过程也是一个 Diff 的过程，Diff 完成之后会生成一个 Effect List，这个 Effect List 就是最终 Commit 阶段用来处理副作用的阶段。\n后记 本开始想一篇文章把 Fiber 讲透的，但是写着写着发现确实太多了，想写详细，估计要写几万字，所以我这篇文章的目的仅仅是在没有涉及到源码的情况下梳理了大致 React 的工作流程，对于细节，比如如何调度异步任务、如何去做 Diff 等等细节将以小节的方式一个个的结合源码进行分析。\n说实话，自己不是特别满意这篇，感觉头重脚轻，在讲协调之前写得还挺好的，但是在讲协调这块文字反而变少了，因为我是专门想写一篇文章讲协调的，所以这篇仅仅用来梳理整个流程。\n但是梳理整个流程又发现 Schedule 这块基本没什么体现，哎，不想写了，这篇文章拖太久了，请继续后续的文章。\n可以关注我的 github：Deep In React\n一些问题 接下来留一些思考题。\n如何去划分任务优先级？\n在 reconcile 过程的 render 阶段是如何去遍历链表，如何去构建 workInProgress 的？\n当任务被打断，如何恢复？\n如何去收集 EffectList？\n针对不同的组件类型如何进行更新？\n参考 完全理解 React Fiber Fiber React16源码之React Fiber架构 ","wordCount":"618","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"桃翁"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E6%8A%80%E6%9C%AF/262/"},"publisher":{"@type":"Organization","name":"桃园","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/archives/ title=Archives><span>Archives</span></a></li><li><a href=/categories/ title=Categories><span>Categories</span></a></li><li><a href=search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>Deep In React 之浅谈 React Fiber 架构（一）</h1><div class=post-meta>3 min&nbsp;·&nbsp;618 words&nbsp;·&nbsp;桃翁&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/%e6%8a%80%e6%9c%af/2019-06-27-Deep_In_React_%e4%b9%8b%e6%b5%85%e8%b0%88_React_Fiber_%e6%9e%b6%e6%9e%84%ef%bc%88%e4%b8%80%ef%bc%89.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e4%bb%8b%e7%bb%8d aria-label=介绍>介绍</a><ul><li><a href=#react-%e7%9a%84%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3 aria-label="React 的核心思想">React 的核心思想</a></li><li><a href=#react-16-%e4%b9%8b%e5%89%8d%e7%9a%84%e4%b8%8d%e8%b6%b3 aria-label="React 16 之前的不足">React 16 之前的不足</a></li><li><a href=#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e4%b9%8b%e5%89%8d%e7%9a%84%e4%b8%8d%e8%b6%b3 aria-label=如何解决之前的不足>如何解决之前的不足</a><ul><li><a href=#%e6%b5%8f%e8%a7%88%e5%99%a8%e6%af%8f%e4%b8%80%e5%b8%a7%e9%83%bd%e9%9c%80%e8%a6%81%e5%ae%8c%e6%88%90%e5%93%aa%e4%ba%9b%e5%b7%a5%e4%bd%9c aria-label=浏览器每一帧都需要完成哪些工作？>浏览器每一帧都需要完成哪些工作？</a></li><li><a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=解决方案>解决方案</a></li></ul></li></ul></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af-fiber aria-label="什么是 Fiber">什么是 Fiber</a></li><li><a href=#fiber-%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84 aria-label="Fiber 是如何工作的">Fiber 是如何工作的</a><ul><li><a href=#fiber-node aria-label="Fiber Node">Fiber Node</a></li><li><a href=#fiber-reconciler aria-label="Fiber Reconciler">Fiber Reconciler</a><ul><li><a href=#reconciliation-%e9%98%b6%e6%ae%b5 aria-label="reconciliation 阶段">reconciliation 阶段</a></li><li><a href=#commit-%e9%98%b6%e6%ae%b5 aria-label="commit 阶段">commit 阶段</a></li></ul></li><li><a href=#fiber-tree-%e5%92%8c-workinprogress-tree aria-label="Fiber Tree 和 WorkInProgress Tree">Fiber Tree 和 WorkInProgress Tree</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li><li><a href=#%e4%b8%80%e4%ba%9b%e9%97%ae%e9%a2%98 aria-label=一些问题>一些问题</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>文章首发于<a href=http://taoweng.site>个人博客</a></p></blockquote><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>2016 年都已经透露出来的概念，这都 9102 年了，我才开始写 Fiber 的文章，表示惭愧呀。不过现在好的是关于 Fiber 的资料已经很丰富了，在写文章的时候参考资料比较多，比较容易深刻的理解。</p><p>React 作为我最喜欢的框架，没有之一，我愿意花很多时间来好好的学习他，我发现对于学习一门框架会有四种感受，刚开始没使用过，可能有一种很神奇的感觉；然后接触了，遇到了不熟悉的语法，感觉这是什么垃圾东西，这不是反人类么；然后当你熟悉了之后，真香，设计得挺好的，这个时候它已经改变了你编程的思维方式了；再到后来，看过他的源码，理解他的设计之后，设计得确实好，感觉自己也能写一个的样子。</p><p>所以我<strong>今年</strong>(对，没错，就是一年)就是想完全的学透 React，所以开了一个 <strong>Deep In React</strong> 的系列，把一些新手在使用 API 的时候不知道为什么的点，以及一些为什么有些东西要这么设计写出来，与大家共同探讨 React 的奥秘。</p><p>我的思路是自上而下的介绍，先理解整体的 Fiber 架构，然后再细挖每一个点，所以这篇文章主要是谈 Fiber 架构的。</p><h2 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h2><p>在详细介绍 Fiber 之前，先了解一下 Fiber 是什么，以及为什么 React 团队要话两年时间重构协调算法。</p><h3 id=react-的核心思想>React 的核心思想<a hidden class=anchor aria-hidden=true href=#react-的核心思想>#</a></h3><p><strong>内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中</strong>。</p><h3 id=react-16-之前的不足>React 16 之前的不足<a hidden class=anchor aria-hidden=true href=#react-16-之前的不足>#</a></h3><p>首先我们了解一下 React 的工作过程，当我们通过<code>render() </code>和 <code>setState()</code> 进行组件渲染和更新的时候，React 主要有两个阶段：</p><p><img loading=lazy src=http://imgs.taoweng.site/2019-06-25-151228.png alt></p><p><strong>调和阶段(Reconciler)：</strong><a href=https://zh-hans.reactjs.org/docs/reconciliation.html>官方解释</a>。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。</p><p><strong>渲染阶段(Renderer)</strong>：遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。</p><p>在协调阶段阶段，由于是采用的递归的遍历方式，这种也被成为 <strong>Stack Reconciler</strong>，主要是为了区别 <strong>Fiber Reconciler</strong> 取的一个名字。这种方式有一个特点：一旦任务开始进行，就<strong>无法中断</strong>，那么 js 将一直占用主线程， 一直要等到整棵 Virtual DOM 树计算完成之后，才能把执行权交给渲染引擎，那么这就会导致一些用户交互、动画等任务无法立即得到处理，就会有卡顿，非常的影响用户体验。</p><h3 id=如何解决之前的不足>如何解决之前的不足<a hidden class=anchor aria-hidden=true href=#如何解决之前的不足>#</a></h3><blockquote><p>之前的问题主要的问题是任务一旦执行，就无法中断，js 线程一直占用主线程，导致卡顿。</p></blockquote><p>可能有些接触前端不久的不是特别理解上面为什么 js 一直占用主线程就会卡顿，我这里还是简单的普及一下。</p><h4 id=浏览器每一帧都需要完成哪些工作>浏览器每一帧都需要完成哪些工作？<a hidden class=anchor aria-hidden=true href=#浏览器每一帧都需要完成哪些工作>#</a></h4><p>页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。</p><p>1s 60 帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。</p><p><img loading=lazy src=http://imgs.taoweng.site/2019-06-25-151230.png alt=image-20190603163205451></p><p><em>浏览器一帧内的工作</em></p><p>通过上图可看到，一帧内需要完成如下六个步骤的任务：</p><ul><li>处理用户的交互</li><li>JS 解析执行</li><li>帧开始。窗口尺寸变更，页面滚去等的处理</li><li>rAF(requestAnimationFrame)</li><li>布局</li><li>绘制</li></ul><p>如果这六个步骤中，任意一个步骤所占用的时间过长，总时间超过 16ms 了之后，用户也许就能看到卡顿。</p><p>而在上一小节提到的<strong>调和阶段</strong>花的时间过长，也就是 js 执行的时间过长，那么就有可能在用户有交互的时候，本来应该是渲染下一帧了，但是在当前一帧里还在执行 JS，就导致用户交互不能麻烦得到反馈，从而产生卡顿感。</p><h4 id=解决方案>解决方案<a hidden class=anchor aria-hidden=true href=#解决方案>#</a></h4><p>**把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行。**这种策略叫做 <a href=https://www.w3.org/TR/requestidlecallback/>Cooperative Scheduling（合作式调度）</a>，操作系统常用任务调度策略之一。</p><blockquote><p><strong>补充知识</strong>，操作系统常用任务调度策略：先来先服务（FCFS）调度算法、短作业（进程）优先调度算法（SJ/PF）、最高优先权优先调度算法（FPF）、高响应比优先调度算法（HRN）、时间片轮转法（RR）、多级队列反馈法。</p></blockquote><p>合作式调度主要就是用来分配任务的，当有更新任务来的时候，不会马上去做 Diff 操作，而是先把当前的更新送入一个 Update Queue 中，然后交给 <strong>Scheduler</strong> 去处理，Scheduler 会根据当前主线程的使用情况去处理这次 Update。为了实现这种特性，使用了<code>requestIdelCallback</code>API。对于不支持这个API 的浏览器，React 会加上 pollyfill。</p><p>在上面我们已经知道浏览器是一帧一帧执行的，在两个执行帧之间，主线程通常会有一小段空闲时间，<code>requestIdleCallback</code>可以在这个<strong>空闲期（Idle Period）调用空闲期回调（Idle Callback）</strong>，执行一些任务。</p><p><img loading=lazy src=http://imgs.taoweng.site/2019-06-25-151231.png alt=image-20190625225130226></p><ul><li><p>低优先级任务由<code>requestIdleCallback</code>处理；</p></li><li><p>高优先级任务，如动画相关的由<code>requestAnimationFrame</code>处理；</p></li><li><p><code>requestIdleCallback </code>可以在多个空闲期调用空闲期回调，执行任务；</p></li><li><p><code>requestIdleCallback </code>方法提供 deadline，即任务执行限制时间，以切分任务，避免长时间执行，阻塞UI渲染而导致掉帧；</p></li></ul><p>这个方案看似确实不错，但是怎么实现可能会遇到几个问题：</p><ul><li>如何拆分成子任务？</li><li>一个子任务多大合适？</li><li>怎么判断是否还有剩余时间？</li><li>有剩余时间怎么去调度应该执行哪一个任务？</li><li>没有剩余时间之前的任务怎么办？</li></ul><p>接下里整个 Fiber 架构就是来解决这些问题的。</p><h2 id=什么是-fiber>什么是 Fiber<a hidden class=anchor aria-hidden=true href=#什么是-fiber>#</a></h2><p>为了解决之前提到解决方案遇到的问题，提出了以下几个目标：</p><ul><li>暂停工作，稍后再回来。</li><li>为不同类型的工作分配优先权。</li><li>重用以前完成的工作。</li><li>如果不再需要，则中止工作。</li></ul><p>为了做到这些，我们首先需要一种方法将任务分解为单元。从某种意义上说，这就是 Fiber，Fiber 代表一种<strong>工作单元</strong>。</p><p>但是仅仅是分解为单元也无法做到中断任务，因为函数调用栈就是这样，每个函数为一个工作，每个工作被称为<strong>堆栈帧</strong>，它会一直工作，直到堆栈为空，无法中断。</p><p>所以我们需要一种增量渲染的调度，那么就需要重新实现一个堆栈帧的调度，这个堆栈帧可以按照自己的调度算法执行他们。另外由于这些堆栈是可以自己控制的，所以可以加入并发或者错误边界等功能。</p><p>因此 Fiber 就是重新实现的堆栈帧，本质上 Fiber 也可以理解为是一个<strong>虚拟的堆栈帧</strong>，将可中断的任务拆分成多个子任务，通过按照优先级来自由调度子任务，分段更新，从而将之前的同步渲染改为异步渲染。</p><p>所以我们可以说 Fiber 是一种数据结构(堆栈帧)，也可以说是一种解决可中断的调用任务的一种解决方案，它的特性就是<strong>时间分片(time slicing)<strong>和</strong>暂停(supense)</strong>。</p><blockquote><p>如果了解<strong>协程</strong>的可能会觉得 Fiber 的这种解决方案，跟协程有点像(区别还是很大的)，是可以中断的，可以控制执行顺序。在 JS 里的 generator 其实就是一种协程的使用方式，不过颗粒度更小，可以控制函数里面的代码调用的顺序，也可以中断。</p></blockquote><h2 id=fiber-是如何工作的>Fiber 是如何工作的<a hidden class=anchor aria-hidden=true href=#fiber-是如何工作的>#</a></h2><ol><li><code>ReactDOM.render()</code> 和 <code>setState</code> 的时候开始创建更新。</li><li>将创建的更新加入任务队列，等待调度。</li><li>在 requestIdleCallback 空闲时执行任务。</li><li>从根节点开始遍历 Fiber Node，并且构建 WokeInProgress Tree。</li><li>生成 effectList。</li><li>根据 EffectList 更新 DOM。</li></ol><p>下面是一个详细的执行过程图：</p><p><img loading=lazy src=http://imgs.taoweng.site/2019-06-25-151232.png alt></p><ol><li>第一部分从 <code>ReactDOM.render()</code> 方法开始，把接收的 React Element 转换为 Fiber 节点，并为其设置优先级，创建 Update，加入到更新队列，这部分主要是做一些初始数据的准备。</li><li>第二部分主要是三个函数：<code>scheduleWork</code>、<code>requestWork</code>、<code>performWork</code>，即安排工作、申请工作、正式工作三部曲，React 16 新增的异步调用的功能则在这部分实现，这部分就是 <strong>Schedule 阶段</strong>，前面介绍的 Cooperative Scheduling 就是在这个阶段，只有在这个解决获取到可执行的时间片，第三部分才会继续执行。具体是如何调度的，后面文章再介绍，这是 React 调度的关键过程。</li><li>第三部分是一个大循环，遍历所有的 Fiber 节点，通过 Diff 算法计算所有更新工作，产出 EffectList 给到 commit 阶段使用，这部分的核心是 beginWork 函数，这部分基本就是 <strong>Fiber Reconciler ，包括 reconciliation 和 commit 阶段</strong>。</li></ol><h3 id=fiber-node>Fiber Node<a hidden class=anchor aria-hidden=true href=#fiber-node>#</a></h3><p>FIber Node，承载了非常关键的上下文信息，可以说是贯彻整个创建和更新的流程，下来分组列了一些重要的 Fiber 字段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>stateNode</span><span class=o>:</span> <span class=nx>any</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 单链表树结构
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span><span class=c1>// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>child</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span><span class=c1>// 指向自己的第一个子节点
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>sibling</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>  <span class=c1>// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// 更新相关
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>pendingProps</span><span class=o>:</span> <span class=nx>any</span><span class=p>,</span>  <span class=c1>// 新的变动带来的新的props
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>memoizedProps</span><span class=o>:</span> <span class=nx>any</span><span class=p>,</span>  <span class=c1>// 上一次渲染完成之后的props
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>updateQueue</span><span class=o>:</span> <span class=nx>UpdateQueue</span><span class=o>&lt;</span><span class=nx>any</span><span class=o>&gt;</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>  <span class=c1>// 该Fiber对应的组件产生的Update会存放在这个队列里面
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>memoizedState</span><span class=o>:</span> <span class=nx>any</span><span class=p>,</span> <span class=c1>// 上一次渲染的时候的state
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>  <span class=c1>// Scheduler 相关
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>expirationTime</span><span class=o>:</span> <span class=nx>ExpirationTime</span><span class=p>,</span>  <span class=c1>// 代表任务在未来的哪个时间点应该被完成，不包括他的子树产生的任务
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 快速确定子树中是否有不在等待的变化
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>childExpirationTime</span><span class=o>:</span> <span class=nx>ExpirationTime</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl> <span class=c1>// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 我们称他为`current &lt;==&gt; workInProgress`
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 在渲染完成之后他们会交换位置
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>alternate</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Effect 相关的
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>effectTag</span><span class=o>:</span> <span class=nx>SideEffectTag</span><span class=p>,</span> <span class=c1>// 用来记录Side Effect
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>nextEffect</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span> <span class=c1>// 单链表用来快速查找下一个side effect
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>firstEffect</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>  <span class=c1>// 子树中第一个side effect
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>lastEffect</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span> <span class=c1>// 子树中最后一个side effect
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>....</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=fiber-reconciler>Fiber Reconciler<a hidden class=anchor aria-hidden=true href=#fiber-reconciler>#</a></h3><p>在第二部分，进行 Schedule 完，获取到时间片之后，就开始进行 reconcile。</p><p>Fiber Reconciler 是 React 里的调和器，这也是任务调度完成之后，如何去执行每个任务，如何去更新每一个节点的过程，对应上面的第三部分。</p><p>reconcile 过程分为2个阶段（phase）：</p><ol><li>（可中断）render/reconciliation 通过构造 WorkInProgress Tree 得出 Change。</li><li>（不可中断）commit 应用这些DOM change。</li></ol><h4 id=reconciliation-阶段>reconciliation 阶段<a hidden class=anchor aria-hidden=true href=#reconciliation-阶段>#</a></h4><p>在 reconciliation 阶段的每个工作循环中，每次处理一个 Fiber，处理完可以中断/挂起整个工作循环。通过每个节点更新结束时向上归并 <strong>Effect List</strong> 来收集任务结果，reconciliation 结束后，<strong>根节点</strong>的 Effect List里记录了包括 DOM change 在内的所有 <strong>Side Effect</strong>。</p><p>render 阶段可以理解为就是 Diff 的过程，得出 Change(Effect List)，会执行声明如下的声明周期方法：</p><ul><li>[UNSAFE_]componentWillMount（弃用）</li><li>[UNSAFE_]componentWillReceiveProps（弃用）</li><li>getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>[UNSAFE_]componentWillUpdate（弃用）</li><li>render</li></ul><p>由于 reconciliation 阶段是可中断的，一旦中断之后恢复的时候又会重新执行，所以很可能 reconciliation 阶段的生命周期方法会被多次调用，所以在 reconciliation 阶段的生命周期的方法是不稳定的，我想这也是 React 为什么要废弃 <code>componentWillMount</code> 和 <code>componentWillReceiveProps</code>方法而改为静态方法 <code>getDerivedStateFromProps</code> 的原因吧。</p><h4 id=commit-阶段>commit 阶段<a hidden class=anchor aria-hidden=true href=#commit-阶段>#</a></h4><p>commit 阶段可以理解为就是将 Diff 的结果反映到真实 DOM 的过程。</p><p>在 commit 阶段，在 commitRoot 里会根据 <code>effect </code>的 <code>effectTag</code>，具体 effectTag 见<a href=https://github.com/facebook/react/blob/504576306461a5ff339dc99691842f0f35a8bf4c/packages/shared/ReactSideEffectTags.js>源码</a> ，进行对应的插入、更新、删除操作，根据 <code>tag</code> 不同，调用不同的更新方法。</p><p>commit 阶段会执行如下的声明周期方法：</p><ul><li>getSnapshotBeforeUpdate</li><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul><blockquote><p>P.S：注意区别 reconciler、reconcile 和 reconciliation，reconciler 是调和器，是一个名词，可以说是 React 工作的一个模块，协调模块；reconcile 是调和器调和的动作，是一个动词；而 reconciliation 只是 reconcile 过程的第一个阶段。</p></blockquote><h3 id=fiber-tree-和-workinprogress-tree>Fiber Tree 和 WorkInProgress Tree<a hidden class=anchor aria-hidden=true href=#fiber-tree-和-workinprogress-tree>#</a></h3><p>React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 <strong>Virtual DOM Tree</strong>，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 <strong>Fiber Tree</strong>。它反映了用于渲染 UI 的应用程序的状态。这棵树通常被称为 <strong>current 树（当前树，记录当前页面的状态）。</strong></p><p>在后续的更新过程中（setState），每次重新渲染都会重新创建 Element, 但是 Fiber 不会，Fiber 只会使用对应的 Element 中的数据来更新自己必要的属性，</p><p>Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</p><p>这个链接的结构是怎么构成的呢，这就要主要到之前 Fiber Node 的节点的这几个字段：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 单链表树结构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span> <span class=c1>// 指向父节点
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>child</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span><span class=c1>// 指向自己的第一个子节点
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=nx>sibling</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span><span class=c1>// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>每一个 Fiber Node 节点与 Virtual Dom 一一对应，所有 Fiber Node 连接起来形成 Fiber tree, 是个单链表树结构，如下图所示：</p><p><img loading=lazy src=http://imgs.taoweng.site/2019-06-25-151232.jpg alt></p><p>对照图来看，是不是可以知道 Fiber Node 是如何联系起来的呢，Fiber Tree 就是这样一个单链表。</p><p><strong>当 render 的时候有了这么一条单链表，当调用 <code>setState</code> 的时候又是如何 Diff 得到 change 的呢？</strong></p><p>采用的是一种叫<strong>双缓冲技术（double buffering）</strong>，这个时候就需要另外一颗树：WorkInProgress Tree，它反映了要刷新到屏幕的未来状态。</p><p>WorkInProgress Tree 构造完毕，得到的就是新的 Fiber Tree，然后喜新厌旧（把 current 指针指向WorkInProgress Tree，丢掉旧的 Fiber Tree）就好了。</p><p>这样做的好处：</p><ul><li>能够复用内部对象（fiber）</li><li>节省内存分配、GC的时间开销</li><li>就算运行中有错误，也不会影响 View 上的数据</li></ul><p>每个 Fiber上都有个<code>alternate</code>属性，也指向一个 Fiber，创建 WorkInProgress 节点时优先取<code>alternate</code>，没有的话就创建一个。</p><p>创建 WorkInProgress Tree 的过程也是一个 Diff 的过程，Diff 完成之后会生成一个 Effect List，这个 Effect List 就是最终 Commit 阶段用来处理副作用的阶段。</p><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>本开始想一篇文章把 Fiber 讲透的，但是写着写着发现确实太多了，想写详细，估计要写几万字，所以我这篇文章的目的仅仅是在没有涉及到源码的情况下梳理了大致 React 的工作流程，对于细节，比如如何调度异步任务、如何去做 Diff 等等细节将以小节的方式一个个的结合源码进行分析。</p><p>说实话，自己不是特别满意这篇，感觉头重脚轻，在讲协调之前写得还挺好的，但是在讲协调这块文字反而变少了，因为我是专门想写一篇文章讲协调的，所以这篇仅仅用来梳理整个流程。</p><p>但是梳理整个流程又发现 Schedule 这块基本没什么体现，哎，不想写了，这篇文章拖太久了，请继续后续的文章。</p><p>可以关注我的 github：<a href=https://github.com/crazylxr/deep-in-react>Deep In React</a></p><h2 id=一些问题>一些问题<a hidden class=anchor aria-hidden=true href=#一些问题>#</a></h2><p>接下来留一些思考题。</p><ul><li><p>如何去划分任务优先级？</p></li><li><p>在 reconcile 过程的 render 阶段是如何去遍历链表，如何去构建 workInProgress 的？</p></li><li><p>当任务被打断，如何恢复？</p></li><li><p>如何去收集 EffectList？</p></li><li><p>针对不同的组件类型如何进行更新？</p></li></ul><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li><a href=%5Bhttp://www.ayqy.net/blog/dive-into-react-fiber/#articleHeader4%5D(http://www.ayqy.net/blog/dive-into-react-fiber/#articleHeader4)>完全理解 React Fiber</a></li><li><a href=https://happy-alex.github.io/js/react/fiber/>Fiber</a></li><li><a href=https://github.com/HuJiaoHJ/blog/issues/7#>React16源码之React Fiber架构</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/react/>react</a></li><li><a href=/tags/javascript/>JavaScript</a></li></ul><nav class=paginav><a class=prev href=/posts/%E6%8A%80%E6%9C%AF/288/><span class=title>« Prev</span><br><span>css计数器教程</span></a>
<a class=next href=/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/226/><span class=title>Next »</span><br><span>三个比它们等效 ES5 速度慢的 ES 6 函数</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Deep In React 之浅谈 React Fiber 架构（一） on twitter" href="https://twitter.com/intent/tweet/?text=Deep%20In%20React%20%e4%b9%8b%e6%b5%85%e8%b0%88%20React%20Fiber%20%e6%9e%b6%e6%9e%84%ef%bc%88%e4%b8%80%ef%bc%89&url=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f262%2f&hashtags=react%2cJavaScript"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Deep In React 之浅谈 React Fiber 架构（一） on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f262%2f&title=Deep%20In%20React%20%e4%b9%8b%e6%b5%85%e8%b0%88%20React%20Fiber%20%e6%9e%b6%e6%9e%84%ef%bc%88%e4%b8%80%ef%bc%89&summary=Deep%20In%20React%20%e4%b9%8b%e6%b5%85%e8%b0%88%20React%20Fiber%20%e6%9e%b6%e6%9e%84%ef%bc%88%e4%b8%80%ef%bc%89&source=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f262%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Deep In React 之浅谈 React Fiber 架构（一） on reddit" href="https://reddit.com/submit?url=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f262%2f&title=Deep%20In%20React%20%e4%b9%8b%e6%b5%85%e8%b0%88%20React%20Fiber%20%e6%9e%b6%e6%9e%84%ef%bc%88%e4%b8%80%ef%bc%89"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Deep In React 之浅谈 React Fiber 架构（一） on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f262%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Deep In React 之浅谈 React Fiber 架构（一） on whatsapp" href="https://api.whatsapp.com/send?text=Deep%20In%20React%20%e4%b9%8b%e6%b5%85%e8%b0%88%20React%20Fiber%20%e6%9e%b6%e6%9e%84%ef%bc%88%e4%b8%80%ef%bc%89%20-%20%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f262%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Deep In React 之浅谈 React Fiber 架构（一） on telegram" href="https://telegram.me/share/url?text=Deep%20In%20React%20%e4%b9%8b%e6%b5%85%e8%b0%88%20React%20Fiber%20%e6%9e%b6%e6%9e%84%ef%bc%88%e4%b8%80%ef%bc%89&url=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f262%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href>桃园</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>