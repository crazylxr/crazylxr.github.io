<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>如何对 React 函数式组件进行优化 | 桃园</title><meta name=keywords content="react,JavaScript,性能优化"><meta name=description content="前言 目的 本文只介绍函数式组件特有的性能优化方式，类组件和函数式组件都有的不介绍，比如 key 的使用。另外本文不详细的介绍 API 的使用，后面也许会写，其实想用好 hooks 还是蛮难的。
面向读者 有过 React 函数式组件的实践，并且对 hooks 有过实践，对 useState、useCallback、useMemo API 至少看过文档，如果你有过对类组件的性能优化经历，那么这篇文章会让你有种熟悉的感觉。
React 性能优化思路 我觉得React 性能优化的理念的主要方向就是这两个：
减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconction(简单的可以理解为 diff)，如果不 render，就不会 reconction。
减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。
在使用类组件的时候，使用的 React 优化 API 主要是：shouldComponentUpdate 和 PureComponent，这两个 API 所提供的解决思路都是为了减少重新 render 的次数，主要是减少父组件更新而子组件也更新的情况，虽然也可以在 state 更新的时候阻止当前组件渲染，如果要这么做的话，证明你这个属性不适合作为 state，而应该作为静态属性或者放在 class 外面作为一个简单的变量 。
但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？
React.memo 首先要介绍的就是 React.memo，这个 API 可以说是对标类组件里面的 PureComponent，这是可以减少重新 render 的次数的。
可能产生性能问题的例子 举个例子，首先我们看两段代码：
在根目录有一个 index.js，代码如下，实现的东西大概就是：上面一个 title，中间一个 button(点击 button 修改 title)，下面一个木偶组件，传递一个 name 进去。"><meta name=author content="桃翁"><link rel=canonical href=/posts/%E6%8A%80%E6%9C%AF/280/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.355db47b48ce042e543348876cce64165399cee8651ce7514d3c4b076b02f0aa.css integrity="sha256-NV20e0jOBC5UM0iHbM5kFlOZzuhlHOdRTTxLB2sC8Ko=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="如何对 React 函数式组件进行优化"><meta property="og:description" content="前言 目的 本文只介绍函数式组件特有的性能优化方式，类组件和函数式组件都有的不介绍，比如 key 的使用。另外本文不详细的介绍 API 的使用，后面也许会写，其实想用好 hooks 还是蛮难的。
面向读者 有过 React 函数式组件的实践，并且对 hooks 有过实践，对 useState、useCallback、useMemo API 至少看过文档，如果你有过对类组件的性能优化经历，那么这篇文章会让你有种熟悉的感觉。
React 性能优化思路 我觉得React 性能优化的理念的主要方向就是这两个：
减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconction(简单的可以理解为 diff)，如果不 render，就不会 reconction。
减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。
在使用类组件的时候，使用的 React 优化 API 主要是：shouldComponentUpdate 和 PureComponent，这两个 API 所提供的解决思路都是为了减少重新 render 的次数，主要是减少父组件更新而子组件也更新的情况，虽然也可以在 state 更新的时候阻止当前组件渲染，如果要这么做的话，证明你这个属性不适合作为 state，而应该作为静态属性或者放在 class 外面作为一个简单的变量 。
但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？
React.memo 首先要介绍的就是 React.memo，这个 API 可以说是对标类组件里面的 PureComponent，这是可以减少重新 render 的次数的。
可能产生性能问题的例子 举个例子，首先我们看两段代码：
在根目录有一个 index.js，代码如下，实现的东西大概就是：上面一个 title，中间一个 button(点击 button 修改 title)，下面一个木偶组件，传递一个 name 进去。"><meta property="og:type" content="article"><meta property="og:url" content="/posts/%E6%8A%80%E6%9C%AF/280/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-11-19T08:32:00+00:00"><meta property="article:modified_time" content="2019-11-19T08:32:00+00:00"><meta property="og:site_name" content="桃园"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="如何对 React 函数式组件进行优化"><meta name=twitter:description content="前言 目的 本文只介绍函数式组件特有的性能优化方式，类组件和函数式组件都有的不介绍，比如 key 的使用。另外本文不详细的介绍 API 的使用，后面也许会写，其实想用好 hooks 还是蛮难的。
面向读者 有过 React 函数式组件的实践，并且对 hooks 有过实践，对 useState、useCallback、useMemo API 至少看过文档，如果你有过对类组件的性能优化经历，那么这篇文章会让你有种熟悉的感觉。
React 性能优化思路 我觉得React 性能优化的理念的主要方向就是这两个：
减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconction(简单的可以理解为 diff)，如果不 render，就不会 reconction。
减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。
在使用类组件的时候，使用的 React 优化 API 主要是：shouldComponentUpdate 和 PureComponent，这两个 API 所提供的解决思路都是为了减少重新 render 的次数，主要是减少父组件更新而子组件也更新的情况，虽然也可以在 state 更新的时候阻止当前组件渲染，如果要这么做的话，证明你这个属性不适合作为 state，而应该作为静态属性或者放在 class 外面作为一个简单的变量 。
但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？
React.memo 首先要介绍的就是 React.memo，这个 API 可以说是对标类组件里面的 PureComponent，这是可以减少重新 render 的次数的。
可能产生性能问题的例子 举个例子，首先我们看两段代码：
在根目录有一个 index.js，代码如下，实现的东西大概就是：上面一个 title，中间一个 button(点击 button 修改 title)，下面一个木偶组件，传递一个 name 进去。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"如何对 React 函数式组件进行优化","item":"/posts/%E6%8A%80%E6%9C%AF/280/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何对 React 函数式组件进行优化","name":"如何对 React 函数式组件进行优化","description":"前言 目的 本文只介绍函数式组件特有的性能优化方式，类组件和函数式组件都有的不介绍，比如 key 的使用。另外本文不详细的介绍 API 的使用，后面也许会写，其实想用好 hooks 还是蛮难的。\n面向读者 有过 React 函数式组件的实践，并且对 hooks 有过实践，对 useState、useCallback、useMemo API 至少看过文档，如果你有过对类组件的性能优化经历，那么这篇文章会让你有种熟悉的感觉。\nReact 性能优化思路 我觉得React 性能优化的理念的主要方向就是这两个：\n减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconction(简单的可以理解为 diff)，如果不 render，就不会 reconction。\n减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。\n在使用类组件的时候，使用的 React 优化 API 主要是：shouldComponentUpdate 和 PureComponent，这两个 API 所提供的解决思路都是为了减少重新 render 的次数，主要是减少父组件更新而子组件也更新的情况，虽然也可以在 state 更新的时候阻止当前组件渲染，如果要这么做的话，证明你这个属性不适合作为 state，而应该作为静态属性或者放在 class 外面作为一个简单的变量 。\n但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？\nReact.memo 首先要介绍的就是 React.memo，这个 API 可以说是对标类组件里面的 PureComponent，这是可以减少重新 render 的次数的。\n可能产生性能问题的例子 举个例子，首先我们看两段代码：\n在根目录有一个 index.js，代码如下，实现的东西大概就是：上面一个 title，中间一个 button(点击 button 修改 title)，下面一个木偶组件，传递一个 name 进去。","keywords":["react","JavaScript","性能优化"],"articleBody":"前言 目的 本文只介绍函数式组件特有的性能优化方式，类组件和函数式组件都有的不介绍，比如 key 的使用。另外本文不详细的介绍 API 的使用，后面也许会写，其实想用好 hooks 还是蛮难的。\n面向读者 有过 React 函数式组件的实践，并且对 hooks 有过实践，对 useState、useCallback、useMemo API 至少看过文档，如果你有过对类组件的性能优化经历，那么这篇文章会让你有种熟悉的感觉。\nReact 性能优化思路 我觉得React 性能优化的理念的主要方向就是这两个：\n减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconction(简单的可以理解为 diff)，如果不 render，就不会 reconction。\n减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。\n在使用类组件的时候，使用的 React 优化 API 主要是：shouldComponentUpdate 和 PureComponent，这两个 API 所提供的解决思路都是为了减少重新 render 的次数，主要是减少父组件更新而子组件也更新的情况，虽然也可以在 state 更新的时候阻止当前组件渲染，如果要这么做的话，证明你这个属性不适合作为 state，而应该作为静态属性或者放在 class 外面作为一个简单的变量 。\n但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？\nReact.memo 首先要介绍的就是 React.memo，这个 API 可以说是对标类组件里面的 PureComponent，这是可以减少重新 render 的次数的。\n可能产生性能问题的例子 举个例子，首先我们看两段代码：\n在根目录有一个 index.js，代码如下，实现的东西大概就是：上面一个 title，中间一个 button(点击 button 修改 title)，下面一个木偶组件，传递一个 name 进去。\n// index.js import React, { useState } from \"react\"; import ReactDOM from \"react-dom\"; import Child from './child' function App() { const [title, setTitle] = useState(\"这是一个 title\") return ( \u003cdiv className=\"App\"\u003e \u003ch1\u003e{ title }\u003c/h1\u003e \u003cbutton onClick={() =\u003e setTitle(\"title 已经改变\")}\u003e改名字\u003c/button\u003e \u003cChild name=\"桃桃\"\u003e\u003c/Child\u003e \u003c/div\u003e ); } const rootElement = document.getElementById(\"root\"); ReactDOM.render(\u003cApp /\u003e, rootElement); 在同级目录有一个 child.js\n// child.js import React from \"react\"; function Child(props) { console.log(props.name) return \u003ch1\u003e{props.name}\u003c/h1\u003e } export default Child 当首次渲染的时候的效果如下：\n并且控制台会打印\"桃桃”，证明 Child 组件渲染了。\n接下来点击改名字这个 button，页面会变成：\ntitle 已经改变了，而且控制台也打印出\"桃桃\"，可以看到虽然我们改的是父组件的状态，父组件重新渲染了，并且子组件也重新渲染了。你可能会想，传递给 Child 组件的 props 没有变，要是 Child 组件不重新渲染就好了，为什么会这么想呢？\n我们假设 Child 组件是一个非常大的组件，渲染一次会消耗很多的性能，那么我们就应该尽量减少这个组件的渲染，否则就容易产生性能问题，所以子组件如果在 props 没有变化的情况下，就算父组件重新渲染了，子组件也不应该渲染。\n那么我们怎么才能做到在 props 没有变化的时候，子组件不渲染呢？\n答案就是用 React.memo 在给定相同 props 的情况下渲染相同的结果，并且通过记忆组件渲染结果的方式来提高组件的性能表现。\nReact.memo 的基础用法 把声明的组件通过React.memo包一层就好了，React.memo其实是一个高阶函数，传递一个组件进去，返回一个可以记忆的组件。\nfunction Component(props) { /* 使用 props 渲染 */ } const MyComponent = React.memo(Component); 那么上面例子的 Child 组件就可以改成这样：\nimport React from \"react\"; function Child(props) { console.log(props.name) return \u003ch1\u003e{props.name}\u003c/h1\u003e } export default React.memo(Child) 通过 React.memo 包裹的组件在 props 不变的情况下，这个被包裹的组件是不会重新渲染的，也就是说上面那个例子，在我点击改名字之后，仅仅是 title 会变，但是 Child 组件不会重新渲染（表现出来的效果就是 Child 里面的 log 不会在控制台打印出来），会直接复用最近一次渲染的结果。\n这个效果基本跟类组件里面的 PureComponent效果极其类似，只是前者用于函数组件，后者用于类组件。\nReact.memo 高级用法 默认情况下其只会对 props 的复杂对象做浅层对比(浅层对比就是只会对比前后两次 props 对象引用是否相同，不会对比对象里面的内容是否相同)，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。\nfunction MyComponent(props) { /* 使用 props 渲染 */ } function areEqual(prevProps, nextProps) { /* 如果把 nextProps 传入 render 方法的返回结果与 将 prevProps 传入 render 方法的返回结果一致则返回 true， 否则返回 false */ } export default React.memo(MyComponent, areEqual); 此部分来自于 React 官网。\n如果你有在类组件里面使用过 shouldComponentUpdate() 这个方法，你会对 React.memo 的第二个参数非常的熟悉，不过值得注意的是，如果 props 相等，areEqual 会返回 true；如果 props 不相等，则返回 false。这与 shouldComponentUpdate 方法的返回值相反。\nuseCallback 现在根据上面的例子，再改一下需求，在上面的需求上增加一个副标题，并且有一个修改副标题的 button，然后把修改标题的 button 放到 Child 组件里。\n把修改标题的 button 放到 Child 组件的目的是，将修改 title 的事件通过 props 传递给 Child 组件，然后观察这个事件可能会引起性能问题。\n首先看代码：\n父组件 index.js\n// index.js import React, { useState } from \"react\"; import ReactDOM from \"react-dom\"; import Child from \"./child\"; function App() { const [title, setTitle] = useState(\"这是一个 title\"); const [subtitle, setSubtitle] = useState(\"我是一个副标题\"); const callback = () =\u003e { setTitle(\"标题改变了\"); }; return ( \u003cdiv className=\"App\"\u003e \u003ch1\u003e{title}\u003c/h1\u003e \u003ch2\u003e{subtitle}\u003c/h2\u003e \u003cbutton onClick={() =\u003e setSubtitle(\"副标题改变了\")}\u003e改副标题\u003c/button\u003e \u003cChild onClick={callback} name=\"桃桃\" /\u003e \u003c/div\u003e ); } const rootElement = document.getElementById(\"root\"); ReactDOM.render(\u003cApp /\u003e, rootElement); 子组件 child.js\nimport React from \"react\"; function Child(props) { console.log(props); return ( \u003c\u003e \u003cbutton onClick={props.onClick}\u003e改标题\u003c/button\u003e \u003ch1\u003e{props.name}\u003c/h1\u003e \u003c/\u003e ); } export default React.memo(Child); 首次渲染的效果\n这段代码在首次渲染的时候会显示上图的样子，并且控制台会打印出桃桃。\n然后当我点击改副标题这个 button 之后，副标题会变为「副标题改变了」，并且控制台会再次打印出桃桃，这就证明了子组件又重新渲染了，但是子组件没有任何变化，那么这次 Child 组件的重新渲染就是多余的，那么如何避免掉这个多余的渲染呢？\n找原因 我们在解决问题的之前，首先要知道这个问题是什么原因导致的？\n咱们来分析，一个组件重新重新渲染，一般三种情况：\n要么是组件自己的状态改变\n要么是父组件重新渲染，导致子组件重新渲染，但是父组件的 props 没有改版\n要么是父组件重新渲染，导致子组件重新渲染，但是父组件传递的 props 改变\n接下来用排除法查出是什么原因导致的：\n第一种很明显就排除了，当点击改副标题 的时候并没有去改变 Child 组件的状态；\n第二种情况好好想一下，是不是就是在介绍 React.memo 的时候情况，父组件重新渲染了，父组件传递给子组件的 props 没有改变，但是子组件重新渲染了，我们这个时候用 React.memo 来解决了这个问题，所以这种情况也排除。\n那么就是第三种情况了，当父组件重新渲染的时候，传递给子组件的 props 发生了改变，再看传递给 Child 组件的就两个属性，一个是 name，一个是 onClick ，name 是传递的常量，不会变，变的就是 onClick 了，为什么传递给 onClick 的 callback 函数会发生改变呢？在文章的开头就已经说过了，在函数式组件里每次重新渲染，函数组件都会重头开始重新执行，那么这两次创建的 callback 函数肯定发生了改变，所以导致了子组件重新渲染。\n如何解决 找到问题的原因了，那么解决办法就是在函数没有改变的时候，重新渲染的时候保持两个函数的引用一致，这个时候就要用到 useCallback 这个 API 了。\nuseCallback 使用方法 const callback = () =\u003e { doSomething(a, b); } const memoizedCallback = useCallback(callback, [a, b]) 把函数以及依赖项作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，这个 memoizedCallback 只有在依赖项有变化的时候才会更新。\n那么可以将 index.js 修改为这样：\n// index.js import React, { useState, useCallback } from \"react\"; import ReactDOM from \"react-dom\"; import Child from \"./child\"; function App() { const [title, setTitle] = useState(\"这是一个 title\"); const [subtitle, setSubtitle] = useState(\"我是一个副标题\"); const callback = () =\u003e { setTitle(\"标题改变了\"); }; // 通过 useCallback 进行记忆 callback，并将记忆的 callback 传递给 Child const memoizedCallback = useCallback(callback, []) return ( \u003cdiv className=\"App\"\u003e \u003ch1\u003e{title}\u003c/h1\u003e \u003ch2\u003e{subtitle}\u003c/h2\u003e \u003cbutton onClick={() =\u003e setSubtitle(\"副标题改变了\")}\u003e改副标题\u003c/button\u003e \u003cChild onClick={memoizedCallback} name=\"桃桃\" /\u003e \u003c/div\u003e ); } const rootElement = document.getElementById(\"root\"); ReactDOM.render(\u003cApp /\u003e, rootElement); 这样我们就可以看到只会在首次渲染的时候打印出桃桃，当点击改副标题和改标题的时候是不会打印桃桃的。\n如果我们的 callback 传递了参数，当参数变化的时候需要让它重新添加一个缓存，可以将参数放在 useCallback 第二个参数的数组中，作为依赖的形式，使用方式跟 useEffect 类似。\nuseMemo 在文章的开头就已经介绍了，React 的性能优化方向主要是两个：一个是减少重新 render 的次数(或者说减少不必要的渲染)，另一个是减少计算的量。\n前面介绍的 React.memo 和 useCallback 都是为了减少重新 render 的次数。对于如何减少计算的量，就是 useMemo 来做的，接下来我们看例子。\nfunction App() { const [num, setNum] = useState(0); // 一个非常耗时的一个计算函数 // result 最后返回的值是 49995000 function expensiveFn() { let result = 0; for (let i = 0; i \u003c 10000; i++) { result += i; } console.log(result) // 49995000 return result; } const base = expensiveFn(); return ( \u003cdiv className=\"App\"\u003e \u003ch1\u003ecount：{num}\u003c/h1\u003e \u003cbutton onClick={() =\u003e setNum(num + base)}\u003e+1\u003c/button\u003e \u003c/div\u003e ); } 首次渲染的效果如下：\n这个例子功能很简单，就是点击 +1 按钮，然后会将现在的值(num) 与 计算函数 (expensiveFn) 调用后的值相加，然后将和设置给 num 并显示出来，在控制台会输出 49995000。\n可能产生性能问题 就算是一个看起来很简单的组件，也有可能产生性能问题，通过这个最简单的例子来看看还有什么值得优化的地方。\n首先我们把 expensiveFn 函数当做一个计算量很大的函数(比如你可以把 i 换成 10000000)，然后当我们每次点击 +1 按钮的时候，都会重新渲染组件，而且都会调用 expensiveFn 函数并输出 49995000。由于每次调用 expensiveFn 所返回的值都一样，所以我们可以想办法将计算出来的值缓存起来，每次调用函数直接返回缓存的值，这样就可以做一些性能优化。\nuseMemo 做计算结果缓存 针对上面产生的问题，就可以用 useMemo 来缓存 expensiveFn 函数执行后的值。\n首先介绍一下 useMemo 的基本的使用方法，详细的使用方法可见官网：\nfunction computeExpensiveValue() { // 计算量很大的代码 return xxx } const memoizedValue = useMemo(computeExpensiveValue, [a, b]); useMemo 的第一个参数就是一个函数，这个函数返回的值会被缓存起来，同时这个值会作为 useMemo 的返回值，第二个参数是一个数组依赖，如果数组里面的值有变化，那么就会重新去执行第一个参数里面的函数，并将函数返回的值缓存起来并作为 useMemo 的返回值 。\n了解了 useMemo 的使用方法，然后就可以对上面的例子进行优化，优化代码如下：\nfunction App() { const [num, setNum] = useState(0); function expensiveFn() { let result = 0; for (let i = 0; i \u003c 10000; i++) { result += i; } console.log(result) return result; } const base = useMemo(expensiveFn, []); return ( \u003cdiv className=\"App\"\u003e \u003ch1\u003ecount：{num}\u003c/h1\u003e \u003cbutton onClick={() =\u003e setNum(num + base)}\u003e+1\u003c/button\u003e \u003c/div\u003e ); } 执行上面的代码，然后现在可以观察无论我们点击 +1多少次，只会输出一次 49995000，这就代表 expensiveFn 只执行了一次，达到了我们想要的效果。\n小结 useMemo 的使用场景主要是用来缓存计算量比较大的函数结果，可以避免不必要的重复计算，有过 vue 的使用经历同学可能会觉得跟 Vue 里面的计算属性有异曲同工的作用。\n不过另外提醒两点\n一、如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值；\n二、计算量如果很小的计算函数，也可以选择不使用 useMemo，因为这点优化并不会作为性能瓶颈的要点，反而可能使用错误还会引起一些性能问题。\n总结 对于性能瓶颈可能对于小项目遇到的比较少，毕竟计算量小、业务逻辑也不复杂，但是对于大项目，很可能是会遇到性能瓶颈的，但是对于性能优化有很多方面：网络、关键路径渲染、打包、图片、缓存等等方面，具体应该去优化哪方面还得自己去排查，本文只介绍了性能优化中的冰山一角：运行过程中 React 的优化。\nReact 的优化方向：减少 render 的次数；减少重复计算。 如何去找到 React 中导致性能问题的方法，见 useCallback 部分。 合理的拆分组件其实也是可以做性能优化的，你这么想，如果你整个页面只有一个大的组件，那么当 props 或者 state 变更之后，需要 reconction 的是整个组件，其实你只是变了一个文字，如果你进行了合理的组件拆分，你就可以控制更小粒度的更新。 合理拆分组件还有很多其他好处，比如好维护，而且这是学习组件化思想的第一步，合理的拆分组件又是一门艺术了，如果拆分得不合理，就有可能导致状态混乱，多敲代码多思考。\n推荐文章 我这里只介绍了函数式组件的优化方式，更多的 React 优化技巧可以阅读下面的文章：\n21 个 React 性能优化技巧 浅谈React性能优化的方向 后记 我是桃翁，一个爱思考的前端er，想了解关于更多的前端相关的，请关注我的公号：「前端桃园」，如果想加入交流群关注公众号后回复「微信」拉你进群\n","wordCount":"774","inLanguage":"en","datePublished":"2019-11-19T08:32:00Z","dateModified":"2019-11-19T08:32:00Z","author":{"@type":"Person","name":"桃翁"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E6%8A%80%E6%9C%AF/280/"},"publisher":{"@type":"Organization","name":"桃园","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/archives/ title=Archives><span>Archives</span></a></li><li><a href=/categories/ title=Categories><span>Categories</span></a></li><li><a href=search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>如何对 React 函数式组件进行优化</h1><div class=post-meta><span title='2019-11-19 08:32:00 +0000 UTC'>November 19, 2019</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;774 words&nbsp;·&nbsp;桃翁&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/%e6%8a%80%e6%9c%af/2019-11-19-%e5%a6%82%e4%bd%95%e5%af%b9_React_%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e4%bc%98%e5%8c%96.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a><ul><li><a href=#%e7%9b%ae%e7%9a%84 aria-label=目的>目的</a></li><li><a href=#%e9%9d%a2%e5%90%91%e8%af%bb%e8%80%85 aria-label=面向读者>面向读者</a></li><li><a href=#react-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%80%9d%e8%b7%af aria-label="React 性能优化思路">React 性能优化思路</a></li></ul></li><li><a href=#reactmemo aria-label=React.memo>React.memo</a><ul><li><a href=#%e5%8f%af%e8%83%bd%e4%ba%a7%e7%94%9f%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e7%9a%84%e4%be%8b%e5%ad%90 aria-label=可能产生性能问题的例子>可能产生性能问题的例子</a></li><li><a href=#reactmemo-%e7%9a%84%e5%9f%ba%e7%a1%80%e7%94%a8%e6%b3%95 aria-label="React.memo 的基础用法">React.memo 的基础用法</a></li><li><a href=#reactmemo-%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95 aria-label="React.memo 高级用法">React.memo 高级用法</a></li></ul></li><li><a href=#usecallback aria-label=useCallback>useCallback</a><ul><li><a href=#%e6%89%be%e5%8e%9f%e5%9b%a0 aria-label=找原因>找原因</a></li><li><a href=#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3 aria-label=如何解决>如何解决</a><ul><li><a href=#usecallback-%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95 aria-label="useCallback 使用方法">useCallback 使用方法</a></li></ul></li></ul></li><li><a href=#usememo aria-label=useMemo>useMemo</a><ul><li><a href=#%e5%8f%af%e8%83%bd%e4%ba%a7%e7%94%9f%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98 aria-label=可能产生性能问题>可能产生性能问题</a></li><li><a href=#usememo-%e5%81%9a%e8%ae%a1%e7%ae%97%e7%bb%93%e6%9e%9c%e7%bc%93%e5%ad%98 aria-label="useMemo 做计算结果缓存">useMemo 做计算结果缓存</a></li><li><a href=#%e5%b0%8f%e7%bb%93 aria-label=小结>小结</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e6%8e%a8%e8%8d%90%e6%96%87%e7%ab%a0 aria-label=推荐文章>推荐文章</a></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><h3 id=目的>目的<a hidden class=anchor aria-hidden=true href=#目的>#</a></h3><p>本文只介绍函数式组件特有的性能优化方式，类组件和函数式组件都有的不介绍，比如 key 的使用。另外本文不详细的介绍 API 的使用，后面也许会写，其实想用好 hooks 还是蛮难的。</p><h3 id=面向读者>面向读者<a hidden class=anchor aria-hidden=true href=#面向读者>#</a></h3><p>有过 React 函数式组件的实践，并且对 hooks 有过实践，对 useState、useCallback、useMemo API 至少看过文档，如果你有过对类组件的性能优化经历，那么这篇文章会让你有种熟悉的感觉。</p><h3 id=react-性能优化思路>React 性能优化思路<a hidden class=anchor aria-hidden=true href=#react-性能优化思路>#</a></h3><p>我觉得React 性能优化的理念的主要方向就是这两个：</p><ol><li><p>减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconction(简单的可以理解为 diff)，如果不 render，就不会 reconction。</p></li><li><p>减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。</p></li></ol><p>在使用类组件的时候，使用的 React 优化 API 主要是：<code>shouldComponentUpdate </code>和 <code>PureComponent</code>，这两个 API 所提供的解决思路都是为了<strong>减少重新 render 的次数</strong>，主要是减少父组件更新而子组件也更新的情况，虽然也可以在 state 更新的时候阻止当前组件渲染，如果要这么做的话，证明你这个属性不适合作为 state，而应该作为静态属性或者放在 class 外面作为一个简单的变量 。</p><p>但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？</p><h2 id=reactmemo>React.memo<a hidden class=anchor aria-hidden=true href=#reactmemo>#</a></h2><p>首先要介绍的就是 <code>React.memo</code>，这个 API 可以说是对标类组件里面的 <code>PureComponent</code>，这是可以减少重新 render 的次数的。</p><h3 id=可能产生性能问题的例子>可能产生性能问题的例子<a hidden class=anchor aria-hidden=true href=#可能产生性能问题的例子>#</a></h3><p>举个例子，首先我们看两段代码：</p><p>在根目录有一个 index.js，代码如下，实现的东西大概就是：上面一个 title，中间一个 button(点击 button 修改 title)，下面一个木偶组件，传递一个 name 进去。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// index.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=nx>React</span><span class=p>,</span> <span class=p>{</span> <span class=nx>useState</span> <span class=p>}</span> <span class=nx>from</span> <span class=s2>&#34;react&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=nx>ReactDOM</span> <span class=nx>from</span> <span class=s2>&#34;react-dom&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=nx>Child</span> <span class=nx>from</span> <span class=s1>&#39;./child&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>title</span><span class=p>,</span> <span class=nx>setTitle</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=s2>&#34;这是一个 title&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span> <span class=nx>className</span><span class=o>=</span><span class=s2>&#34;App&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=p>{</span> <span class=nx>title</span> <span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=p>=&gt;</span> <span class=nx>setTitle</span><span class=p>(</span><span class=s2>&#34;title 已经改变&#34;</span><span class=p>)}</span><span class=o>&gt;</span><span class=nx>改名字</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>Child</span> <span class=nx>name</span><span class=o>=</span><span class=s2>&#34;桃桃&#34;</span><span class=o>&gt;&lt;</span><span class=err>/Child&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>rootElement</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;root&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>ReactDOM</span><span class=p>.</span><span class=nx>render</span><span class=p>(</span><span class=o>&lt;</span><span class=nx>App</span> <span class=o>/&gt;</span><span class=p>,</span> <span class=nx>rootElement</span><span class=p>);</span>
</span></span></code></pre></div><p>在同级目录有一个 child.js</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// child.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=nx>React</span> <span class=nx>from</span> <span class=s2>&#34;react&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Child</span><span class=p>(</span><span class=nx>props</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>props</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>props</span><span class=p>.</span><span class=nx>name</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=nx>Child</span>
</span></span></code></pre></div><p>当首次渲染的时候的效果如下：</p><p><img loading=lazy src=http://imgs.taoweng.site/2019-10-30-141225.png alt=image-20191030221223045></p><p>并且控制台会打印<code>"桃桃”</code>，证明 Child 组件渲染了。</p><p>接下来点击<strong>改名字</strong>这个 button，页面会变成：</p><p><img loading=lazy src=http://imgs.taoweng.site/2019-10-30-142024.png alt=image-20191030222021717></p><p>title 已经改变了，而且控制台也打印出<code>"桃桃"</code>，可以看到虽然我们改的是父组件的状态，父组件重新渲染了，并且子组件也重新渲染了。你可能会想，传递给 Child 组件的 props 没有变，要是 Child 组件不重新渲染就好了，为什么会这么想呢？</p><p>我们假设 Child 组件是一个非常大的组件，渲染一次会消耗很多的性能，那么我们就应该尽量减少这个组件的渲染，否则就容易产生性能问题，所以子组件如果在 props 没有变化的情况下，就算父组件重新渲染了，子组件也不应该渲染。</p><p>那么我们怎么才能做到在 props 没有变化的时候，子组件不渲染呢？</p><p>答案就是用 <code>React.memo</code> 在给定相同 props 的情况下渲染相同的结果，并且通过记忆组件渲染结果的方式来提高组件的性能表现。</p><h3 id=reactmemo-的基础用法>React.memo 的基础用法<a hidden class=anchor aria-hidden=true href=#reactmemo-的基础用法>#</a></h3><p>把声明的组件通过<code>React.memo</code>包一层就好了，<code>React.memo</code>其实是一个高阶函数，传递一个组件进去，返回一个可以记忆的组件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Component</span><span class=p>(</span><span class=nx>props</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=cm>/* 使用 props 渲染 */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>MyComponent</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>memo</span><span class=p>(</span><span class=nx>Component</span><span class=p>);</span>
</span></span></code></pre></div><p>那么上面例子的 Child 组件就可以改成这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>import</span> <span class=nx>React</span> <span class=nx>from</span> <span class=s2>&#34;react&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Child</span><span class=p>(</span><span class=nx>props</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>props</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>props</span><span class=p>.</span><span class=nx>name</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=nx>React</span><span class=p>.</span><span class=nx>memo</span><span class=p>(</span><span class=nx>Child</span><span class=p>)</span>
</span></span></code></pre></div><p>通过 <code>React.memo</code> 包裹的组件在 props 不变的情况下，这个被包裹的组件是不会重新渲染的，也就是说上面那个例子，在我点击改名字之后，仅仅是 title 会变，但是 Child 组件不会重新渲染（表现出来的效果就是 Child 里面的 log 不会在控制台打印出来），会直接复用最近一次渲染的结果。</p><p>这个效果基本跟类组件里面的 <code>PureComponent</code>效果极其类似，只是前者用于函数组件，后者用于类组件。</p><h3 id=reactmemo-高级用法>React.memo 高级用法<a hidden class=anchor aria-hidden=true href=#reactmemo-高级用法>#</a></h3><p>默认情况下其只会对 props 的复杂对象做浅层对比(浅层对比就是只会对比前后两次 props 对象引用是否相同，不会对比对象里面的内容是否相同)，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>MyComponent</span><span class=p>(</span><span class=nx>props</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* 使用 props 渲染 */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>areEqual</span><span class=p>(</span><span class=nx>prevProps</span><span class=p>,</span> <span class=nx>nextProps</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  如果把 nextProps 传入 render 方法的返回结果与
</span></span></span><span class=line><span class=cl><span class=cm>  将 prevProps 传入 render 方法的返回结果一致则返回 true，
</span></span></span><span class=line><span class=cl><span class=cm>  否则返回 false
</span></span></span><span class=line><span class=cl><span class=cm>  */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=nx>React</span><span class=p>.</span><span class=nx>memo</span><span class=p>(</span><span class=nx>MyComponent</span><span class=p>,</span> <span class=nx>areEqual</span><span class=p>);</span>
</span></span></code></pre></div><blockquote><p>此部分来自于 <a href=https://zh-hans.reactjs.org/docs/react-api.html#reactmemo>React 官网</a>。</p></blockquote><p>如果你有在类组件里面使用过 <a href=https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate><code>shouldComponentUpdate()</code></a> 这个方法，你会对 <code>React.memo</code> 的第二个参数非常的熟悉，不过值得注意的是，如果 props 相等，<code>areEqual</code> 会返回 <code>true</code>；如果 props 不相等，则返回 <code>false</code>。这与 <code>shouldComponentUpdate</code> 方法的返回值相反。</p><h2 id=usecallback>useCallback<a hidden class=anchor aria-hidden=true href=#usecallback>#</a></h2><p>现在根据上面的例子，再改一下需求，在上面的需求上增加一个副标题，并且有一个修改副标题的 button，然后把修改标题的 button 放到 Child 组件里。</p><blockquote><p>把修改标题的 button 放到 Child 组件的目的是，将修改 title 的事件通过 props 传递给 Child 组件，然后观察这个事件可能会引起性能问题。</p></blockquote><p><strong>首先看代码：</strong></p><p>父组件 index.js</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// index.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=nx>React</span><span class=p>,</span> <span class=p>{</span> <span class=nx>useState</span> <span class=p>}</span> <span class=nx>from</span> <span class=s2>&#34;react&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=nx>ReactDOM</span> <span class=nx>from</span> <span class=s2>&#34;react-dom&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=nx>Child</span> <span class=nx>from</span> <span class=s2>&#34;./child&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>title</span><span class=p>,</span> <span class=nx>setTitle</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=s2>&#34;这是一个 title&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>subtitle</span><span class=p>,</span> <span class=nx>setSubtitle</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=s2>&#34;我是一个副标题&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>callback</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setTitle</span><span class=p>(</span><span class=s2>&#34;标题改变了&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span> <span class=nx>className</span><span class=o>=</span><span class=s2>&#34;App&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>title</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>h2</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>subtitle</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h2&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=p>=&gt;</span> <span class=nx>setSubtitle</span><span class=p>(</span><span class=s2>&#34;副标题改变了&#34;</span><span class=p>)}</span><span class=o>&gt;</span><span class=nx>改副标题</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>Child</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>callback</span><span class=p>}</span> <span class=nx>name</span><span class=o>=</span><span class=s2>&#34;桃桃&#34;</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>rootElement</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;root&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>ReactDOM</span><span class=p>.</span><span class=nx>render</span><span class=p>(</span><span class=o>&lt;</span><span class=nx>App</span> <span class=o>/&gt;</span><span class=p>,</span> <span class=nx>rootElement</span><span class=p>);</span>
</span></span></code></pre></div><p>子组件 child.js</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>import</span> <span class=nx>React</span> <span class=nx>from</span> <span class=s2>&#34;react&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Child</span><span class=p>(</span><span class=nx>props</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>props</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>props</span><span class=p>.</span><span class=nx>onClick</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>改标题</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>props</span><span class=p>.</span><span class=nx>name</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=nx>React</span><span class=p>.</span><span class=nx>memo</span><span class=p>(</span><span class=nx>Child</span><span class=p>);</span>
</span></span></code></pre></div><p><strong>首次渲染的效果</strong></p><p><img loading=lazy src=http://imgs.taoweng.site/2019-10-31-155607.png alt=image-20191031235605228></p><p>这段代码在首次渲染的时候会显示上图的样子，并且控制台会打印出<code>桃桃</code>。</p><p>然后当我点击<strong>改副标题</strong>这个 button 之后，副标题会变为「副标题改变了」，并且控制台会再次打印出<code>桃桃</code>，这就证明了子组件又重新渲染了，但是子组件没有任何变化，那么这次 Child 组件的重新渲染就是多余的，那么如何避免掉这个多余的渲染呢？</p><h3 id=找原因>找原因<a hidden class=anchor aria-hidden=true href=#找原因>#</a></h3><p>我们在解决问题的之前，<strong>首先要知道这个问题是什么原因导致的？</strong></p><p>咱们来分析，一个组件重新重新渲染，一般三种情况：</p><ol><li><p>要么是组件自己的状态改变</p></li><li><p>要么是父组件重新渲染，导致子组件重新渲染，但是父组件的 props 没有改版</p></li><li><p>要么是父组件重新渲染，导致子组件重新渲染，但是父组件传递的 props 改变</p></li></ol><p>接下来用排除法查出是什么原因导致的：</p><p>第一种很明显就排除了，当点击<strong>改副标题</strong> 的时候并没有去改变 Child 组件的状态；</p><p>第二种情况好好想一下，是不是就是在介绍 <code>React.memo</code> 的时候情况，父组件重新渲染了，父组件传递给子组件的 props 没有改变，但是子组件重新渲染了，我们这个时候用 <code>React.memo</code> 来解决了这个问题，所以这种情况也排除。</p><p>那么就是第三种情况了，当父组件重新渲染的时候，传递给子组件的 props 发生了改变，再看传递给 Child 组件的就两个属性，一个是 <code>name</code>，一个是 <code>onClick</code> ，<code>name</code> 是传递的常量，不会变，变的就是 <code>onClick</code> 了，为什么传递给 onClick 的 callback 函数会发生改变呢？在文章的开头就已经说过了，在函数式组件里每次重新渲染，函数组件都会重头开始重新执行，那么这两次创建的 callback 函数肯定发生了改变，所以导致了子组件重新渲染。</p><h3 id=如何解决>如何解决<a hidden class=anchor aria-hidden=true href=#如何解决>#</a></h3><p>找到问题的原因了，那么解决办法就是在函数没有改变的时候，重新渲染的时候保持两个函数的引用一致，这个时候就要用到 <code>useCallback</code> 这个 API 了。</p><h4 id=usecallback-使用方法>useCallback 使用方法<a hidden class=anchor aria-hidden=true href=#usecallback-使用方法>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>callback</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>doSomething</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>memoizedCallback</span> <span class=o>=</span> <span class=nx>useCallback</span><span class=p>(</span><span class=nx>callback</span><span class=p>,</span> <span class=p>[</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>])</span>
</span></span></code></pre></div><p>把函数以及依赖项作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，这个 memoizedCallback 只有在依赖项有变化的时候才会更新。</p><p>那么可以将 index.js 修改为这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// index.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=nx>React</span><span class=p>,</span> <span class=p>{</span> <span class=nx>useState</span><span class=p>,</span> <span class=nx>useCallback</span> <span class=p>}</span> <span class=nx>from</span> <span class=s2>&#34;react&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=nx>ReactDOM</span> <span class=nx>from</span> <span class=s2>&#34;react-dom&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=nx>Child</span> <span class=nx>from</span> <span class=s2>&#34;./child&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>title</span><span class=p>,</span> <span class=nx>setTitle</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=s2>&#34;这是一个 title&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>subtitle</span><span class=p>,</span> <span class=nx>setSubtitle</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=s2>&#34;我是一个副标题&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>callback</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setTitle</span><span class=p>(</span><span class=s2>&#34;标题改变了&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 通过 useCallback 进行记忆 callback，并将记忆的 callback 传递给 Child
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>memoizedCallback</span> <span class=o>=</span> <span class=nx>useCallback</span><span class=p>(</span><span class=nx>callback</span><span class=p>,</span> <span class=p>[])</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span> <span class=nx>className</span><span class=o>=</span><span class=s2>&#34;App&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>title</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>h2</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>subtitle</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h2&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=p>=&gt;</span> <span class=nx>setSubtitle</span><span class=p>(</span><span class=s2>&#34;副标题改变了&#34;</span><span class=p>)}</span><span class=o>&gt;</span><span class=nx>改副标题</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>Child</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>memoizedCallback</span><span class=p>}</span> <span class=nx>name</span><span class=o>=</span><span class=s2>&#34;桃桃&#34;</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>rootElement</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;root&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>ReactDOM</span><span class=p>.</span><span class=nx>render</span><span class=p>(</span><span class=o>&lt;</span><span class=nx>App</span> <span class=o>/&gt;</span><span class=p>,</span> <span class=nx>rootElement</span><span class=p>);</span>
</span></span></code></pre></div><p>这样我们就可以看到只会在首次渲染的时候打印出<strong>桃桃</strong>，当点击改副标题和改标题的时候是不会打印<strong>桃桃</strong>的。</p><p>如果我们的 callback 传递了参数，当参数变化的时候需要让它重新添加一个缓存，可以将参数放在 useCallback 第二个参数的数组中，作为依赖的形式，使用方式跟 useEffect 类似。</p><h2 id=usememo>useMemo<a hidden class=anchor aria-hidden=true href=#usememo>#</a></h2><p>在文章的开头就已经介绍了，React 的性能优化方向主要是两个：一个是减少重新 render 的次数(或者说减少不必要的渲染)，另一个是减少计算的量。</p><p>前面介绍的 <strong>React.memo</strong> 和 <strong>useCallback</strong> 都是为了减少重新 render 的次数。对于如何减少计算的量，就是 useMemo 来做的，接下来我们看例子。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>num</span><span class=p>,</span> <span class=nx>setNum</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 一个非常耗时的一个计算函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// result 最后返回的值是 49995000
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>function</span> <span class=nx>expensiveFn</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>result</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=mi>10000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>result</span> <span class=o>+=</span> <span class=nx>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>)</span> <span class=c1>// 49995000
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>base</span> <span class=o>=</span> <span class=nx>expensiveFn</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span> <span class=nx>className</span><span class=o>=</span><span class=s2>&#34;App&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>count</span><span class=err>：</span><span class=p>{</span><span class=nx>num</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=p>=&gt;</span> <span class=nx>setNum</span><span class=p>(</span><span class=nx>num</span> <span class=o>+</span> <span class=nx>base</span><span class=p>)}</span><span class=o>&gt;+</span><span class=mi>1</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>首次渲染的效果如下：</p><p><img loading=lazy src=http://imgs.taoweng.site/2019-11-13-124545.png alt=useMemo></p><p>这个例子功能很简单，就是点击 <strong>+1</strong> 按钮，然后会将现在的值(num) 与 计算函数 (expensiveFn) 调用后的值相加，然后将和设置给 num 并显示出来，在控制台会输出 <code>49995000</code>。</p><h3 id=可能产生性能问题>可能产生性能问题<a hidden class=anchor aria-hidden=true href=#可能产生性能问题>#</a></h3><p>就算是一个看起来很简单的组件，也有可能产生性能问题，通过这个最简单的例子来看看还有什么值得优化的地方。</p><p>首先我们把 expensiveFn 函数当做一个计算量很大的函数(比如你可以把 i 换成 10000000)，然后当我们每次点击 <strong>+1</strong> 按钮的时候，都会重新渲染组件，而且都会调用 expensiveFn 函数并输出 <code>49995000</code>。由于每次调用 expensiveFn 所返回的值都一样，所以我们可以想办法将计算出来的值缓存起来，每次调用函数直接返回缓存的值，这样就可以做一些性能优化。</p><h3 id=usememo-做计算结果缓存>useMemo 做计算结果缓存<a hidden class=anchor aria-hidden=true href=#usememo-做计算结果缓存>#</a></h3><p>针对上面产生的问题，就可以用 useMemo 来缓存 expensiveFn 函数执行后的值。</p><p>首先介绍一下 useMemo 的基本的使用方法，详细的使用方法可见<a href=https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo>官网</a>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>computeExpensiveValue</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 计算量很大的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=nx>xxx</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>memoizedValue</span> <span class=o>=</span> <span class=nx>useMemo</span><span class=p>(</span><span class=nx>computeExpensiveValue</span><span class=p>,</span> <span class=p>[</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>]);</span>
</span></span></code></pre></div><p>useMemo 的第一个参数就是一个函数，这个函数返回的值会被缓存起来，同时这个值会作为 useMemo 的返回值，第二个参数是一个数组依赖，如果数组里面的值有变化，那么就会重新去执行第一个参数里面的函数，并将函数返回的值缓存起来并作为 useMemo 的返回值 。</p><p>了解了 useMemo 的使用方法，然后就可以对上面的例子进行优化，优化代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>[</span><span class=nx>num</span><span class=p>,</span> <span class=nx>setNum</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>expensiveFn</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>result</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=mi>10000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>result</span> <span class=o>+=</span> <span class=nx>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>base</span> <span class=o>=</span> <span class=nx>useMemo</span><span class=p>(</span><span class=nx>expensiveFn</span><span class=p>,</span> <span class=p>[]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=nx>div</span> <span class=nx>className</span><span class=o>=</span><span class=s2>&#34;App&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>h1</span><span class=o>&gt;</span><span class=nx>count</span><span class=err>：</span><span class=p>{</span><span class=nx>num</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>button</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=p>=&gt;</span> <span class=nx>setNum</span><span class=p>(</span><span class=nx>num</span> <span class=o>+</span> <span class=nx>base</span><span class=p>)}</span><span class=o>&gt;+</span><span class=mi>1</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>执行上面的代码，然后现在可以观察无论我们点击 <strong>+1</strong>多少次，只会输出一次 <strong>49995000</strong>，这就代表 expensiveFn 只执行了一次，达到了我们想要的效果。</p><h3 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h3><p>useMemo 的使用场景主要是用来<strong>缓存计算量比较大的函数结果</strong>，可以避免不必要的重复计算，有过 vue 的使用经历同学可能会觉得跟 Vue 里面的计算属性有异曲同工的作用。</p><blockquote><p>不过另外提醒两点</p><p>一、如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值；</p><p>二、计算量如果很小的计算函数，也可以选择不使用 useMemo，因为这点优化并不会作为性能瓶颈的要点，反而可能使用错误还会引起一些性能问题。</p></blockquote><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>对于性能瓶颈可能对于小项目遇到的比较少，毕竟计算量小、业务逻辑也不复杂，但是对于大项目，很可能是会遇到性能瓶颈的，但是对于性能优化有很多方面：网络、关键路径渲染、打包、图片、缓存等等方面，具体应该去优化哪方面还得自己去排查，本文只介绍了性能优化中的冰山一角：运行过程中 React 的优化。</p><ol><li>React 的优化方向：减少 render 的次数；减少重复计算。</li><li>如何去找到 React 中导致性能问题的方法，见 useCallback 部分。</li><li>合理的拆分组件其实也是可以做性能优化的，你这么想，如果你整个页面只有一个大的组件，那么当 props 或者 state 变更之后，需要 reconction 的是整个组件，其实你只是变了一个文字，如果你进行了合理的组件拆分，你就可以控制更小粒度的更新。</li></ol><blockquote><p>合理拆分组件还有很多其他好处，比如好维护，而且这是学习组件化思想的第一步，合理的拆分组件又是一门艺术了，如果拆分得不合理，就有可能导致状态混乱，多敲代码多思考。</p></blockquote><h2 id=推荐文章>推荐文章<a hidden class=anchor aria-hidden=true href=#推荐文章>#</a></h2><p>我这里只介绍了函数式组件的优化方式，更多的 React 优化技巧可以阅读下面的文章：</p><ul><li><a href=https://www.infoq.cn/article/KVE8xtRs-uPphptq5LUz>21 个 React 性能优化技巧</a></li><li><a href=https://juejin.im/post/5d045350f265da1b695d5bf2#heading-0>浅谈React性能优化的方向</a></li></ul><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>我是桃翁，一个爱思考的前端er，想了解关于更多的前端相关的，请关注我的公号：「前端桃园」，如果想加入交流群关注公众号后回复「微信」拉你进群</p><p><img loading=lazy src=http://imgs.taoweng.site/2019-11-19-002953.jpg alt></p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/react/>react</a></li><li><a href=/tags/javascript/>JavaScript</a></li><li><a href=/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>性能优化</a></li></ul><nav class=paginav><a class=prev href=/posts/%E6%8A%80%E6%9C%AF/284/><span class=title>« Prev</span><br><span>通过fetch发送 post 请求下载文件</span></a>
<a class=next href=/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/272/><span class=title>Next »</span><br><span>在mac上安装XAMPP并搭建 typecho 博客</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 如何对 React 函数式组件进行优化 on twitter" href="https://twitter.com/intent/tweet/?text=%e5%a6%82%e4%bd%95%e5%af%b9%20React%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e4%bc%98%e5%8c%96&url=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f280%2f&hashtags=react%2cJavaScript%2c%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 如何对 React 函数式组件进行优化 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f280%2f&title=%e5%a6%82%e4%bd%95%e5%af%b9%20React%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e4%bc%98%e5%8c%96&summary=%e5%a6%82%e4%bd%95%e5%af%b9%20React%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e4%bc%98%e5%8c%96&source=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f280%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 如何对 React 函数式组件进行优化 on reddit" href="https://reddit.com/submit?url=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f280%2f&title=%e5%a6%82%e4%bd%95%e5%af%b9%20React%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e4%bc%98%e5%8c%96"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 如何对 React 函数式组件进行优化 on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f280%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 如何对 React 函数式组件进行优化 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%a6%82%e4%bd%95%e5%af%b9%20React%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e4%bc%98%e5%8c%96%20-%20%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f280%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 如何对 React 函数式组件进行优化 on telegram" href="https://telegram.me/share/url?text=%e5%a6%82%e4%bd%95%e5%af%b9%20React%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bb%84%e4%bb%b6%e8%bf%9b%e8%a1%8c%e4%bc%98%e5%8c%96&url=%2fposts%2f%25E6%258A%2580%25E6%259C%25AF%2f280%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href>桃园</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>