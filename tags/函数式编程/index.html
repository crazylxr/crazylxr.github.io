<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>函数式编程 | 桃园</title><meta name=keywords content><meta name=description content="一个有意思的前端工程师"><meta name=author content="桃翁"><link rel=canonical href=/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.355db47b48ce042e543348876cce64165399cee8651ce7514d3c4b076b02f0aa.css integrity="sha256-NV20e0jOBC5UM0iHbM5kFlOZzuhlHOdRTTxLB2sC8Ko=" rel="preload stylesheet" as=style><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="函数式编程"><meta property="og:description" content="一个有意思的前端工程师"><meta property="og:type" content="website"><meta property="og:url" content="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="桃园"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="函数式编程"><meta name=twitter:description content="一个有意思的前端工程师"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/archives/ title=Archives><span>Archives</span></a></li><li><a href=/categories/ title=Categories><span>Categories</span></a></li><li><a href=search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/tags/>Tags</a></div><h1>函数式编程
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>函数式编程里面的基本工具函数实现</h2></header><div class=entry-content><p>compose 实现 function compose(...args) { return (result) => { return args.reduceRight((result, fn) => { return fn(result) }, result) } } pipe 实现 function compose(...args) { return (result) => { return args.reduce((result, fn) => { return fn(result) }, result) } } 柯里化实现 function currying(fn, ...args) { if (args.length >= fn.length) { return fn(...args) } return function (...args2) { return currying(fn, ...args, ...args2) } } 部分应用实现 function partial(fn, ...args) { return (..._arg) => { return fn(....</p></div><footer class=entry-footer><span title='2019-01-09 13:12:00 +0000 UTC'>January 9, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;77 words&nbsp;·&nbsp;桃翁</footer><a class=entry-link aria-label="post link to 函数式编程里面的基本工具函数实现" href=/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/218/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>函数式编程笔记</h2></header><div class=entry-content><p>过去编程方式主要是以命令式编程为主，什么意思呢？简单说电脑的思维方式和我们人类的思考方式是不一样的。我们人类的大脑擅长的是分析问题，提出一个解决问题的方案，电脑则是生硬的执行指令，命令式编程就像是给电脑下达命令，让电脑去执行一样，现在主要的编程语言（比如：Java，C，C++等）都是由命令式编程构建起来的。 ​ 而函数式编程就不一样了，这是模仿我们人类的思维方式发明出来的。例如：操作某个数组的每一个元素然后返回一个新数组，如果是计算机的思考方式，会这样想：创建一个新数组=>遍历旧数组=>给新数组赋值。如果是人类的思考方式，会这样想：创建一个数组方法，作用在旧数组上，返回新数组。这样此方法可以被重复利用。而这就是函数式编程了。
...</p></div><footer class=entry-footer><span title='2018-01-05 19:25:00 +0000 UTC'>January 5, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;88 words&nbsp;·&nbsp;桃翁</footer><a class=entry-link aria-label="post link to 函数式编程笔记" href=/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/18/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>函数式编程之组合</h2></header><div class=entry-content><p>该系列文章不是针对前端新手，需要有一定的编程经验，而且了解 JavaScript 里面作用域，闭包等概念
组合函数 组合是一种为软件的行为，进行清晰建模的一种简单、优雅而富于表现力的方式。通过组合小的、确定性的函数，来创建更大的软件组件和功能的过程，会生成更容易组织、理解、调试、扩展、测试和维护的软件。
对于组合，我觉得是函数式编程里面最精髓的地方之一，所以我迫不及待的把这个概念拿出来先介绍，因为在整个学习函数式编程里，所遇到的基本上都是以组合的方式来编写代码，这也是改变你从一个面向对象，或者结构化编程思想的一个关键点。
我这里也不去证明组合比继承好，也不说组合的方式写代码有多好，我希望你看了这篇文章能知道以组合的方式去抽象代码，这会扩展你的视野，在你想重构你的代码，或者想写出更易于维护的代码的时候，提供一种思路。
组合的概念是非常直观的，并不是函数式编程独有的，在我们生活中或者前端开发中处处可见。
比如我们现在流行的 SPA (单页面应用)，都会有组件的概念，为什么要有组件的概念呢，因为它的目的就是想让你把一些通用的功能或者元素组合抽象成可重用的组件，就算不通用，你在构建一个复杂页面的时候也可以拆分成一个个具有简单功能的组件，然后再组合成你满足各种需求的页面。
其实我们函数式编程里面的组合也是类似，函数组合就是一种将已被分解的简单任务组织成复杂的整体过程。
现在我们有这样一个需求：给你一个字符串，将这个字符串转化成大写，然后逆序。
你可能会这么写。
// 例 1.1 var str = 'function program' // 一行代码搞定 function oneLine(str) { var res = str.toUpperCase().split('').reverse().join('') return res; } // 或者 按要求一步一步来，先转成大写，然后逆序 function multiLine(str) { var upperStr = str.toUpperCase() var res = upperStr.split('').reverse().join('') return res; } console.log(oneLine(str)) // MARGORP NOITCNUF console.log(multiLine(str)) // MARGORP NOITCNUF 可能看到这里你并没有觉得有什么不对的，但是现在产品又突发奇想，改了下需求，把字符串大写之后，把每个字符拆开之后组装成一个数组，比如 ’aaa‘ 最终会变成 [A, A, A]。
那么这个时候我们就需要更改我们之前我们封装的函数。这就修改了以前封装的代码，其实在设计模式里面就是破坏了开闭原则。
那么我们如果把最开始的需求代码写成这个样子，以函数式编程的方式来写。
// 例 1....</p></div><footer class=entry-footer>4 min&nbsp;·&nbsp;789 words&nbsp;·&nbsp;桃翁</footer><a class=entry-link aria-label="post link to 函数式编程之组合" href=/posts/%E6%8A%80%E6%9C%AF/253/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>函数式编程资料</h2></header><div class=entry-content><p>Eric Elliott 函数式教程 征服 JavaScript 面试: 什么是函数式编程？ 组合软件：1. 函数式编程的兴衰 为什么用 JavaScript 学习函数式编程？（软件编写）（第二部分） 函数式程序员的 JavaScript 简介 (软件编写)（第三部分） 高阶函数（软件编写）（第四部分） Reduce（软件编写）（第五部分） Functor 与 Category （软件编写）（第六部分） 函数式 Mixin（软件编写）（第七部分） 为什么在使用了类之后会使得组合变得愈发困难（软件编写）（第九部分） 借助函数完成可组合的数据类型（软件编写）（第十部分） JavaScript 让 Monad 更简单（软件编写）（第十一部分） JavaScript 轻量级函数式编程 JavaScript 轻量级函数式编程
Starkwang.log JavaScript函数式编程（一）
JavaScript函数式编程（二）
JavaScript函数式编程（三）
如果你想成为函数式编程爱好者 如何成为一位函数式编程爱好者(Part 1) 如何成为一位函数式编程爱好者(Part 2) 如何成为一位函数式编程爱好者(Part 3) 如何成为一位函数式编程爱好者(Part 4) 如何成为一位函数式编程爱好者(Part 5) 如何成为一位函数式编程爱好者(Part 6) 书籍 《JavaScript 函数式编程指南》推荐 《JavaScript 函数式编程思想》推荐 《JavaScript ES6 函数式入门经典》看了上面两本这本就不用买了 《JavaScript 函数式编程》 相关库 https://folktale.origamitower.com/ https://github.com/fantasyland/fantasy-land http://ramda.cn/ http://lodash.think2011.net/</p></div><footer class=entry-footer>1 min&nbsp;·&nbsp;66 words&nbsp;·&nbsp;桃翁</footer><a class=entry-link aria-label="post link to 函数式编程资料" href=/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/197/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>认识函数式编程</h2></header><div class=entry-content><p>最开始接触函数式编程的时候是在小米工作的时候，那个时候看老大以前写的代码各种 compose，然后一些 ramda 的一些工具函数，看着很吃力，然后极力吐槽函数式编程，现在回想起来，那个时候的自己真的是见识短浅，只想说,‘真香’。
最近在研究函数式编程，真的是在学习的过程中感觉自己的思维提升了很多，抽象能力大大的提高了，让我深深的感受到了函数式编程的魅力。所以我打算后面用 5 到 8 篇的篇幅，详细的介绍一下函数式编程的思想，基础、如何设计、测试等。
今天这篇文章主要介绍函数式编程的思想。
函数式编程有用吗？ 什么是函数式编程？ 函数式编程的优点。 面向对象编程(OOP)通过封装变化使得代码更易理解。 函数式编程(FP)通过最小化变化使得代码更易理解。 – Michacel Feathers（Twitter）
总所周知 JavaScript 是一种拥有很多共享状态的动态语言，慢慢的，代码就会积累足够的复杂性，变得笨拙难以维护。面向对象设计能帮我们在一定程度上解决这个问题，但是还不够。
由于有很多的状态，所以处理数据流和变化的传递显得尤为重要，不知道你们知道响应式编程与否，这种编程范式有助于处理 JavaScript 的异步或者事件响应。总之，当我们在设计应用程序的时候，我们应该考虑是否遵守了以下的设计原则。
可扩展性–我是否需要不断地重构代码来支持额外的功能？ 易模块化–如果我更改了一个文件，另一个文件是否会受到影响？ 可重用性–是否有很多重复的代码？ 可测性–给这些函数添加单元测试是否让我纠结？ 易推理性–我写的代码是否非结构化严重并难以推理？ 我这能这么跟你说，一旦你学会了函数式编程，这些问题迎刃而解，本来函数式编程就是这个思想，一旦你掌握了函数式，然后你再学习响应式编程那就比较容易懂了，这是我亲身体会的。我之前在学 Rxjs 的时候是真的痛苦，说实话，Rxjs 是我学过最难的库了，没有之一。在经历过痛苦的一两个月之后，有些东西还是不能融会贯通，知道我最近研究函数式编程，才觉得是理所当然。毫无夸张，我也尽量在后面的文章中给大家介绍一下 Rxjs，这个话题我也在公司分享过。
什么是函数式编程？ 简单来说，函数式编程是一种强调以函数使用为主的软件开发风格。看到这句我想你还是一脸懵逼，不知道函数式编程是啥，不要着急，看到最后我相信你会明白的。
还有一点你要记住，函数式编程的目的是使用函数来抽象作用在数据之上的控制流和操作，从而在系统中消除副作用并减少对状态的改变。
下面我们通过例子来简单的演示一下函数式编程的魅力。
现在的需求就是输出在网页上输出 “Hello World”。
可能初学者会这么写。
document.querySelector('#msg').innerHTML = '&lt;h1>Hello World&lt;/h1>' 这个程序很简单，但是所有代码都是死的，不能重用，如果想改变消息的格式、内容等就需要重写整个表达式，所以可能有经验的前端开发者会这么写。
function printMessage(elementId, format, message) { document.querySelector(elementId).innerHTML = `&lt;${format}>${message}&lt;/${format}>` } printMessage('msg', 'h1', 'Hello World') 这样确实有所改进，但是任然不是一段可重用的代码，如果是要将文本写入文件，不是非 HTML，或者我想重复的显示 Hello World。
那么作为一个函数式开发者会怎么写这段代码呢？
const printMessage = compose(addToDom('msg'), h1, echo) printMessage('Hello World') 解释一下这段代码，其中的 h1 和 echo 都是函数，addToDom 很明显也能看出它是函数，那么我们为什么要写成这样呢？看起来多了很多函数一样。...</p></div><footer class=entry-footer>2 min&nbsp;·&nbsp;364 words&nbsp;·&nbsp;桃翁</footer><a class=entry-link aria-label="post link to 认识函数式编程" href=/posts/%E6%8A%80%E6%9C%AF/190/></a></article></main><footer class=footer><span>&copy; 2023 <a href>桃园</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>