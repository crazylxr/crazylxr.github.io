<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005-Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>react on 桃园</title>
    <link>/tags/react/</link>
    <description>Recent content in react on 桃园</description>
    <image>
      <title>桃园</title>
      <url>%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 09 Mar 2022 08:20:00 +0000</lastBuildDate><atom:link href="/tags/react/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用 React 和 TypeScript 编写干净代码的10个必知模式</title>
      <link>/posts/2022/03-09-%E4%BD%BF%E7%94%A8-react-%E5%92%8C-typescript-something-%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%BB%A3%E7%A0%81%E7%9A%8410%E4%B8%AA%E5%BF%85%E7%9F%A5%E6%A8%A1%E5%BC%8F-copy/</link>
      <pubDate>Wed, 09 Mar 2022 08:20:00 +0000</pubDate>
      
      <guid>/posts/2022/03-09-%E4%BD%BF%E7%94%A8-react-%E5%92%8C-typescript-something-%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%BB%A3%E7%A0%81%E7%9A%8410%E4%B8%AA%E5%BF%85%E7%9F%A5%E6%A8%A1%E5%BC%8F-copy/</guid>
      <description>React 是一个 JavaScript 库，它是当今最流行和行业领先的前端开发库。
JavaScript 是一种松散的类型化语言，因此，它捕获了运行时。这样做的结果就是 JavaScript 错误被捕获得非常晚，这可能导致严重的 bug。
当然 React 作为一个 JavaScript 库，也继承了这个问题。
干净代码(Clean code)是一种一致的编程风格，它使代码更容易编写、读取和维护。任何人都可以编写计算机可以理解的代码，但是优秀的开发人员可以编写人类可以理解的干净的代码。
干净的代码是一种以读者为中心的开发风格，它提高了我们的软件质量和可维护性。
编写干净代码需要编写具有清晰和简单的设计模式的代码，这使得人们可以轻松地阅读、测试和维护代码。因此，干净的代码可以降低软件开发的成本。这是因为编写干净的代码所涉及的原则，消除了技术债务。
在本文中，我们将介绍一些在使用 React 和 TypeScript 时使用的有用模式。
💡 为了让您的团队更容易地保持代码健康并优先处理技术债务工作，请尝试使用 Stepsize 的 VS Code 和 JetBrains 扩展。它们帮助工程师创建技术问题，将它们添加到迭代 中，并持续解决技术债务——而不离开编辑器。
现在让我们来了解一下在使用 React 和 Typescript 时应用的 10 个有用模式:
1. 使用默认导入来导入 React 考虑下面的代码:
import * as React from &amp;#34;react&amp;#34;; 虽然上面的代码可以工作，但是如果我们不使用 React 的所有内容，那么导入它们是令人困惑的，也不是一个好的做法。一个更好的模式是使用如下所示的默认导出:
import React, {useContext, useState} from &amp;#34;react&amp;#34;; 使用这种方法，我们可以从 React 模块中解构我们需要的东西，而不是导入所有的内容。
注意: 要使用这个选项，我们需要配置 tsconfig.json 文件，如下所示:
{ &amp;#34;compilerOptions&amp;#34;: { &amp;#34;esModuleInterop&amp;#34;: true&amp;#34; } } 在上面的代码中，通过将 esModuleInterop 设置为 true，我们启用了 allowSyntheticDefaultImports ，这对于 TypeScript 支持我们的语法非常重要。</description>
    </item>
    
    <item>
      <title>如何应用 SOLID 原则在 React 中整理代码之开闭原则</title>
      <link>/posts/%E8%AF%91%E6%96%87/336/</link>
      <pubDate>Mon, 24 May 2021 08:27:43 +0000</pubDate>
      
      <guid>/posts/%E8%AF%91%E6%96%87/336/</guid>
      <description>SOLID 是一套原则。它们主要是关心代码质量和可维护性的软件专业人员的指导方针。
React 不是面向对象，但这些原则背后的主要思想可能是有帮助的。在本文中，我将尝试演示如何应用这些原则来编写更好的代码。
在前一篇文章中，我们讨论了单一责任原则。今天，我们将讨论 SOLID 的第二个原则: 开闭原则。
本系列其他文章 如何应用 SOLID 原则在 React 中整理代码之单一原则 什么是开闭原则？ Robert c. Martin 认为这个原则是面向对象设计最重要的原则。但他不是第一个定义这个概念的人。Bertrand Meyer 于1988年在他的《面向对象软件构造》一书中写到了这一点。他解释了开放/封闭原则:
软件实体(类、模块、功能等)应该对扩展开放，但对修改关闭。
这个原则告诉您以这样一种方式来编写代码，即您能够在不更改现有代码的情况下添加其他功能。
让我们看看我们在哪里可以应用这个原则。
让我们从一个例子开始 假设我们有一个 User 组件，其中我们传递用户的详细信息，这个类的主要目的是显示该特定用户的详细信息。
这是一个很简单的开始。但是我们的生活并不是那么简单。几天后，我们的经理告诉我们系统中有三种类型的用户: SuperAdmin、 Admin 等等。
它们每个都有不同的信息和功能。
一个糟糕的解决方案 第一个也是显而易见的解决方案：在组件中包含一个条件，并根据不同的用户类型呈现不同的信息。
import React from &amp;#39;react&amp;#39;; export const User = ({user}) =&amp;gt; { return &amp;lt;&amp;gt; &amp;lt;div&amp;gt; Name: {user.name}&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; Email: {user.email}&amp;lt;/div&amp;gt; { user.type === &amp;#39;SUPER_ADMIN&amp;#39; &amp;amp;&amp;amp; &amp;lt;div&amp;gt; Details about super admin&amp;lt;/div&amp;gt; } { user.type === &amp;#39;ADMIN&amp;#39; &amp;amp;&amp;amp; &amp;lt;div&amp;gt; Details about admin&amp;lt;/div&amp;gt; } &amp;lt;/&amp;gt; } 你知道这里出了什么问题吗？</description>
    </item>
    
    <item>
      <title>React 代码规范</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/314/</link>
      <pubDate>Thu, 02 Apr 2020 16:51:22 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/314/</guid>
      <description>基本规范 每个文件只包含的一个 React 组件： 联系紧密的组件可以使用「命名空间」的形式； 每个文件中可包含多个纯函数组件。 始终使用 JSX 语法，不要使用 React.createElement 创建 ReactElement，以提高编写速度、可读性、可维护性（没有 JSX 转换的特殊场景例外，如在 console 中测试组件）。 文件规范 组件文件使用一致的.js或 .jsx后缀。所有组件文件的后缀名从.js或.jsx中任选其一。不应在项目中出现部分组件为.js文件，部分为.jsx的情况。
每个存放组件的目录使用一个index.js/index.jsx以命名导出的形式暴露所有组件。同目录内的组件相互引用使用import Foo from &#39;./Foo&#39;;进行。引用其它目录的组件使用import {Foo} from &#39;../component&#39;;进行。
命名规范 文件名：使用大驼峰命名法（PascalCase），如 MyComponent.jsx；
组件命名：组件名称和文件名一致，如 MyComponent.jsx 里的组件名应该是 MyComponent；一个目录的根组件使用 index.jsx 命名，以目录名称作为组件名称；
引用命名：React 组件使用大驼峰命名法（PascalCase）；
高阶组件使用camelCase命名。高阶组件事实上并非一个组件，而是一个“生成组件类型”的函数，因此遵守JavaScript函数命名的规范，使用camelCase命名。
使用onXxx形式作为props中用于回调的属性名称。使用统一的命名规则用以区分props中回调和非回调部分的属性，在JSX上可以清晰地看到一个组件向上和向下的逻辑交互。
使用withXxx或xxxable形式的词作为高阶组件的名称。高阶组件是为组件添加行为和功能的函数，因此使用如上形式的词有助于对其功能进行理解。
带命名空间的组件 如果一个组件有许多关联子组件，可以以该组件作为命名空间编写、调用子组件。 class Form extends React.Component { // ... } class Row extends React.Component {} class Label extends React.Component {} class Input extends React.Component {} Form.Row = Row; Form.Label = Label; Form.</description>
    </item>
    
    <item>
      <title>你可能不知道的 React Hooks</title>
      <link>/posts/%E8%AF%91%E6%96%87/296/</link>
      <pubDate>Tue, 07 Jan 2020 21:50:00 +0000</pubDate>
      
      <guid>/posts/%E8%AF%91%E6%96%87/296/</guid>
      <description>本文是译文，原文地址是：https://medium.com/@sdolidze/the-iceberg-of-react-hooks-af0b588f43fb
React Hooks 与类组件不同，它提供了用于优化和组合应用程序的简单方式，并且使用了最少的样板文件。
如果没有深入的知识，由于微妙的 bug 和抽象层漏洞，可能会出现性能问题，代码复杂性也会增加。
我已经创建了12个案例研究来演示常见的问题以及解决它们的方法。 我还编写了 React Hooks Radar 和 React Hooks Checklist，来推荐和快速参考。
案例研究： 实现 Interval 目标是实现计数器，从 0 开始，每 500 毫秒增加一次。 应提供三个控制按钮: 启动、停止和清除。
Level 0：Hello World export default function Level00() { console.log(&amp;#39;renderLevel00&amp;#39;); const [count, setCount] = useState(0); return ( &amp;lt;div&amp;gt; count =&amp;gt; {count} &amp;lt;button onClick={() =&amp;gt; setCount(count + 1)}&amp;gt;+&amp;lt;/button&amp;gt; &amp;lt;button onClick={() =&amp;gt; setCount(count - 1)}&amp;gt;-&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); } 这是一个简单的、正确实现的计数器，用户单击时计数器的增加或减少。
Level 1：setInterval export default function Level01() { console.</description>
    </item>
    
    <item>
      <title>如何对 React 函数式组件进行优化</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/280/</link>
      <pubDate>Tue, 19 Nov 2019 08:32:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/280/</guid>
      <description>前言 目的 本文只介绍函数式组件特有的性能优化方式，类组件和函数式组件都有的不介绍，比如 key 的使用。另外本文不详细的介绍 API 的使用，后面也许会写，其实想用好 hooks 还是蛮难的。
面向读者 有过 React 函数式组件的实践，并且对 hooks 有过实践，对 useState、useCallback、useMemo API 至少看过文档，如果你有过对类组件的性能优化经历，那么这篇文章会让你有种熟悉的感觉。
React 性能优化思路 我觉得React 性能优化的理念的主要方向就是这两个：
减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconction(简单的可以理解为 diff)，如果不 render，就不会 reconction。
减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。
在使用类组件的时候，使用的 React 优化 API 主要是：shouldComponentUpdate 和 PureComponent，这两个 API 所提供的解决思路都是为了减少重新 render 的次数，主要是减少父组件更新而子组件也更新的情况，虽然也可以在 state 更新的时候阻止当前组件渲染，如果要这么做的话，证明你这个属性不适合作为 state，而应该作为静态属性或者放在 class 外面作为一个简单的变量 。
但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？
React.memo 首先要介绍的就是 React.memo，这个 API 可以说是对标类组件里面的 PureComponent，这是可以减少重新 render 的次数的。
可能产生性能问题的例子 举个例子，首先我们看两段代码：
在根目录有一个 index.js，代码如下，实现的东西大概就是：上面一个 title，中间一个 button(点击 button 修改 title)，下面一个木偶组件，传递一个 name 进去。</description>
    </item>
    
    <item>
      <title>如何让 useEffect 只在依赖变化的时候执行</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/271/</link>
      <pubDate>Mon, 14 Oct 2019 21:51:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/271/</guid>
      <description>遇到问题 今天遇到一个 useEffect 的问题，遇到一个问题：在 useEffect 里面发异步请求，然后第二个参数的依赖也是异步请求之后得到的结果，然后就导致最终结果会请求两次 useEffect 里的函数。
const [metaKey, setMetaKey] = useState&amp;lt;string[]&amp;gt;([]) // useEffect1 useEffect(() =&amp;gt; { getServiceCoreIndexParam().then((res: IResult) =&amp;gt; { setMetaKey(res.data.defaultValue) return res.data }) }, []) // useEffect2 useEffect(() =&amp;gt; { getAdvisorIndexTable({ visitdate: props.visitdate, advisorSupervisor: props.advisorSupervisor, comparevisitdate: props.comparevisitdate, metaKeys: metaKey || [] }).then((res: IResult) =&amp;gt; { res.success &amp;amp;&amp;amp; setTable(res.data) }) }, [props.visitdate, props.advisorSupervisor, metaKey, props.comparevisitdate]) 分析一下这段代码，首先在组件 mount 的时候，useEffect2 会调用一次 getAdvisorIndexTable，当 useEffect1 执行完毕之后 setMetaKey 后，由于 metaKey 发生改变，导致 getAdvisorIndexTable 还会调用一次，这很明显是我们不想看到的结果，因为这只是一个默认请求，然而发了两次请求。</description>
    </item>
    
    <item>
      <title>新手学习 React 迷惑的点</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/257/</link>
      <pubDate>Thu, 05 Sep 2019 21:37:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/257/</guid>
      <description>网上各种言论说 React 上手比 Vue 难，可能难就难不能深刻理解 JSX，或者对 ES6 的一些特性理解得不够深刻，导致觉得有些点难以理解，然后说 React 比较难上手，还反人类啥的，所以我打算写两篇文章来讲新手学习 React 的时候容易迷惑的点写出来，如果你还以其他的对于学习 React 很迷惑的点，可以在留言区里给我留言。
为什么要引入 React 在写 React 的时候，你可能会写类似这样的代码：
import React from &amp;#39;react&amp;#39; function A() { // ...other code return &amp;lt;h1&amp;gt;前端桃园&amp;lt;/h1&amp;gt; } 你肯定疑惑过，下面的代码都没有用到 React，为什么要引入 React 呢？
如果你把 import React from ‘react’ 删掉，还会报下面这样的错误：
那么究竟是哪里用到了这个 React，导致我们引入 React 会报错呢，不懂这个原因，那么就是 JSX 没有搞得太明白。
你可以讲上面的代码(忽略导入语句)放到在线 babel 里进行转化一下，发现 babel 会把上面的代码转化成:
function A() { // ...other code return React.createElement(&amp;#34;h1&amp;#34;, null, &amp;#34;前端桃园&amp;#34;); } 因为从本质上讲，JSX 只是为 React.createElement(component, props, ...children) 函数提供的语法糖。</description>
    </item>
    
    <item>
      <title>Deep In React 之详谈 React 16 Diff 策略(二)</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/261/</link>
      <pubDate>Tue, 30 Jul 2019 21:42:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/261/</guid>
      <description>文章首发于个人博客
这是我 Deep In React 系列的第二篇文章，如果还没有读过的强烈建议你先读第一篇：详谈 React Fiber 架构(1)。
前言 我相信在看这篇文章的读者一般都已经了解过 React 16 以前的 Diff 算法了，这个算法也算是 React 跨时代或者说最有影响力的一点了，使 React 在保持了可维护性的基础上性能大大的提高，但 Diff 过程不仅不是免费的，而且对性能影响很大，有时候更新页面的时候往往 Diff 所花的时间 js 运行时间比 Rendering 和 Painting 花费更多的时间，所以我一直传达的观念是 React 或者说框架的意义是为了提高代码的可维护性，而不是为了提高性能的，现在所做的提升性能的操作，只是在可维护性的基础上对性能的优化。具体可以参考我公众号以前发的这两篇文章：
别再说虚拟 DOM 快了，要被打脸的
深入理解虚拟 DOM，它真的不快
如果你对标题不满意，请把文章看完，至少也得把文章最后的结论好好看下
在上一篇将 React Fiber 架构中，已经说到过，React 现在将整体的数据结构从树改为了链表结构。所以相应的 Diff 算法也得改变，以为以前的 Diff 算法就是基于树的。
老的 Diff 算法提出了三个策略来保证整体界面构建的性能，具体是：
Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。 基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化。
具体老的算法可以见这篇文章：React 源码剖析系列 － 不可思议的 react diff</description>
    </item>
    
    <item>
      <title>发布 react 组件到 npm 上</title>
      <link>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/235/</link>
      <pubDate>Mon, 28 Jan 2019 15:43:00 +0000</pubDate>
      
      <guid>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/235/</guid>
      <description>我发布了我的第一个 npm 组件，一个基于 react 的 3d 标签云组件。在这途中我也是遇到了很多的坑，花在完善整个发布流程的时间远多于写这个组件本身的时间，所以我记录下我觉得一个正常的 react 组件的发布流程
最后记录这篇文章花的时间比我完成整个组件的时间都多，最终希望能给新手带来帮助
在整个发布组件的过程我做了如下几件事儿：
开发组件 编写 Readme 推送到 github，并且把 demo 放到 github page 上 发布组件到 npm 上 开发组件 创建项目文件夹并初始化 npm package ，确保你创建的组件名称没有在 npm 上被使用过， 这里我们用 react-demo 作为示例
mkdir react-demo cd react-demo npm init npm init 是生成初始的 package.json 的命令，在 npm init 的时候，你可以根据你自己的需要进行填写你的组件信息。或者直接使用 npm init -y 采用默认的，后面自己再去修改。
首先安装 react 相关的包：
npm i react react-dom -D 采用 babel 编译相关的依赖：
npm i @babel/cli @babel/core @babel/preset-env @babel/preset-react -D 采用 webpack 做构建，webpack-dev-server 作为本地开发服务器，所以需要安装如下依赖：</description>
    </item>
    
    <item>
      <title>不要再说虚拟 DOM 有多快了</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/124/</link>
      <pubDate>Tue, 20 Nov 2018 12:03:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/124/</guid>
      <description>如果你觉得它很快，那么这篇文章可能就是你所缺少的
我经常听到有人在群里，或者在社区里说的一个很严重的错误，那就是说 React 的 Virtual Dom 是以快出名的，比原生 Dom 快多了，啥啥啥的，每次都一两句话说不清楚，所以下次有谁再说 React 是以快出名的，你就把这篇文章丢给他，下面进入正题。
在过去的几年里，你一直在跟踪 JavaScript 社区的发展，你至少听说过 Virtual DOM（React，Vue.js 2，Riot.js，Angular 2等等）。他们承诺（或者更确切地说，他们的宣传）更快的渲染界面，特别是更新，减少麻烦。你很快的上手了使用虚拟DOM的应用程序，这很好。几个月后，您的应用程序现在变得越来越复杂，你可能从用户交互到屏幕更新只需要一两秒钟的更新。你可能会想，这东西很神奇，应该会比 jQuery 快，但是实际上不是这个样子的。
虽然我同意虚拟 DOM 为我们提供了很多便利，但我将解释为什么我认为根据定义，更快的渲染和更快的更新是不正确的。要付出代价，其利益并不是大多数人想象或至少希望的。
要阅读本文，您需要熟悉DOM。理想情况下，您至少可以使用 DOM API。如果你只使用 DOM API 构建东西，你可能不需要这篇文章，但我仍然希望你阅读它并在评论中留下一点评语。
渲染和更新 让我们来看看手动执行 DOM 节点的创建和更新的鸟瞰图。这对于理解虚拟DOM如何工作以及它解决了哪些问题非常重要。
在谈论 JavaScript Web 应用程序时，用户界面的更改通过 DOM 操作发生。这个过程分为两个阶段：
JS 部分：定义 JavaScript 世界中的变化 DOM 部分：使用 DOM API 函数和属性执行更改 性能是根据整个过程的速度来衡量的，但了解每部分的速度也很重要，以便了解要优化的内容。
有两种方法可以创建和更新DOM树的各个部分。
①字符串方式创建
使用字符串既快速又简单，但在更新方面并不是非常精细。对于字符串，JS部分是它如此之快的原因。您可以在几毫秒内创建一段代表5000个节点的HTML。这是一个例子：
const userList = document.getElementById(&amp;#34;user-list&amp;#34;); // JS 部分 const html = users.map(function (user) { return ` &amp;lt;div id=&amp;#34;${user.id}&amp;#34; class=”user”&amp;gt; &amp;lt;h2 class=&amp;#34;header&amp;#34;&amp;gt;${user.</description>
    </item>
    
    <item>
      <title>桃园周刊 2018-5-14</title>
      <link>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/87/</link>
      <pubDate>Mon, 14 May 2018 14:25:07 +0000</pubDate>
      
      <guid>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/87/</guid>
      <description>如何更好的编写 async 函数 虽然 async/await 方式来处理异步请求，已经是比较非常好的方式了，但是有时候新手会乱用导致性能堪忧，这篇文章作者总结了他在项目迁移中更好的编写 aysnc 函数的方法。
实现双向绑定 Proxy 比 defineproperty 优劣如何? 双向绑定其实已经是一个老掉牙的问题了,只要涉及到 MVVM 框架就不得不谈的知识点。
可以实现双向绑定的方法有很多, KnockoutJS 基于观察者模式的双向绑定, Ember 基于数据模型的双向绑定, Angular 基于脏检查的双向绑定,本篇文章我们重点讲面试中常见的基于数据劫持的双向绑定。
深度剖析：如何实现一个 Virtual DOM 算法 本文会在教你怎么用 300~400 行代码实现一个基本的 Virtual DOM 算法，并且尝试尽量把 Virtual DOM 的算法思路阐述清楚。希望在阅读本文后，能让你深入理解 Virtual DOM 算法，给你现有前端的编程提供一些新的思考。</description>
    </item>
    
    <item>
      <title>桃园周刊 2018-5-5</title>
      <link>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/74/</link>
      <pubDate>Sat, 05 May 2018 19:18:00 +0000</pubDate>
      
      <guid>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/74/</guid>
      <description>### Mvvm 前端数据流框架精讲 带大家了解什么是 mvvm，mvvm 的原理，以及近几年产生了哪些演变。
同时借 mvvm 这个话题拓展到对各类前端数据流方案的思考，形成对前端数据流整体认知，帮助大家在团队中更好的做技术选型。
译-RxJS 游戏之贪吃蛇 众所周知，Web 发展的很快。如今，响应式编程和 Angular 或 React 这样的框架一样，已经是 Web 开发领域中最热门的话题之一。响应式编程变得越来越流行，尤其是在当今的 JavaScript 世界。从命令式编程范式到响应式编程范式，社区已经发生了巨大的变化。然而，许多开发者还是十分纠结，常常因为响应式编程的复杂度(大量 API)、思维转换(从命令式到响应式)和众多概念而畏缩。
该应用使用 HTML5、JavaScript 和 RxJS 来将编程事件循环 (programmatic-event-loop) 的应用转变成响应事件驱动 (reactive-event-driven) 的应用。
前端性能优化之浏览器渲染优化 —— 打造60FPS页面 该文仅针对高性能渲染进行分析。详细的讲解了 CSS 优化 和 Javascript 的优化，一篇非常深入的文章</description>
    </item>
    
    <item>
      <title>一个例子来谈react的两大优势</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/20/</link>
      <pubDate>Fri, 05 Jan 2018 20:12:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/20/</guid>
      <description>&lt;p&gt;今天我想谈的react的优势有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明式写法更符合人性&lt;/li&gt;
&lt;li&gt;减少dom操作使性能得以提升&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在我们就写一个最简单的计数例子来比较传统的jquery和react。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2020 年你应该知道的 React 库</title>
      <link>/posts/%E8%AF%91%E6%96%87/300/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E8%AF%91%E6%96%87/300/</guid>
      <description>声明：本文为译文，原文链接：https://www.robinwieruch.de/react-libraries
React 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经习惯了框架包含了所需要的所有功能，
然而对于 React 来说，它的核心并不是完善所有的可选库。 这是优势还是劣势取决于你自己。 当我从 Angular 切换到 React，我绝对经历了它作为 React 的优势。
只有通过 React，您才能使用函数组件和 props 构建组件驱动的用户界面。 它带有一些内置的解决方案，例如，用于本地状态和副作用的 React Hooks。
下面的文章将向您提供一些自己总结的方法，以便从补充库中进行选择，从而构建一个全面的 React 应用程序。
如何开始 React 如果你是一个完全不熟悉 React 的初学者想创建一个 React 项目，加入 React 的世界。有许多工具包项目可以选择，每个项目都试图满足不同的需求。 React 社区的现状是通过 Facebook 的 create-react-app(CRA)。 它提供了一个零配置的设置，并给你一个开箱即用并且简单的启动和运行的 React 应用程序。 所有的工具都对您隐藏起来了，但是最终要由您来更改这些工具。
如果你已经熟悉 React，你可以选择它流行的入门工具包之一: Next.js 和 Gatsby.js。 这两个框架都建立在 React 之上，因此你应该已经熟悉 React 的基本原理。 Next.js 用于服务器端渲染(如动态 web 应用程序) ，Gatsby.js 用于静态站点生成(如博客、登陆页面)。
如果您只是想了解这些初学者工具包是如何工作的，那么可以尝试从头开始设置 React 项目。 你将从一个基本的 HTML 和 JavaScript 项目开始，然后自己添加 React 和它的支持工具。</description>
    </item>
    
    <item>
      <title>Deep In React 之浅谈 React Fiber 架构（一）</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/262/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/262/</guid>
      <description>文章首发于个人博客
前言 2016 年都已经透露出来的概念，这都 9102 年了，我才开始写 Fiber 的文章，表示惭愧呀。不过现在好的是关于 Fiber 的资料已经很丰富了，在写文章的时候参考资料比较多，比较容易深刻的理解。
React 作为我最喜欢的框架，没有之一，我愿意花很多时间来好好的学习他，我发现对于学习一门框架会有四种感受，刚开始没使用过，可能有一种很神奇的感觉；然后接触了，遇到了不熟悉的语法，感觉这是什么垃圾东西，这不是反人类么；然后当你熟悉了之后，真香，设计得挺好的，这个时候它已经改变了你编程的思维方式了；再到后来，看过他的源码，理解他的设计之后，设计得确实好，感觉自己也能写一个的样子。
所以我今年(对，没错，就是一年)就是想完全的学透 React，所以开了一个 Deep In React 的系列，把一些新手在使用 API 的时候不知道为什么的点，以及一些为什么有些东西要这么设计写出来，与大家共同探讨 React 的奥秘。
我的思路是自上而下的介绍，先理解整体的 Fiber 架构，然后再细挖每一个点，所以这篇文章主要是谈 Fiber 架构的。
介绍 在详细介绍 Fiber 之前，先了解一下 Fiber 是什么，以及为什么 React 团队要话两年时间重构协调算法。
React 的核心思想 内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中。
React 16 之前的不足 首先我们了解一下 React 的工作过程，当我们通过render() 和 setState() 进行组件渲染和更新的时候，React 主要有两个阶段：
调和阶段(Reconciler)：官方解释。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。
渲染阶段(Renderer)：遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。</description>
    </item>
    
    <item>
      <title>前端桃园周刊第五期</title>
      <link>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/292/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/292/</guid>
      <description>文章 1. Thinking in React Hooks 当从 React 类组件切换到函数组件 + hook 时，基本的思维模式发生了什么变化。
2. Ant Design 1.0 背后的故事：把艺术变成技术 我以前一直不喜欢读历史，今年了解吴军老师比较多，听他的硅谷来信，看他的书：《浪潮之巅》、《文明之光》才决定历史背景原来那么重要，了解历史你会发现现在很多的东西都是必然会出现的。 Ant Desgin 这么伟大的东西，了解一个产品背后的故事，我觉得还是很有必要的，看看为什么别人能做出伟大的东西，而我们不能。
3. 前端API层架构，也许你做得还不够 架构设计是一条永远走不完的路，没有最好，只有更好。这个道理适用于软件设计的各个场景，前端API 层的设计也不例外，如果您觉得在调用接口时还存在诸多槽点，那就说明您的接口层架构还待优化。作者以 vue + axios 为例，为大家梳理下我的一些经历和设想。
4. 你的 Mac 用对了吗？推荐一些 Mac 上比较好用的软件 这些 mac 软件都挺好用的，强烈推荐。
5. 再谈编程范式—程序语言背后的思想 详细讲述了命令式、过程式、说明式、面向对象、函数式、泛型编程各个编程范式的特性。
6. 少讲大道理，多解决小问题 二爷这篇文章以很多亲身体验的例子来阐述了多做事，少废话的道理，非常值得一读。
挖宝 1. vscode 字体 fira code 一款为程序员专属的字体。
2. 大四学生开源文言文编程语言 这一项目并不是简单的将程序中的英文字符换成了中文，而是利用 NLP 的一些技术，将文言文程序语法转换到 JavaScript 或 Python 运行，有一定的技术难度。
如果读者想快速试一试，你也可以玩一玩在线 IDE，上面有很多预定义的函数。即使在手机上，我们也能编辑并运行「文言文代码」。
3. lutaonan.com 一款很简洁的博客，文章阅读页的样式准备参考他的。
4. 方凳雅集 方凳雅集是阿里B系前端技术团队的专属公众号，内容来自1688、阿里巴巴国际站、零售通、AliExpress、企业金融、考拉等多个BU的前端团队，涵盖阿里原创技术、精彩翻译和公司文化、职业成长等内容。
最近关注到的质量比较高的前端公众号了，不过不太适合初级工程师，文章话题一般比较高大上，都是他们团队内部的一些解决方案，而不是基础知识。
5. 第十四届D2前端技术论坛「创心」 12 月 14 日，第十四届 D2 前端技术论坛在杭州圆满举办。来自全国各地的近千名开发者齐聚杭州，聆听 3 大会场、来自 24 位海内外嘉宾的 21 个主题分享。</description>
    </item>
    
    <item>
      <title>前端桃园周刊第六期</title>
      <link>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/294/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/294/</guid>
      <description>小知识 伪类before/after中的图片大小是不是不能设置的? 文章 编写组件的 10 个原则 一篇英文文章，之前面试被面到过设计组件的时候要注意哪些，当时我大脑空白，根本答不出来，看了这篇文章之后，也许知道怎么答了。
深入解析ES Module（二）：彻底禁用default export 文章介绍了 export default object 这种方式所带来的问题，主要是在转换的时候不兼容 cjs，当然这篇文章也有助于更深刻的理解 ES Module。
「圣诞特辑」纯前端实现人脸识别自动佩戴圣诞帽 通过使用 TensorFlow.js 来进行人脸识别，然后自动佩戴圣诞帽，我最近也在学习机器学习相关的，当然也绕不开 TensorFlow.js ，学完课程之后再来看这篇文章。
那些你用错了的 React 生命周期 这篇文章的中心思想跟我之前在 React 官方博客里面看到那篇「你也许不需要派生 State」基本类似，主要是 componentWillReceiveProps 和getDerivedStateFromProps 这两个声明周期可能会写成反模式。
独家 | 阿里张勇湖畔分享：领导者如何“落子无悔” 张勇的演讲全文，看到很多大佬推荐这篇文章，先 mark 一波。</description>
    </item>
    
    <item>
      <title>前端桃园周刊第四期</title>
      <link>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/289/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/289/</guid>
      <description>一句话知识 npm v packageName versions npm v packageName versions 查看包的所有版本，不加s 获取新版本。用途，安装了包但是 package.json 里面没有包，需要手动填入的时候。
typeof null 为什么返回 &amp;ldquo;object&amp;rdquo;？ 不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。
in 和 hasOwnProperty 区别 in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。相比之下， hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。
for in 和 for of 的区别 for in 用于对象的遍历，会遍历原型上可以枚举的属性
for of 用于遍历可迭代的对象，比如数组，因为数组里面是有迭代器的，凡是有迭代器的对象都可以用 for of 来遍历
对 constructor 的误解 对象的 constructor 实际上不是对象创建的时候有的，而是通过委托到 prototype 上找的。
function Foo() { /* .</description>
    </item>
    
    <item>
      <title>根据 React 历史来聊如何理解虚拟 DOM</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/293/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/293/</guid>
      <description>最近我发现很多面试题里面都有「如何理解虚拟 DOM」这个题，我觉得这个题应该没有想象中那么好答，因为很多人没有真正理解虚拟 DOM 它的价值所在，我这篇从虚拟 DOM 的诞生过程来引出它的价值以及历史地位，帮助你深入的理解它。
什么是虚拟DOM 本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述。
对，就是这么简单！
就是一个复杂一点的对象而已，没什么好说的，重点是为什么要有这个东西，以及有了这个描述有什么好处才是我们今天要介绍的内容。
为什么要有虚拟DOM 再谈为什么要用虚拟 DOM 之前，先来聊一聊 React 是怎么诞生的，毕竟在了解历史背景，再去思考他的诞生，就知道是必然会出现的。
再查了很多关于 React 的历史相关的文章，这篇文章我感觉比较值得令我信服：React 是怎样炼成的。
众所周知，Facebook 是 PHP 大户，所以 React 最开始的灵感就来至于 PHP。
字符串拼接时代 - 2004 在 2004 年这个时候，大家都还在用 PHP 的字符串拼接来开发网站：
$str = &amp;#39;&amp;lt;ul&amp;gt;&amp;#39;; foreach ($talks as $talk) { $str += &amp;#39;&amp;lt;li&amp;gt;&amp;#39; . $talk-&amp;gt;name . &amp;#39;&amp;lt;/li&amp;gt;&amp;#39;; } $str += &amp;#39;&amp;lt;/ul&amp;gt;&amp;#39;; 这种方式代码写出来不好看不说，还容易造成 XSS 等安全问题。
应对方法是对用户的任何输入都进行转义（Escape）。但是如果对字符串进行多次转义，那么反转义的次数也必须是相同的，否则会无法得到原内容。如果又不小心把 HTML 标签（Markup）给转义了，那么 HTML 标签会直接显示给用户，从而导致很差的用户体验。
XHP 时代 - 2010 到了 2010 年，为了更加高效的编码，同时也避免转义 HTML 标签的错误，Facebook 开发了 XHP 。XHP 是对 PHP 的语法拓展，它允许开发者直接在 PHP 中使用 HTML 标签，而不再使用字符串。</description>
    </item>
    
  </channel>
</rss>
