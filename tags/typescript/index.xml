<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005-Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>typescript on ExampleSite</title>
    <link>https://examplesite.com/tags/typescript/</link>
    <description>Recent content in typescript on ExampleSite</description>
    <image>
      <title>ExampleSite</title>
      <url>https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 09 Mar 2022 08:20:00 +0000</lastBuildDate><atom:link href="https://examplesite.com/tags/typescript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用 React 和 TypeScript 编写干净代码的10个必知模式</title>
      <link>https://examplesite.com/posts/2022/03-09-%E4%BD%BF%E7%94%A8-react-%E5%92%8C-typescript-something-%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%BB%A3%E7%A0%81%E7%9A%8410%E4%B8%AA%E5%BF%85%E7%9F%A5%E6%A8%A1%E5%BC%8F-copy/</link>
      <pubDate>Wed, 09 Mar 2022 08:20:00 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/2022/03-09-%E4%BD%BF%E7%94%A8-react-%E5%92%8C-typescript-something-%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%BB%A3%E7%A0%81%E7%9A%8410%E4%B8%AA%E5%BF%85%E7%9F%A5%E6%A8%A1%E5%BC%8F-copy/</guid>
      <description>React 是一个 JavaScript 库，它是当今最流行和行业领先的前端开发库。
JavaScript 是一种松散的类型化语言，因此，它捕获了运行时。这样做的结果就是 JavaScript 错误被捕获得非常晚，这可能导致严重的 bug。
当然 React 作为一个 JavaScript 库，也继承了这个问题。
干净代码(Clean code)是一种一致的编程风格，它使代码更容易编写、读取和维护。任何人都可以编写计算机可以理解的代码，但是优秀的开发人员可以编写人类可以理解的干净的代码。
干净的代码是一种以读者为中心的开发风格，它提高了我们的软件质量和可维护性。
编写干净代码需要编写具有清晰和简单的设计模式的代码，这使得人们可以轻松地阅读、测试和维护代码。因此，干净的代码可以降低软件开发的成本。这是因为编写干净的代码所涉及的原则，消除了技术债务。
在本文中，我们将介绍一些在使用 React 和 TypeScript 时使用的有用模式。
💡 为了让您的团队更容易地保持代码健康并优先处理技术债务工作，请尝试使用 Stepsize 的 VS Code 和 JetBrains 扩展。它们帮助工程师创建技术问题，将它们添加到迭代 中，并持续解决技术债务——而不离开编辑器。
现在让我们来了解一下在使用 React 和 Typescript 时应用的 10 个有用模式:
1. 使用默认导入来导入 React 考虑下面的代码:
import * as React from &amp;#34;react&amp;#34;; 虽然上面的代码可以工作，但是如果我们不使用 React 的所有内容，那么导入它们是令人困惑的，也不是一个好的做法。一个更好的模式是使用如下所示的默认导出:
import React, {useContext, useState} from &amp;#34;react&amp;#34;; 使用这种方法，我们可以从 React 模块中解构我们需要的东西，而不是导入所有的内容。
注意: 要使用这个选项，我们需要配置 tsconfig.json 文件，如下所示:
{ &amp;#34;compilerOptions&amp;#34;: { &amp;#34;esModuleInterop&amp;#34;: true&amp;#34; } } 在上面的代码中，通过将 esModuleInterop 设置为 true，我们启用了 allowSyntheticDefaultImports ，这对于 TypeScript 支持我们的语法非常重要。</description>
    </item>
    
    <item>
      <title>从两个角度看 Typescript 中的类型是什么?</title>
      <link>https://examplesite.com/posts/%E8%AF%91%E6%96%87/302/</link>
      <pubDate>Tue, 03 Mar 2020 10:09:33 +0000</pubDate>
      
      <guid>https://examplesite.com/posts/%E8%AF%91%E6%96%87/302/</guid>
      <description>0. 作者以及原文介绍 作者是 Dr. Axel Rauschmayer，号称”德国阮一峰“，本文原文来自于他的博客：https://2ality.com/2020-02/understanding-types-typescript.html，不熟悉他的可以关注一下他的博客。
1. 每个角度都从这三个问题来解释 以下三个问题对于理解类型是如何工作的非常重要，需要从这两个角度中的每一个角度来回答。
myVariable 的类型 MyType 意味着什么？ let myVariable: MyType = /*...*/; Sourcetype 可以分配给 TargetType 吗? let source: SourceType = /*...*/; let target: TargetType = source; TypeUnion 是如何从 Type1、 Type2 和 Type3 衍生而来的？ type TypeUnion = Type1 | Type2 | Type3; 2. 角度 1： 类型是一组值 从这个角度来看，类型是一组值：
如果 myVariable 具有 MyType 类型，这意味着可以分配给 myVariable 的所有值都必须是集合 MyType 的元素。
如果 Sourcetype 可以分配给 TargetType，那么 Sourcetype 是 TargetType 的子集。 因此，TargetType 也允许 SourceType 所允许的所有值。</description>
    </item>
    
  </channel>
</rss>
