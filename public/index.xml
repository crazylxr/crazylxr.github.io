<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005-Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>桃园</title>
    <link>/</link>
    <description>Recent content on 桃园</description>
    <image>
      <title>桃园</title>
      <url>%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 19 Feb 2023 20:24:26 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2023 关于图像互动技术前景思考</title>
      <link>/posts/2023/02-19-%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E4%BA%92%E5%8A%A8%E6%8A%80%E6%9C%AF%E5%89%8D%E6%99%AF%E6%80%9D%E8%80%83/</link>
      <pubDate>Sun, 19 Feb 2023 20:24:26 +0800</pubDate>
      
      <guid>/posts/2023/02-19-%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E4%BA%92%E5%8A%A8%E6%8A%80%E6%9C%AF%E5%89%8D%E6%99%AF%E6%80%9D%E8%80%83/</guid>
      <description>前言 很久没有在外部写文章，跟我的读者们交流了，一些知心一点的同事，也离职了。所以最近感觉有点缺外部的输入，还是想写点文章，跟各种各样的朋友交流一下。 熟悉我的人应该知道，去年参加了支付宝的五福的前端开发，主要负责的是 AI 年画。 年画里面其实是有很多图形互动技术，比如秒轮廓，让后让兔子动起来，然后整个过度动画到装饰页面，装饰页面对于贴纸相关的操作，里面其实用到了大量的图形互动技术，主要用的是蚂蚁的 2D 互动引擎 Tiny.js。
后面我会整理一下，把年画的一些方案公布出来，有兴趣的可以看一下。
在做五福之前，我从来没有接触互动技术，对于如何开发互动应用没有任何概念，另外像五福这种大促时间又紧，任务又重，压力十分之大。 还好跟我合作的 partner 是懂的，并且有互动技术大佬给我们当技术顾问，所以才能顺利的上线并取得了不错的效果。
工作内容发生变化 回到我自己今天写这篇文章的目的，主要是我的工作内容要发生变化了，以后要从一个传统前端要转向一个图形互动技术方向的前端了。 这意味着什么呢？
服务的用户从公司内部用户转向了公司外部的 C 端用户。 用户量更大，意味着要求就更高，挑战就更大，也容易出故障。 技术方向发生了分叉，得重新开始学，学习任务极大。 互动技术方向对于我来说几乎是从 0 开始学，前面几年的前端经验积累用处就没那么大了，对于 React、构建工具、微前端这样的知识未来就不会再花很多的时间去学习了。 需要从 0 开始学习互动技术方向的内容：图形学、WebGL、2D 引擎库、3D 引擎库等等，还得稍微补一些数学知识。这块从我目前的学习以及同事了解，学习内容非常的多，而且对专业要求极高，不亚于传统前端的技术栈。 变化的原因主要是组内对于互动技术这块需要更多的人才，今年这块的业务会更多，另外就是在五福里接触过之后，觉得这块还是比较有意思的，特别是搞 3D 的，比如今年的福气乐园，看来就比较高大上。 两者结合，今年就准备开始走这个方向了。 不过对于现在来说，换方向对于职业发展有一些风险的，我也是在思考过后才决定的。
前景思考 对于换职业方向，其实我觉得是一件很重要的事情，需要慎重，影响未来的发展，尽量还是朝着前景好的方向转。 我记一下我现在对这个方向的思考，如果你刚好准备换方向可以参考一下。
担心的 路会往专精方向走，需要接受找工作没那么多公司招这个岗位的情况。 目前每个互联网公司都会招传统写页面的前端，但是对于图像互动技术的前端的岗位需求会少很多。 门槛高相对较高、知识的广度和深度往往不限于前端。 比如需要掌握图形学、部分数学这样非常专业的知识，相对还是比较难一些。 工程化相对落后，开发体验相对较差。 这块的知识体系跟图形/游戏行业是紧密相连的，整体看仅前端范围内还是比其它场景更大的端和场景弱不少，包括应用场景、专业度、生产模式工作流啥的，都比较落后。 看好的 就是因为门槛高，才容易形成壁垒，不容易别替换(当然，反过来，也不容易替换别人，看自己怎么看待)。 在随着未来 AI 的发展，同事随着年龄变大，才不容易被年轻人或者 AI 替代。 看好未来人机交互的进步，甚至是变革。 主要看好两个方向 元宇宙 (不看好的朋友请保留意见)。现在国内腾讯(QQ 小窝)、阿里(淘宝人生、天猫二楼的 3D体验空间)、百度(希壤)、网易(网易瑶台)等都在布局这方面的，国外的更不用说了，Facebook 都直接改名为 meta 了。 人机交互变革。目前来看前端主要是负责电脑或者手机显示器和人进行交互，未来以后可能是 VR、AR 进行交互。 最后 通过上面的分析，主要是看好未来人机交互的进步，才选择了这个方向。就算以后这个方向发展得不好，有了这些基础知识还是可以往其他的方向，比如一些设计行业(家装设计)、可视化、游戏等行业进行发展。
最后如果你来选，你会怎么来选呢？欢迎留言说一下你的看法。</description>
    </item>
    
    <item>
      <title>有一种用户增长方案，叫不做“用户增长”</title>
      <link>/posts/2022/03-21-%E6%9C%89%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF%E6%96%B9%E6%A1%88%E5%8F%AB%E4%B8%8D%E5%81%9A%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF/</link>
      <pubDate>Mon, 21 Mar 2022 22:22:22 +0000</pubDate>
      
      <guid>/posts/2022/03-21-%E6%9C%89%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF%E6%96%B9%E6%A1%88%E5%8F%AB%E4%B8%8D%E5%81%9A%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF/</guid>
      <description>我自己最近由于组织架构的调整，调整到了做用户增长相关的业务，我才去了解了什么是用户增长，用户增长包含用户的获客、激活、留存、变现、推荐，然后知道用户增长是所以企业永远不会过时的话题。
因为所有的企业如果需要成长，一定需要伴随用户的增长，扩大规模。
然后我还想着在做用户增长相关的业务，想去深入学习一下，然后把自己的公众号当做产品来做用户增长。
由于产品在给我们讲业务的时候，主要讲的是拉新获客相关的，所以我的头脑的一直就把 拉新作为用户增长的全部了。但是实际上拉新只是用户增长的一个环节，还有很多环节都需要用户增长，今天重点聊拉新。
拉新是增长中的第一个要素，通过合理的拉新方式让用户知道一款产品并在使用找到产品提供的核心价值留下来，并在使用过程中对产品创造价值最终形成对产品在盈利上的供给。
可见拉新主要是让不太清楚这款产品的用户，知道他的价值，然后使用这款产品，基本上这样拉新就算成功了。后续这个用户继续不继续使用，那就是激活、留存要做的事情了。
常用的一些拉新方式就是找一些渠道打广告，公域的比如应用商店、抖音、快手、百度、小红书等；私域的比如公众号找博主，朋友圈；甚至有些还有线下地推的方式。
今天在读《华与华正道》看到一句话：把现有的客户服务好，远方的客户自己会来。
我发现自己悟了，懂得了一条新的渠道，而且靠谱，对用户增长后面的环节，比如激活、留存转化率都会更高。
我们思考这么一个道理，现有的客户服务好，怎么对拉新有帮助的。
服务好现有的客户，那么客户对身边的人有类似需求的，是不是可以带过来；社交电商就是基于此。 服务好现有的客户，自己的品牌口碑就会很好，当别人有类似需求的时候，找口碑好的产品，就会自己找上来。 这就是不做用户增长，也做到了用户增长。
要是服务不好现有的客户，为了维持现有的收益，可能就得不停的通过传统的方式拉新，传统方式拉新成本贼高，投广告啥的都是很花钱的。然后把钱花了很多去投广告，如果资金不充裕，没有多余的，那么现有的客户更服务不好，又要去拉新，恶性循环。
所以我觉得服务好现有的客户，是用户增长的基础，稳扎稳打，逐步扩张。
基于以上的思考，我觉得我未来的做公众号的方向就需要转向服务好现有的读者，不断的去尝试对现在的读者有价值，愿意看的内容，而不是为了维持现有的阅读量，通过各种渠道去拉新人。
另外我想到了我现在的公司，支付宝，在支付份额上最近几年被微信压得很惨，虽然我觉得支付宝被压得很惨的原因不是因为客户没有服务好，而是被微信的高频所压制。但是我还是觉得服务好现有的客户是比拉新更重要的，有没有办法把现在支付宝和微信重叠的用户，让他们都用支付宝，这如果都转过来了，已经够支付宝长久发展了。
如果支付宝的服务好到这部分微信高频用户的都用上了支付宝，难道对于新用户在选支付产品的时候还不用支付宝吗？
最后还是送给大家书中的一句话：
《大学》说：“物有本末，事有终始，知所先后，则近道矣！”现有客户是本，新客户是末；把现有客户服务好是先，新客户是后。所以我一看见谁着急没客户，要去拓展，我就觉得他是舍本求末。到处去开拓客户，是最低效的经营手段。想要客户，只会让你签下不平等条约，最后除了得到一个“客户”，剩下的全是损失。
不做「用户增长」的用户增长，才是最有效的用户增长。</description>
    </item>
    
    <item>
      <title>债券基金</title>
      <link>/posts/2022/03-19-%E5%80%BA%E5%88%B8%E5%9F%BA%E9%87%91/</link>
      <pubDate>Sat, 19 Mar 2022 22:55:22 +0000</pubDate>
      
      <guid>/posts/2022/03-19-%E5%80%BA%E5%88%B8%E5%9F%BA%E9%87%91/</guid>
      <description>债基是什么？ 债券型基金，就是主要投资债券的基金，规定基金资产80%以上要投资于债券，也可以有一小部分资金投资于股票市场、可转债、打新股等等。
债券基金分类 只做债券的，叫“纯债基金”；
做债券+打新股的叫“一级债基”；
做债券+打新股+炒股的叫“二级债基”。
主要投资可转债的叫“可转债基”。
债券基金是怎么赚钱的？ 1、利息收入
即债券持有到期所获得的票面利息收入。只要债券不出现兑付困难，持有至到期一般是不会出现亏损的。这个角度来看，长期债券基金的收益要高于短期债券基金。
2、价差收入
债券一般在银行间市场或沪深交易所交易，因流动性、市场利率、信用情况变化等，债券的价格是存在波动的。一般而言，利率上升，债券价格下降；利率下降，债券价格上升。因而根据债券二级市场价格变动，低买高卖可以赚取差价。
3、债券回购
这主要是通过回购业务将持有的债券质押进行融资，融得的资金又继续投入到债券市场，这就可以获得额外的杠杆收入。目前开放式基金杠杆比例不超过140%，封闭式基金以及定期开放式基金杠杆比例可以达200%。
4、股票投资收入
这主要说的是二级债券基金，
可以通过参与二级市场股票投资，增厚基金收益。
当然，这也要相应承担股票市场波动的风险。
债基什么情况会跌 第一， 国债收益率快速上行
因为国债利率大涨，那些求稳的大资金肯定会想配置更多国债，那么势必卖出一部分公司类债券。所以大多数债券遭到抛售，债券价格大跌，拖累债券基金净值下跌。
第二， 碰到债券违约
第 三 ，可转换债波动很大
可转换债券和一般债券不一样，除了本身有还本付息的债券属性外，还有转股的权利。那么如果正股上涨，可转换债券就会上涨。</description>
    </item>
    
    <item>
      <title>【面试系列一】如何回答如何理解重排和重绘</title>
      <link>/posts/2022/03-15-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/</link>
      <pubDate>Tue, 15 Mar 2022 22:14:22 +0000</pubDate>
      
      <guid>/posts/2022/03-15-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/</guid>
      <description>最近在面试的时候经常会问：如何理解重排和重绘？
我发现很多候选人都没有答道关键点上，感觉是在哪里看到过相关的文章，听起来零零散散，毫无逻辑。
错误示范 一般的面试过程就是这样的：
面试官：如何理解重排和重绘?
候选人：重排就是当页面的结构发生变化了，就会重排，比如改变变字体的大小，增删 DOM 元素这样的。重绘就是页面结构没有变化，只是外观变了，比如改了一下字体颜色、背景颜色这样的。就只会发生重绘。
当然他说的也没错，我也不能直接说他错，就继续引导
面试官：那重排和重绘有什么关系吗？
候选人：重排一定会导致重绘，重绘不一定会导致重排。
面试官：为什么呢？
候选人：因为重排结构发生变化了嘛，肯定会导致重绘。
我这时候表情就是这样：
如果你觉得上面的回答很真实，那下面的你确定得好好看看。
接下来一般我不会直接跳过，我会再问一下浏览器关键渲染路径引导一下。
如果不知道的话，我会再引导一下(这个时候其实基本已经放弃了)。
问一下你知道当浏览器加载到一个 HTML 会发生什么事情吗？
如果还是不知道的话，这下一题了。
如果知道关键渲染路径的，基本引导一下还是可以搞明白，如果不清楚的，肯定是理解不了重排和重绘的。
考点 这道题我一般考察两个点：
浏览器的关键渲染路径。如果答不到这上面，一般这个题就凉了。 性能优化，如果减少重绘和回流，当然这个点肯定也是要基于对 关键渲染路径 的理解（这点不是关键点）。 复习 复习的目的是为了知道考点是啥，简单的给大家复习一下，更详细的内容希望按我介绍的知识点(可以看我文末推荐的文章进行深入学习)，毕竟复习不是上课。
我们可以能知道，写了 HTML、CSS、JavaScript 就可以将页面渲染到屏幕上，但是浏览器是如何把我们的代码渲染到屏幕上的像素点的呢？这就需要了解到这么一个概念 CRP：
关键渲染路径(Critical Rendering Path)是浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列。优化关键渲染路径可提高渲染性能。
大致步骤是这样：在解析 HTML 时会创建 DOM，HTML 可以请求 JavaScript，而 JavaScript 反过来，又可以更改 DOM。HTML 包含或请求样式，依次来构建 CSSOM。浏览器引擎将两者结合起来以创建 Render Tree (渲染树)，Layout(布局)确定页面上所有内容的大小和位置，确定布局后，将像素 Paint (绘制)到屏幕上。
优化关键渲染路径可以缩短首次渲染的时间。了解和优化关键渲染路径对于确保重排和重绘可以每秒 60 帧的速度进行，以确保高效的用户交互并避免讨厌是很重要的。
接下来研究一下详细的过程：
步骤 1. 生成DOM DOM构建是增量的。浏览器从远程下载 Byte =&amp;gt; 根据相应的编码 (如 utf8) 转化为字符串 =&amp;gt; 通过 AST 解析为 Token =&amp;gt; 生成 Node =&amp;gt; 生成 DOM。</description>
    </item>
    
    <item>
      <title>做人要做学习型，做事儿要做价值型</title>
      <link>/posts/2022/03-11-%E5%81%9A%E4%BA%BA%E8%A6%81%E5%81%9A%E5%AD%A6%E4%B9%A0%E5%9E%8B%E5%81%9A%E4%BA%8B%E5%84%BF%E8%A6%81%E5%81%9A%E4%BB%B7%E5%80%BC%E5%9E%8B/</link>
      <pubDate>Fri, 11 Mar 2022 22:29:22 +0000</pubDate>
      
      <guid>/posts/2022/03-11-%E5%81%9A%E4%BA%BA%E8%A6%81%E5%81%9A%E5%AD%A6%E4%B9%A0%E5%9E%8B%E5%81%9A%E4%BA%8B%E5%84%BF%E8%A6%81%E5%81%9A%E4%BB%B7%E5%80%BC%E5%9E%8B/</guid>
      <description>今天在阅读《华与华正道》，读到两句金句：
做人要做学习型，不要做纠错型 不要批判思维，要价值思维 记忆深刻，分享一下我的理解。
做人要做学习型 从小我们就学过《论语》的：三人行，必有我师，择其善者而从之,其不善者而改之。
对这句的解释是：别人的言行举止，必定有值得我学习的地方。选择别人好的学习，看到别人缺点，反省自身有没有同样的缺点，如果有，加以改正。
以前在学习的时候只是去死记硬背，并没有去想把这个思想实践到现实中，这就是读死书。
其实读书和交友一样，要看他好的地方。如果纠到一点错就拒之门外，就无书可读、无友可交了。
善于学习别人的人，每天都在成长，每次交流、都在学习，如果是纠错型的人，总是在挑刺，总是自以为是，这样就无法从别人身上学习，成长缓慢。一旦成长缓慢，思维受限，就更无法从牛人身上学习，恶性循环就是这样来的。
除了要做一个学习的人，还要注意不要做一个纠错型的人，老纠别人的错，这样的话你会觉得周围所有人都不好，以自己为中心，这样身边的人都会对你避而远之。
做事要做价值型 不要总是持有批判思维，要学会价值思维。
身边有没有遇到过这样的案例，一个新东西出来，不是去研究这个东西的价值，而是上来就开始批判这个东西的好坏。
就拿数字货币来说吧，可能听说过比特币是基于区块链做的，然后还有还有很多山寨币，很多人炒币亏了，就否认数字货币，否认区块链技术。
然而实际上，这种去中心化区块链的方式，可能是历史依赖，解决信任问题的一大革命。
在比特币上也是，真正去研究他价值的人，从来不是以炒的心态去做的，这些人早已经赚得盆满钵满了。
对一个人，或一件事、一个方案，你不要一上来就评判他好或坏、对或错、接纳或拒绝。而是要关注他有什么价值，这样你就能得到价值。没有人经得起评判，但每个人都有价值。
价值思维的人总是从任何事或人上，都能看到价值，然后从中学习，批判型的人会慢慢丧失研究的能力，上来就要得出一个结论，好或者坏，对或者错。
总结 这两句金句给我最大的感受就是要放开自己，打开自己的眼界，让自己的见识增长，这样眼里就会容纳更多的东西，海纳百川有容乃大。
这样我们才可能看到别人，或者事情的价值，打开自己学习的欲望，而不是眼界狭窄，认为这个世界仅仅只是二元的。</description>
    </item>
    
    <item>
      <title>幸福的秘诀--保持低期望</title>
      <link>/posts/2022/03-10-%E5%B9%B8%E7%A6%8F%E7%9A%84%E7%A7%98%E8%AF%80--%E4%BF%9D%E6%8C%81%E4%BD%8E%E6%9C%9F%E6%9C%9B/</link>
      <pubDate>Thu, 10 Mar 2022 22:55:22 +0000</pubDate>
      
      <guid>/posts/2022/03-10-%E5%B9%B8%E7%A6%8F%E7%9A%84%E7%A7%98%E8%AF%80--%E4%BF%9D%E6%8C%81%E4%BD%8E%E6%9C%9F%E6%9C%9B/</guid>
      <description>为什么你总是在焦虑，总是对生活感到不满呢？
也许是因为期望值太高了。由于期望值过高，现实往往不能达到预期的标准，即使达到了预期的标准，也体验不到“超过预期”的欢欣，因此，完美主义者们总是感到忧心忡忡。
也许是时候把自己的期望值降低一些了，这并不是对现实生活的消极应对，而是对幸福感的积极追寻。
今天读到一段话 ——
对事对人，永远保持低期望。对任何事，永远保持低期望。低期望，就能坚持，就能付出。期望值太高，则很快因失望而放弃。为什么总是不求回报的人得到最大回报，就是这个原因。
对我自己以前的想法产生了巨大的冲击。
特别是对事儿，我以前都是以高期望去做的，认为这样可以让自己在做事儿的时候会更有动力，因为觉得这个事儿只要做成了就会很牛逼，高期望。
在读到这段话，也许我真的要改变以往的心态了。
期望值是一个人对某个目标能够实现的可能性的估计，目标估计越高，并不意味着实现目标的概率就越大，反而会因为不能实现目标而引起失望，增加心理痛苦。
生活中人们往往对某些东西抱有较高的期待，但是等到面对时，往往会发现这件东西并没有给你带来预期的效果，这种心理上的落差会让人倍感痛苦。
我之前看到过这样一个公式：幸福 = 现实 - 期望。
所以想要幸福，关键因数在于现实和期望。
现实往往是难以改变的，但是我们可以管理我们的期望，调整节我们的幸福感。
期望又分为对人的期待和对事儿的期待。
怎么做到对事儿对人保持低期待呢？
比如当我们再寻求朋友帮助的时候，我们一定要降低期望，帮我们是情谊不帮我们是本分。如果你抱着一定会帮你心态，一旦被拒绝，那么你的心理落差会巨大，会觉得这个朋友不给力，这点都不帮你。
那么也许你跟这个朋友的关系就会就此走下坡路。
但是如果抱着低期望，可能这个忙大概率，他不会帮我，毕竟挺麻烦他的。如果他拒绝了，反正你已经预料了，但是如果同意了，你会觉得这个朋友靠谱，值得信赖。
这样不管什么情况，两个人的关系都不会出现问题。
这个放在两性关系里也挺实用的，比如恋爱或者结婚之后，抱着很高的期望，觉得对方不会有很多缺点，所以当你对方的做法令你不满意的时候就会经常吵架。
但是其实都是人嘛，怎么可能没有缺点，总会有多多少少的摩擦，降低期望，互相谅解。
怎么做到对事儿保持低期待呢？
对事儿保持期望其实很简单，就是降低目标就行了。
以我自己为例子，我每次发文章都抱着这篇文章一定能火的心态，那肯定每天过得都愁眉苦脸。
但是我放平心态，我最近并没有什么实质性的突破，发个文章跟平时保持差不多就行了。
一旦可能比平时阅读量高一点，我就会开心一整天，如果反响平平，那也不会影响我的心情。
其实我以前就是对事儿，是以高期望的心态去做的。所以我以前经常做着做着不符合预期的时候就很伤，特别打击人。
就拿做公众号来说，以前一起做公众号的几个朋友，好多人比我还晚做，但是阅读量早已超过我许多了。
其实被后来的人超越，以前我还挺难受的，但是后来想通了，自己确实没有别人写得多，没有付出那么多努力，做得差也应该嘛，后面心态就好了。
最后的建议 保持低期望值，并不是要求你不思进取，而是因为人的欲望和贪婪是永无止境的，保持较低的期望值，反而会对安心做事、身心健康与事业成就有好处。在浮躁的社会环境中，保持低期望值，保持简约生活，可以调节与清净我们的心灵，指导我们实实在在的幸福生活。</description>
    </item>
    
    <item>
      <title>时间管理的三大法宝</title>
      <link>/posts/2022/03-09-%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E5%A4%A7%E6%B3%95%E5%AE%9D/</link>
      <pubDate>Wed, 09 Mar 2022 22:47:22 +0000</pubDate>
      
      <guid>/posts/2022/03-09-%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E5%A4%A7%E6%B3%95%E5%AE%9D/</guid>
      <description>今天读《华与华正道》看到一句话：如何管理时间？做到铁石心肠、制定节拍、不追热点。
这三个法宝基本上已经足以满足绝大部分人的需求了。
接下来我们来推演一下这三个法宝为什么有用。
大前提：
时间管理就是把重要的事情放在效率最高的时候做，让产生的价值最大化。即时间管理 = 做事价值 * 做事的效率
你是承认时间并不能被管理，被管理的只有人。
如果这个大前提是认同的，可以继续往下看，如果不认，可以关闭了，因为下面所有的推演都是基于此。
法宝一：制定节拍 我们基于大前提一开始推演，时间管理 = 做事的价值 * 做事的效率。
所以我们就要知道我们做什么事情价值高，同时，我们在什么时候做事的效率高。
当我们知道之后，我们就需要制定我们自己的节拍，尽量的去固定自己的日程，在效率高的时候去做价值高的事情。
这样我们才会效益最大化，时间管理就是有效的。
如果我们没有制定自己的节拍，那么我们就是跟着别人的节拍走的，他想什么时候找你就什么时间找你。
别人按照他的节拍走的，事儿都干完了，而自己的最重要的事情都还没干。
这种情况就需要模糊，互相的去适应，去调整互相的节拍，尽量一致。
另外自己的节拍最好可以公布出来，让大家都知道，这样磨合起来会快一点。
法宝二：铁石心肠 基于大前提二：时间不能被管理，被管理的只有人。
这个人有别人和自己。
铁石心肠就是用来管理别人的，当别人来打断你的计划的时候，可以拒绝。
没有什么抹不开面子的事儿，我的时间我做主。
法宝三：不追热点 同样基于大前提二：时间不能被管理，被管理的只有人。
这个人有别人和自己。
不追热点就是用来管理自己的。
让自己可以专注于的做事情，高效不仅需要一个合适的时间段，更重要的还是需要能专注下来，心无旁骛。
追热点就像街上有人打架，你围观，还评论，最浪费时间。
总结 总结下来管理时间就是严格准时自己制定的节拍，通过铁石心肠和不追热点的法宝管理别人和管理自己，让自己制定的节拍能够准时执行下去。</description>
    </item>
    
    <item>
      <title>使用 React 和 TypeScript 编写干净代码的10个必知模式</title>
      <link>/posts/2022/03-09-%E4%BD%BF%E7%94%A8-react-%E5%92%8C-typescript-something-%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%BB%A3%E7%A0%81%E7%9A%8410%E4%B8%AA%E5%BF%85%E7%9F%A5%E6%A8%A1%E5%BC%8F-copy/</link>
      <pubDate>Wed, 09 Mar 2022 08:20:00 +0000</pubDate>
      
      <guid>/posts/2022/03-09-%E4%BD%BF%E7%94%A8-react-%E5%92%8C-typescript-something-%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%BB%A3%E7%A0%81%E7%9A%8410%E4%B8%AA%E5%BF%85%E7%9F%A5%E6%A8%A1%E5%BC%8F-copy/</guid>
      <description>React 是一个 JavaScript 库，它是当今最流行和行业领先的前端开发库。
JavaScript 是一种松散的类型化语言，因此，它捕获了运行时。这样做的结果就是 JavaScript 错误被捕获得非常晚，这可能导致严重的 bug。
当然 React 作为一个 JavaScript 库，也继承了这个问题。
干净代码(Clean code)是一种一致的编程风格，它使代码更容易编写、读取和维护。任何人都可以编写计算机可以理解的代码，但是优秀的开发人员可以编写人类可以理解的干净的代码。
干净的代码是一种以读者为中心的开发风格，它提高了我们的软件质量和可维护性。
编写干净代码需要编写具有清晰和简单的设计模式的代码，这使得人们可以轻松地阅读、测试和维护代码。因此，干净的代码可以降低软件开发的成本。这是因为编写干净的代码所涉及的原则，消除了技术债务。
在本文中，我们将介绍一些在使用 React 和 TypeScript 时使用的有用模式。
💡 为了让您的团队更容易地保持代码健康并优先处理技术债务工作，请尝试使用 Stepsize 的 VS Code 和 JetBrains 扩展。它们帮助工程师创建技术问题，将它们添加到迭代 中，并持续解决技术债务——而不离开编辑器。
现在让我们来了解一下在使用 React 和 Typescript 时应用的 10 个有用模式:
1. 使用默认导入来导入 React 考虑下面的代码:
import * as React from &amp;#34;react&amp;#34;; 虽然上面的代码可以工作，但是如果我们不使用 React 的所有内容，那么导入它们是令人困惑的，也不是一个好的做法。一个更好的模式是使用如下所示的默认导出:
import React, {useContext, useState} from &amp;#34;react&amp;#34;; 使用这种方法，我们可以从 React 模块中解构我们需要的东西，而不是导入所有的内容。
注意: 要使用这个选项，我们需要配置 tsconfig.json 文件，如下所示:
{ &amp;#34;compilerOptions&amp;#34;: { &amp;#34;esModuleInterop&amp;#34;: true&amp;#34; } } 在上面的代码中，通过将 esModuleInterop 设置为 true，我们启用了 allowSyntheticDefaultImports ，这对于 TypeScript 支持我们的语法非常重要。</description>
    </item>
    
    <item>
      <title>回顾过去比展望未来重要一百倍</title>
      <link>/posts/2022/03-08-%E5%9B%9E%E9%A1%BE%E8%BF%87%E5%8E%BB%E6%AF%94%E5%B1%95%E6%9C%9B%E6%9C%AA%E6%9D%A5%E9%87%8D%E8%A6%81%E4%B8%80%E7%99%BE%E5%80%8D/</link>
      <pubDate>Tue, 08 Mar 2022 22:00:00 +0000</pubDate>
      
      <guid>/posts/2022/03-08-%E5%9B%9E%E9%A1%BE%E8%BF%87%E5%8E%BB%E6%AF%94%E5%B1%95%E6%9C%9B%E6%9C%AA%E6%9D%A5%E9%87%8D%E8%A6%81%E4%B8%80%E7%99%BE%E5%80%8D/</guid>
      <description>今天在阅读《华与华正道》读到这么一句话 ：
回顾过去比展望未来重要一百倍，如果对过去不认真复盘，就会再次掉进过去的错误里。一个步骤一个步骤地复盘，一个动作一个动作地复盘，才能找到成功或失败的真因。在复盘中钻研，钻研工法，持续改善，最终实现全公司的技术进步。
我们在哪些方面，应该回顾、复盘？ 工作上的事情，比如每一个项目做完了需要复盘，每个月至少写一个月报复盘一下，最好每周复盘。 自己的情绪，比如跟伴侣吵架了，复盘一下是什么情况，两个的情绪分别是啥样的，然后复盘完之后两个再沟通一下，增加感情。 时间管理，比如每天组内其他同学下班都挺早，为啥自己这么晚。为啥早上规划的 5 件事，到下班只做了 3 件事？是不是被别人占用的时间太多了，还是自己偷懒了？ 如果不回顾，会怎么样？ 如果我们不养成回顾的习惯，一路往前走，肯定是走不远的。
因为如果我们不对过去的进行复盘，大概率会再次掉进过去的错误里，只有在复盘的时候找到根本原因，才能进行避免；
同时做得好的地方，也不会被发现，就无法让自己产生积累，无法给其他人复制，这样就无法精进，所以是走不远的。
如何让我们能坚持回顾 每天回顾固然是好的，但是对于大部分人来说是很有难度的。
比如：
上了一天班，很累，回家就想休息。
回顾是一个思考的过程，思考是反人性的，大脑会痛苦，特别是在晚上，意志力会变得很弱。
我以前还遇到过一个难点，不知道回顾什么，想每天写日记来回顾，但是不知道写啥。
针对以上的难点，我的思考的解决方案有两个：
针对 1 和 2，其实都是因为把回顾的时间放到了晚上，晚上其实在做脑力工作不是一个合适的时间，建议把回顾放到早上，早起写晨间日记，写完前一天的复盘之后，再根据复盘的内容做当天的规划。 针对第 3 天，可以从工作、学习、快乐的事情、梦想、理财、关系、健康这几个方向去做回顾，养成习惯之后，这个事情机会变得很容易。 如果自己能坚持每天回顾，我相信我可以在这一年过得非常的清晰，因为我每天都知道我的目标是什么，我现在离目标有多远，我还要做什么才可以实现我的目标。
同时，我也可以通过反思、回顾及时的调整错误的做事方式，
最后 希望大家少关注未来，多回望历史，对过去犯过的错，认真复盘总结
我们预测不到特朗普上台，也预测不了新冠肺炎发生，预测不了美股熔断，现在也预测不了哪个国家会怎么样。德鲁克说，未来只有一点是确定的，就是肯定跟我们的预测不一样。所以，少关注未来，多回望历史。过去犯过的错，认真复盘总结，下次不要再犯。</description>
    </item>
    
    <item>
      <title>专注于自己能做的最少的事情</title>
      <link>/posts/2022/%E4%B8%93%E6%B3%A8%E4%BA%8E%E8%87%AA%E5%B7%B1%E8%83%BD%E5%81%9A%E7%9A%84%E6%9C%80%E5%B0%91%E7%9A%84%E4%BA%8B%E6%83%85/</link>
      <pubDate>Mon, 07 Mar 2022 22:00:00 +0000</pubDate>
      
      <guid>/posts/2022/%E4%B8%93%E6%B3%A8%E4%BA%8E%E8%87%AA%E5%B7%B1%E8%83%BD%E5%81%9A%E7%9A%84%E6%9C%80%E5%B0%91%E7%9A%84%E4%BA%8B%E6%83%85/</guid>
      <description>今天读《华与华正道》，读两句话：
先认识到什么事情是我们做不到的，然后再积极地去做现在能做的事。 要认识到我们知道的有限，能做的事情很少，然后把最少的事情做到最彻底 这两句都是让我们更专注于当前的事的思维。
一、认识到什么事情是我们做不到的，然后再积极地去做现在能做的事 不知道大家有没有这样一种体感，就是你越读书，越专研一个知识，会发现自己不懂的越来越多，感觉自己越学越菜，越学不懂的越多。
这是正常的，不管是阅读，还是跟牛人交流，随着你对世界的认识越深刻，刚开始起的作用是消极的，然后才是积极的。
消极，让我们认识到自己能力和认知的边界，认识到什么事情知道，什么事情不知道，然后才积极的去做自己能做的事情。
这种消极的意义可以让我们避免一些侥幸的情况，堵塞一切错误的源头。
比如我去年在做年度总结的时候就说道我现在放弃了投资个股，甚至一些主动型的基金。
不仅仅是因为去年亏了，而是因为我去年看了很多的投资的书籍，知道了投资个股要想一直赢，是一件极难的事情，需要考虑的东西实在太多。
那些金融公司的高材生，天天研究都不一定能保证能赚，甚至不一定能跑赢大盘，我一个一年就花几十个小时的人，怎么可能比他们强。
所以选择投指数基金或者做一些低风险的投资。
然后把更多的时间花在自己的工作或其他有意义的事情。
这就是认识到自己的能力边界的意义，可以专注于自己能做的事情。
二、要认识到我们知道的有限，能做的事情很少，然后把最少的事情做到最彻底 在上面已经明白了，我们要去积极的做自己能做的事情。
但是其实能做的事情也很多，比如我想做自媒体，我可以：
做公众号 做抖音 做头条 做小红书 做知乎 等等各种方式。
但是除了公众号，其他的平台我都是几乎没有经验，如果花挺多时间到其他平台上，那将是充满很多的不确定。
如果我每个平台都花时间去做，可能最终的效果就是每个渠道都没做起来，甚至公众号也垮了。
所以我今年还是重点发力在公众号上，去寻找确定性的道路，把目标缩小到具有确定性。
想要得到一切，不过是一厢情愿的幻想。
要认识到，并接受现实——我们所知道的有限，我们能做的事情很少，然后把最少的事情做到最彻底。
把最小确定性的目标实现，则运气上不封顶。想要的东西太多，则所得下不保底。
总结 第一句话告诉了我们要去知道哪些我们是不知道的，积极去做能做的。
第二句话是在能做的事情里去寻找确定的小目标，我们知道的有限，能做的也很少，把这少的、能做的事情做到最彻底。
剩下的交给运气就行了。</description>
    </item>
    
    <item>
      <title>如何正确的花钱</title>
      <link>/posts/2022/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%8A%B1%E9%92%B1/</link>
      <pubDate>Sun, 06 Mar 2022 22:00:00 +0000</pubDate>
      
      <guid>/posts/2022/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%8A%B1%E9%92%B1/</guid>
      <description>前言 今天阅读《华与华正道》，看到了跟花钱有关的两句话：
要舍得多花“冤枉钱”，这样碰上刀刃的概率比较大 钱最贱，人最贵，贵的人，时间更贵 感受颇深，特来解读自己理解。
要舍得多花“冤枉钱”，才容易花到刀刃上 经常父母会说：在外面不要乱花钱，要把钱花在刀刃上。
但是父母并没有说
「刀刃」是什么？ 怎么才能把钱花在「刀刃」上。 刀刃是什么？
刀刃是刀最锋利的一边，用来比喻关键处。
那其实把钱花到刀刃上，即为把钱花在关键处。
这个关键处，对于不同的人，不同的时期，关键处也不一样。
比如：
读高中的时候，关键处就是高考，那么花钱到刀刃上就是要把到合适我的练习题。 上大学的时候，关键处是为了找工作，那么花钱到刀刃上，就需要把钱买到合适的编程书籍、合适的编程课程。 对于可能快结婚的人，那么花钱就应该花在买房、准备结婚的钱，而不是把钱拿去投资、创业、娱乐。 所以，想要正确的花钱，需要找到自己当前最需要什么，然后根据自己的需要找到「刀刃」。
多花「冤枉钱」，是一个花到刀刃上的好方法。
如何把钱花在刀刃上？
答案是多花冤枉钱，这样碰上刀刃的概率比较大，就容易成功。如果想把所有的钱都花在刀刃上，那就根本碰不上刀刃，这人就没出息了。
我举几个例子就会明白了。
比如一些广告商，来公众号投广告，那么他们的刀刃就是把钱花下去了，就有转化率，有人报他们课。
如果他们抱着只要投了，就一定有人报课的心态去投的话，他们就可能花大量的时间跟金钱去研究这个公众号主转化率是否符合期望。
这样有两个问题：
时间风险，可能会导致被其他的广告给吸引走了，现在一般一个行业同类的会有好几个，不存在只有一家公司。 金钱成本，在去深度判断一个公众号是否值得投入，可能需要买很多工具，已经人力去分析，这也是很大的成本。 所以往往刚开始广告商都是简单的了解一下号主，然后先投一次再说，效果好的，再复投就行了。这样可能是会多花「冤枉钱」，但是没有让优秀的号主被遗漏。
再拿现在的很多公司拉新来说吧，比如注册邀请一个好友注册，奖励 20 元。
他们其实要的用户是长期用它们的 APP，并且可以在他们平台消费的用户。
但是要这样精准的用户(其实就是刀刃)，很难精确的筛选出来，去进行补贴吸引，所以只能多花「冤枉钱」，先铺量，再选优。
这样就明白了吧，想把所有的钱花在刀刃上，最终可能就是碰不上刀刃。多花点冤枉钱，这样在刀刃上的概率大。
钱最贱，人最贵，贵的人，时间更贵 书中是这么解释这句话的：
能花钱办的事，绝对不要花时间。能用钱办的事，绝对不要用人。能外包给别人干的事，绝对不用自己人。钱最贱，人最贵，贵的人，时间更贵。别人再贵，也比自己人便宜。自己人最贵，所以要加大投资培养自己人。
总结一下就是：按照贵重程度排序，人 &amp;gt; 时间 &amp;gt; 钱
当然，这句话我并不是完全同意，我同意他的理念，不同意他的绝对。
我身边有挺多人把钱看得太重要了，而忽略了时间成本。
有一次跟几个朋友一起从杭州到上海去参加一个隆重的校友会，我们都买的是高铁票，一个多小时能到；而有一个人买的是火车票，应该要三个多小时。
价钱上应该火车票会比高铁便宜一半。
当时我们就说你这在车上浪费的时间，完全不知道，这次出去我们就是为了玩的，结果大多时间都浪费在了火车上。
这个朋友当时完全不能理解时间比钱重要的思想，可能是从小节约用钱的思想根深蒂固。
最终就是我们到了上海之后玩了好久他才到，他到了上海，都快吃晚饭了，结果就是啥都没玩到，你说这亏不亏嘛。
如果你也觉得时间很重要，那就用钱去换时间。
比如：
你应该多花点钱让自己住得离公司近一点，而不是为了省钱，每天在通勤上花上 两三个小时。 短途出行，非高峰期，坚决选择打车。公共汽车、地铁路线虽多，但站站停，换车通常花太多时间。 付费学习，买书、买课程，买教练，不再世界上到处找免费的东西。 付费咨询：与其自己纠结，不如直接投资找个行业专家咨询建议。 常言道，年轻时用时间换钱，年老时用钱换时间。
时间是我们最宝贵的资产，趁年轻时不必要的小钱就别刻意节省了，分配出一些金钱兑换时间多做些自己喜欢的事情岂不是更好？
随着你养成了用金钱交换时间的习惯，减少找免费服务、便宜货。
不知不觉，你反而节省了时间和原本会被消耗的专注力。
总结 这两个花钱的观念我希望人人都能懂。
多花冤枉钱，花在刀刃上。 用金钱换时间，人 &amp;gt; 时间 &amp;gt; 钱。 </description>
    </item>
    
    <item>
      <title>【实战】分享一个花了 499 学到的写作方法：问题 &#43; 回答</title>
      <link>/posts/2022/%E5%AE%9E%E6%88%98%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E8%8A%B1%E4%BA%86-499-%E5%AD%A6%E5%88%B0%E7%9A%84%E5%86%99%E4%BD%9C%E6%96%B9%E6%B3%95%E9%97%AE%E9%A2%98-&#43;-%E5%9B%9E%E7%AD%94/</link>
      <pubDate>Tue, 01 Mar 2022 19:25:00 +0000</pubDate>
      
      <guid>/posts/2022/%E5%AE%9E%E6%88%98%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E8%8A%B1%E4%BA%86-499-%E5%AD%A6%E5%88%B0%E7%9A%84%E5%86%99%E4%BD%9C%E6%96%B9%E6%B3%95%E9%97%AE%E9%A2%98-&#43;-%E5%9B%9E%E7%AD%94/</guid>
      <description>大家好，我是桃翁，一个不止前端的前端工程师。
前言 前几天在一个写作课里学习到一个写作技巧：文章 = 问题 + 答案。
大概就是说当你看到一个话题，想写成文章的时候，可以想一想你针对这个话题会有哪些问题。然后挨个回答一下这个问题，把回答组合一下，就成为一篇文章了。
我发现这个方法跟我有一些文章的方法很像，但是我并没有这样总结出来，而是在写的时候自然而然就这么去设计了。
以这篇用 husky 和 lint-staged 构建代码检查工作流 文章举个例，做一个实战教学，建议看下面的内容的时候先阅读一下这篇文章。
实战 一、提问题
我要介绍的主题是：构建代码检查工作流。
针对这个主题，我想到了几个问题：
什么是代码检查？ 什么情况下需要用到代码检查？ 怎么做代码检查？ 怎么把代码检查做成工作流？ 注意：每个人想到的问题不一样，所以写的思路可能也不太一样。
如果想不到什么问题，我这里给到的建议可以提 what、when、why、how 这样的问题，这也是一种写作方法，后面再讲。
根据以上的思路就可以把大纲列出来。
二、列大纲 其实一般可以直接把这些问题当做大纲。
但是我这篇文章后面又考虑到怎么做代码检查东西比较多，只有在知道了最基础的代码检查方法之后，才可能推到出要用 husky 和 lint-staged 这样的工具。
所以我最终还是以陈述的方式为大纲，一步一步的引导，最终把把代码检查做成工作流。
所以最终这篇文章的目录大概是这样的。
前言里面回答了什么是代码检查和什么情况下需要用到代码检查。
在最简单的方法这个大纲里就是怎么做代码检查。
最后的三个都是讲怎么把代码检查做成工作流。
三、回答问题
大纲做好了，就开始填内容了。
前言就没什么好说的了，主要是介绍背景，然后引出我们怎么做代码检查。
接下来就写了最简单的方法来做代码检查，再提出了两个问题。
其实这两个问题就是来解决工作流的问题。
下面的两个段落就是来解决这两个问题，看到没有，这又是问题 + 回答的模式，不仅大话题可以引发问题，还可以问题里套问题。
标题：通过 scripts 来解决如果检测工具多，需要多次处理，解决问题 1.
标题：通过 husky(哈士奇)来解决容易遗忘的问题，解决问题 2.
所以整篇文章都是以问题驱动，一步一步引导读者把小问题解决了，最终串起来就把大问题解决了。
总结 总结一下，这种问题 + 回答的写作方式有什么好处：
**段落之间具有连贯性。**每个标题之前都是承上启下，都是来解决上面一个标题的问题，然后引出下面一个问题。 读者读起来很流畅，会产生恍然大悟的感觉。 最后在复盘一下这篇用 husky 和 lint-staged 构建代码检查工作流 我觉得不好的地方：
标题不够小白，导致受众不够多，导致打开率低。 在前言里背景介绍得不够细致，如果以前没做过这方面的，可能体感不强。 </description>
    </item>
    
    <item>
      <title>git commit 规范和 如何在 commit 里使用 emoji</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/2021-09-05-git-commit%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sun, 05 Sep 2021 15:30:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/2021-09-05-git-commit%E8%A7%84%E8%8C%83/</guid>
      <description>前言 大家好，我是桃翁，今天给大家带来的是关于 git commit 那些事儿，希望大家喜欢。
对于规范 git commit message 我是分成了两种类型去看待。
对于通用库、开源项目这类多人维护，而且极大可能别人会来看这份代码的，一定要规范，特别是对于开源项目，往往会要列 Change Log，规范好 commit 节省自己整理 log 的时间，也方便了用户。
对于业务代码，特别是那种一个人维护的，其实不搞问题也不大，因为极小可能会有人来看你的 commit message。但是我依然还是建议规范一下，不然一旦后面想去看就会花费很多的力气，毕竟规范一下也不麻烦。
通过本篇文章你讲了解到三部分内容：
了解 git commit 规范 学到用工具 Commitizen 来规范 commit 学到如何在 commit message 里加上好看的 emoji 规范 现在主流的 commit message 规范就是 Angular 团队所用的准则，继而衍生了 Conventional Commits specification. 很多工具也是基于此规范。
每次提交，Commit message 都包括三个部分：header，body 和 footer，其中 header 有一个特殊的格式，包括了 type、scope、subject。
&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt; &amp;lt;BLANK LINE&amp;gt; &amp;lt;body&amp;gt; &amp;lt;BLANK LINE&amp;gt; &amp;lt;footer&amp;gt; 其中 header 是必选的，但是 header 里的 scope 是可选的，另外提交的 message 长度不要超过 100 个字符，太长了不易阅读。</description>
    </item>
    
    <item>
      <title>img 和 picture 的区别和使用场景</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/img-he-picture-de-qu-bie-he-shi-yong-chang-jing/</link>
      <pubDate>Thu, 01 Jul 2021 15:12:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/img-he-picture-de-qu-bie-he-shi-yong-chang-jing/</guid>
      <description>img img 是 HTML4 时就有的标签， 至今仍然是在网页中嵌入图片的最常用的方式。 与 &amp;lt;span&amp;gt;, &amp;lt;em&amp;gt; 等标签一样属于行内标签 （准确地说属于 Phrasing Content）。下面是一个示例：
&amp;lt;img src=&amp;#34;favicon72.png&amp;#34; alt=&amp;#34;MDN logo&amp;#34; srcset=&amp;#34;favicon144.png 2x&amp;#34;&amp;gt; img 其实也可以控制在高清屏幕采用哪个图片，适合用在移动端
picture &amp;lt;picture&amp;gt; &amp;lt;source srcset=&amp;#34;/media/cc0-images/surfer-240-200.jpg&amp;#34; media=&amp;#34;(min-width: 800px)&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;/media/cc0-images/painted-hand-298-332.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/picture&amp;gt; 要决定加载哪个URL，user agent 检查每个 &amp;lt;source&amp;gt; 的 srcset、media 和 type 属性，来选择最匹配页面当前布局、显示设备特征等的兼容图像。
picture 就可以方便的控制在某种媒体类型，加载哪个图片。感觉比较适合做响应式用。
相比 img 标签，picture 提供了更丰富的响应式资源选择方式；
picture 是 HTML5 中定义新标签， 其中可以定义若干个 &amp;lt;source&amp;gt;，浏览器会匹配 &amp;lt;source&amp;gt; 的 type, media, srcset 等属性， 来找到最适合当前布局、视口宽度、设备像素密度 的一个去下载。 为了向下兼容不识别 &amp;lt;picture&amp;gt; 和 &amp;lt;source&amp;gt; 的浏览器，&amp;lt;picture&amp;gt; 中还可以写一个 &amp;lt;img&amp;gt; 作为 fallback。</description>
    </item>
    
    <item>
      <title>聊聊关于如何选择offer</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/337/</link>
      <pubDate>Thu, 27 May 2021 08:57:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/337/</guid>
      <description>前阵子我们组大量招人，看到一些候选人拿了好几个 offer 摇摆不定，一直在纠结；也有不少读者私下跟我询问怎么选择；另外就是知乎上，我回答了一个 蚂蚁和字节怎么选的问题，阅读量比较高，所以也经常有人问我这个问题。
所以想写篇文章来聊一聊这个问题。
最多的就是字节和阿里怎么选 ♀️
我去年换工作的时候也拿了好几个 offer (蚂蚁、字节、滴滴、拼多多、酷家乐)，当时也有过一阵子的纠结，觉得这个公司这里好，那个公司那里好，现在回想起来有点幼稚。
关于我 我之前呆的公司是蘑菇街，一家比较年轻的公司，压力不大，每天基本认认真真敲个四个小时左右代码就可以完成工作，每天晚上大概 7 8 点下班。
在蘑菇街主要是做平台服务，主要是负责一些运营的后台系统，所以不存在着倒排需求，基本上都是正排，在完成自己的工作以后，就有大量的时间去学习一些新知识。
但是由于业务比较简单，所以很多新知识无法真正用到项目里，感觉自己的上限有所限制，所以一直有一个想去大公司，可以有更多可能的公司。
具体原因见： 离开蘑菇街后，我最近的一些想法
我是怎么选的 以下内容来自于我在知乎的回答：蚂蚁金服 VS 字节跳动的 Offer 怎么选择? - 桃翁的回答 - 知乎 https://www.zhihu.com/question/394340089/answer/1251264179
我之前也有过这样的迷惑，也是最近吧，由于公司裁人，逼得我不得不去面试，面过了五家不差的公司(蚂蚁、字节、拼多多、滴滴、酷家乐) ，除了拼多多都是杭州的，因为我目前是在杭州的，所以杭州岗位比较多。
当时在选 offer 的时候令我比较纠结的也是字节和蚂蚁，最后选择了蚂蚁，说一下我的选择逻辑吧，希望能给你一些参考。
1 . 薪资方面。阿里在 P7 以前的薪资是没办法和字节比的，理论上字节待遇会比蚂蚁好，我也是，但是很多人在字节入职即巅峰，涨薪比较少，我了解过，字节绩效好或者晋升才有涨薪，如果绩效仅仅是达到期望基本不会涨薪，但是阿里会有普调，所以如果干几年薪资应该会差不多。另外薪资方面就是年终奖的问题，据我了解阿里的激励会比字节激励的比较多，对于 3.75 加 高潜的同学年终奖将异常的高，而且还会有股票和期权。
base 上字节是好于蚂蚁，年终奖蚂蚁好于字节，总体薪资我觉得字节还是会优于蚂蚁的，毕竟字节还有加班费和房补。
背书方面。蚂蚁背靠阿里这座大山，我征询过我身边值得相信的一些大佬，大部分人还是觉得蚂蚁的背书是要大于字节的，就是觉得蚂蚁比字节难进，以后从蚂蚁出来和字节出来，蚂蚁更有优势一点。
团队方面。蚂蚁杭州总部，字节是分部。当时我在的团队 leader 是在北京的，我是觉得老板毕竟在北京，虽然每个月会来分部带两天，但是总归还是没有老板在身边这么了解自己，所以在绩效方面我觉得蚂蚁是有优势的。另外我在蚂蚁的老板是我上一家公司的老板，比较熟悉，也给蚂蚁加了不少分。
加班程度。蚂蚁很累，累的程度不必字节的大小周差。
我的回答可能倾向于蚂蚁一点，因为我的最终选择是选择了蚂蚁，所以会觉得蚂蚁更好，因为我工作年限也不到 2 年，所以更看重成长和背书，我觉得在蚂蚁带来的成长会比字节多。如果仅仅看重薪资的话可能直接选 拼多多 了。
如何选择 我们往往活在对未知的恐惧，害怕对未来预测的偏差，所以才不知道如何选择。我们往往什么都想要，或者说什么都不舍得放弃，所以才不知道如何选择。其实，只要我们清楚自己最想要的是什么，做减法就可以了。必须做减法，才能做选择。
可以这么去做：
行业、公司、团队、文化、城市、老板、工作内容、工作强度&amp;hellip;把你想得到的维度都列下来 然后就开始划除，一个个划掉。 最后剩下的那一到三个就是你真心不能放弃的，看看哪个机会最符合或接近符合，就是哪个。 每个人的境况不同，能做出的选择自然不同。所以，不要轻易地去为别人做决定，随意地去评价别人的决定。毕竟，你不傻，别人也不傻。
无论今年几岁，我们都要尽量做出属于自己的选择，即使这个选择不完全是自己的真心，但真心一定要有。
一些忠告 自己想要什么最重要。 刚开始工作 base 差个两三 k 不重要。 工作不久的成长很重要。 不要完全听别人的，包括你心中的大佬，别人的意见只能当做参考，不能作为答案。 选了就不要后悔，因为说不定其他选择也跟你想象的不一样。 如果能有多个选择，证明你在这个行业还是比较优秀的，但是也不要骄傲，当你到了跟你一样的公司去的时候，你会发现周边比你优秀的人不要太多。 最后希望每个人都能拿到满意的 offer，选择自己最想去的公司。</description>
    </item>
    
    <item>
      <title>如何应用 SOLID 原则在 React 中整理代码之开闭原则</title>
      <link>/posts/%E8%AF%91%E6%96%87/336/</link>
      <pubDate>Mon, 24 May 2021 08:27:43 +0000</pubDate>
      
      <guid>/posts/%E8%AF%91%E6%96%87/336/</guid>
      <description>SOLID 是一套原则。它们主要是关心代码质量和可维护性的软件专业人员的指导方针。
React 不是面向对象，但这些原则背后的主要思想可能是有帮助的。在本文中，我将尝试演示如何应用这些原则来编写更好的代码。
在前一篇文章中，我们讨论了单一责任原则。今天，我们将讨论 SOLID 的第二个原则: 开闭原则。
本系列其他文章 如何应用 SOLID 原则在 React 中整理代码之单一原则 什么是开闭原则？ Robert c. Martin 认为这个原则是面向对象设计最重要的原则。但他不是第一个定义这个概念的人。Bertrand Meyer 于1988年在他的《面向对象软件构造》一书中写到了这一点。他解释了开放/封闭原则:
软件实体(类、模块、功能等)应该对扩展开放，但对修改关闭。
这个原则告诉您以这样一种方式来编写代码，即您能够在不更改现有代码的情况下添加其他功能。
让我们看看我们在哪里可以应用这个原则。
让我们从一个例子开始 假设我们有一个 User 组件，其中我们传递用户的详细信息，这个类的主要目的是显示该特定用户的详细信息。
这是一个很简单的开始。但是我们的生活并不是那么简单。几天后，我们的经理告诉我们系统中有三种类型的用户: SuperAdmin、 Admin 等等。
它们每个都有不同的信息和功能。
一个糟糕的解决方案 第一个也是显而易见的解决方案：在组件中包含一个条件，并根据不同的用户类型呈现不同的信息。
import React from &amp;#39;react&amp;#39;; export const User = ({user}) =&amp;gt; { return &amp;lt;&amp;gt; &amp;lt;div&amp;gt; Name: {user.name}&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; Email: {user.email}&amp;lt;/div&amp;gt; { user.type === &amp;#39;SUPER_ADMIN&amp;#39; &amp;amp;&amp;amp; &amp;lt;div&amp;gt; Details about super admin&amp;lt;/div&amp;gt; } { user.type === &amp;#39;ADMIN&amp;#39; &amp;amp;&amp;amp; &amp;lt;div&amp;gt; Details about admin&amp;lt;/div&amp;gt; } &amp;lt;/&amp;gt; } 你知道这里出了什么问题吗？</description>
    </item>
    
    <item>
      <title>理清业务团队开发和业务的关系</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/li-qing-ye-wu-tuan-dui-kai-fa-he-ye-wu-de-guan-xi/</link>
      <pubDate>Sun, 16 May 2021 10:16:31 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/li-qing-ye-wu-tuan-dui-kai-fa-he-ye-wu-de-guan-xi/</guid>
      <description>关于开发是否应该深入了解业务，听到两种我觉得不正确的类型：
「我是开发，我就做好开发就行了，业务交给产品和运营同学」。不懂业务，完全不想了解型。 「懂业务之后就可以跟产品 PK 了，方便砍需求」。懂业务，目的不正确型。 我的观点是要想当一个优秀的开发者，必须懂业务，不是为了跟产品 PK，而是为了预判未来的发展方向，好指导自己写的代码可以适应未来更久的时间。
懂业务，目的不正确型。 作为一个开发，不知道多少人经常会在耳边听到这么一句话：多了解业务，多了解业务。
但是大部分情况下并没有告诉你为啥要了解业务。
可能有些人心里会有这么一个答案：懂了业务可以在需求评审的时候可以跟产品 PK，指出他的需求不合理，然后给出一个合理的方案，这就是你对于业务的价值，然后就可以体现你的业务思考了；另外对于你觉得不合理的需求，还可以砍掉。
这是我听到最多的关于为什么开发要懂业务的观点了，我以前也是这么认为的，但是当我真正的作为一个业务 owner 之后，逼得我不得不去了解业务，我才觉得这个观点不完全对，方向都是错的。
上面观点的核心目标就是跟产品 PK，把产品作为开发的敌人去看待。现在网上很多这样的调侃，产品和程序员是对立的。
在产品的眼里，程序员天生就是爱砍需求。
而在程序员的眼里，会因为不会砍需求被老板教育，不要啥需求都接，要学会砍需求。
实际上，懂业务不是为了去指导产品设计，而是为了预判未来的发展方向好指导自己写的代码可以适应未来更久的时间。
懂了业务之后是去发现前端的“价值点”，不是为了跟产品 PK。。。。
你如果去指导产品做产品，反过来想想如果让产品指导你做开发，那能靠谱吗?
我很赞同玉伯说的专业度的问题，作为开发就是要在开发的专业度上表现出来，效率让产品业务都觉得不可思议。而不是让你的产品、业务能力表现出来让他们觉得不可思议(不是不行，但是这样很难，先把自己专业的搞好再说)。
不懂业务，完全不想了解型。 另外还有一些是基本不怎么了解业务，就喜欢专研技术，这种想法基本是工作年限不超过三年的同学。刚毕业，对业务没有什么感知，觉得做技术的技术才是王道，整天喜欢研究各种新技术，处于一种被动接需求的状态。
这种情况就很容易在晋升的时候无法说清楚业务价值，到底自己做的东西有什么用，给公司带来了什么价值，因为在做需求的时候本来没有去思考过业务价值，所以没办法形成闭环，仅仅只是零散的需求。
实际上，我们应该这样做，在业务的背景之下，我们可以主动的**发现问题、定义问题、解决问题、优化效果，拿到结果。**这才是创作个人业绩的正确路线。
如果不懂业务，怎么将技术放到业务里去？不放到业务里去怎么体现技术的价值？
你不能光讲我做了一个什么东西，这个东西多么多么好，这个业务价值如果没有体现出来，那就是没用的。
总结 上面分析了两种思维模式的差别，以及我觉得正确的思考方向。
作为一个在业务团队的开发者，我们做一件事的时候，需要时刻提醒自己，要想清楚三个问题：
弄清楚，为什么做这件事？做这件事的价值是什么？ 去思考，如何做这件事？ 完成后的产出是什么？明确衡量标准。 你们觉得作为一个业务团队的开发，业务和技术的关系应该是什么样的呢？</description>
    </item>
    
    <item>
      <title>在蚂蚁工作是一种什么样的体验(一)</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/2021-03-13-%E5%9C%A8%E8%9A%82%E8%9A%81%E5%B7%A5%E4%BD%9C%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%80/</link>
      <pubDate>Sat, 13 Mar 2021 14:49:27 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/2021-03-13-%E5%9C%A8%E8%9A%82%E8%9A%81%E5%B7%A5%E4%BD%9C%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%80/</guid>
      <description>大家好，我是桃翁！ 之前有小伙伴留言让我聊聊「希望聊一些在大厂工作是什么体验，想听如何融入，如何适应，如何成长的规划，遇到过的哪些比较棘手的问题和怎么处理的，期待」。
他这里这么多问题，我准备每个问题都写一篇文章来聊，首先咱们要聊的就是「大厂的工作体验」。
身边牛人多 可能很多想去大厂的同学，第一驱动力觉得大厂肯定很多大佬，然后进去了可以带带自己。
其实这句话不全对，也别抱太大希望，进来了可能跟你的想法是不一样的。 我的体感是：前半句是对的，大厂里确实很多牛人，但是不会带你的，或者说不是你想象中那么带。
在阿里这边一个新同学刚进来的时候，会在组内分配一个师兄，来协助你顺利度过试用期。但是不是那种事无巨细的关注你的那种，大部分时间师兄每天也很忙，一个新人来了还要帮你解决问题，所以师兄就会更忙了，所以师兄主要是帮你解答一些问题。
再说说身边其他的牛人，牛可以很多方面的：
比如 学校牛，在杭州这边浙大的比较多，我们组才 12 个人就有三个浙大的，还有在国外上大学的。
网红，可以接触到很多之前只能在知乎、或者一些大会里才能看到或者听说的一些大牛，来了之后就可以见到，甚至面对面交流，每次交流都会受益匪浅，比如我在蚂蚁体验技术部就可以接触到玉伯、偏右这种超级前端网红。
技术牛， 不管是 P5、P6、P7 哪个层级的，你都会发现每个人在一个甚至多个方面技术很厉害，说两个我们组的 P5，工作才一年多，早已经是 React 或者微前端方面的专家了，更高层级的那就更不用说了。
总之，大厂里有非常多的优秀的人，意味着你有很多可以学习的榜样，如果有一些技术上的问题，以前可能只能在开源项目的 issue 上提问，现在你可以通过钉钉甚至直接面对面的进行交流。
但是我还是秉承着一个观点，身边的人优秀，并不意味这自己优秀，也没人会主动带着你变成优秀的人，需要自己主动去跟他们学习，让自己成为别人眼中优秀的人。
做项目成就感强 既然是大厂，不管是员工和用户相对都比较的多，做的东西反馈也会很多，不管是好的还是差的，都能感觉到有很多用户在使用，能感觉自己再为这么多人服务，能获得价值感。
像我现在做的项目虽然是给内部小二(小二就是内部员工)用的，但是每天 UV 也有好几千，PV 也是上百万的，这跟我之前在上家公司做的内部系统就不太一样，之前做的东西不管好还是不好，没有什么人反馈，所以总是在找需求做，做出来也不知道有价值，存在感就比较低。
如果能做 C 端用户的项目，比如像五福、双十一、双十二这种运营活动，虽然过程很艰苦，但是我相信做完了之后一定是满满的自豪感。
做项目的成就感就来自于给自己、给别人带来了价值，能服务别人，如果你感受不到这份价值，这个项目估计不久就凉了。。。
压力大 我以前在蘑菇街的时候每天正常作息上下班，基本没在工作上感受到过压力。
但是在蚂蚁无处不在的压力，有时会把自己压得喘不过气，不过大部分时候会把压力当做动力，努力向前。
一方面来自于项目压力，据我了解，在蚂蚁的业务团队相对于技术团队来说会忙一些。我们组现在主要是做业务，我们这边发布频率基本上一周一个迭代，一个迭代里可能还包含好几个需求，布频率极其高，项目周期又都很紧。
偶尔还有项目紧急到需要倒排工期，就是不管你怎么搞，就是要在某一天上线。
另外一方面来自于周围同事压力，前面也说了，周围的牛人很多，每个人身上你都能发现比自己优秀的地方，比自己级别低的、一个级别的要想着不要被别人超越，比自己级别高的，需要考虑怎么才能跟他们一样优秀。 对于项目压力大的正反馈就是逼着自己去做一些可以提效的技术方案，对于周围同事压力正反馈就是逼着自己去像他们学习，让自己变得越来越优秀。
后记 这次主要聊的是环境和项目上的感受，下一篇会介绍一些关于技术上的一些体验。如果你之前没呆过大厂，你可以聊聊你想象的大厂是什么样子。如果你之前在待过，或者现在正在大厂里，可以聊聊你的感受是什么。
同一个环境可能由于自己的心态不同，感受也会有差别，我只是分享我的感受，希望给你带来帮助。</description>
    </item>
    
    <item>
      <title>桃翁2020年度总结</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/326/</link>
      <pubDate>Sun, 24 Jan 2021 19:19:06 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/326/</guid>
      <description>前言 2020 年真的是不平凡的一年， 疫情夺走了很多人的生命，还夺走了我的工作(公司因为疫情被迫裁员)，所以今年换了工作来到了蚂蚁，在蚂蚁的工作经历跟之前在蘑菇街完全不一样。。。
工作 来蚂蚁这半年我觉得在工作上的成长比我之前在蘑菇街一年半的成长都还多，经历比较丰富。
阿里一直都有拥抱变化的文化，我来大概五个月的时候就换了三个主管，经历了好几次的组织架构变动，我刚进来的时候同组的同事（之前组内大概 12 人）到现在还跟我一组的仅剩一名。
不过随着每一次的变动，我的分工也越来越清晰，从最开始哪里缺人就去哪里，再到负责一块模糊的业务线，再到一个人带着 3 个合作伙伴负责一整个业务线，再到现在有了 3 个正式加 6 个合作伙伴的阵型。
作为整个业务线的 owner 不仅要接需求还要去预测业务未来的走向，这样才能在技术上做好提前的准备，当业务真的来了，才能快速的支持。这个是我在试用期答辩的时候面试官给到我的期望，这个我在之前试用期结束后有写过。
原来我是个业务性选手？？？？
只不过那个时候我只是觉得这个话说得很对，并没有体感，但是当我在负责整块业务的，以及带着一群人在做的期间，作为业务 owner 必须得去思考这些了，因为我们这里业务发展得很快，虽然我们业务团队成员变多了，但是需求也越来越多，所以如果不提前去做一些业务上的预测，技术上的沉淀，当业务发展再快点，需求再多一些我们目前的这些人就消化得很吃力，甚至吃不下，这是我今年非常大的一个收获。
对于这个收获其实我之前想过我为什么可以得到，我刚开始把原因归结到了运气，因为我能有机会负责一条业务线的东西是由于我的师兄以及其他大部分同事都走了，现有的业务只能由留下来的人去承担，所以我当时想到了那些得到晋升或者 375 的同学是不是运气好，可以做到好的业务或者技术。但是又细想如果机会给你了，如果没有把它当机会，而且他这块重重的东西当做负担，或者平常心看待，可能也做不出什么优秀的成果。
但是一件平凡的事情如果交给一个优秀的人去做，大概率还是会做出优秀的东西。
所以最后我得出的结论是运气可以让一个准备好了，有实力的人加速成功，但不会让一个平凡的人获得成功。
学习与写作 当我在准备写总结的时候，我本以为今年读的书(去年 20 本)会比去年要少，没想到今年还略多一点，读完的都有 29 本了，但是我明显能感觉到今年花在读书上的时间变少了，特别是在入职蚂蚁之后，属于自己的时间更少了。
我想可能是渐渐的找到了读书的方法，越读越快了吧。
下面是我今年读书列表：豆瓣主页
在写作方面今年公开文章产量就很低了，只有 13 篇，基本都是上半年写的，下半年入职蚂蚁之后就基本没怎么写了，一方面是因为确实工作太忙了，另一方面需要在公司内部写不少的文档。
文章列表见博客：前端桃园
技术 很遗憾今年对技术没有做什么深的研究，主要是业务太忙，把我对技术的追求抹平了，整天就想着如何能把业务支持下去。
来蚂蚁半年没写过 React，大部分时间写钉钉小程序和支付宝小程序，另外还写了将近两个月的云凤蝶。
在我没怎么接触过小程序前，对小程序有刻板的印象，总觉得小程序限制太多，很简单，没有什么意思，当然也不知道其原理，所以对小程序比较抵触。
但是当我写了两三个月之后，对小程序了解得越来越多，但是另一方面发现自己对小程序了解得越来越少，为什么这么说呢？
当我还没怎么接触小程序的时候可能想到的就只有 小程序的语法是什么样的，小程序是怎么运行的，但是写得越来越久，发现自己以前的视野太小了，整个小程序生态还有很多东西可以去研究，越写越发现自己不会的越来越多，这些不知道反而让我对小程序产生了兴趣，感觉可以有新的东西值得去研究。
比如小程序他是怎么运行的，跟原生、H5 之前的区别在哪里，关联是什么，view 层是怎么渲染的，逻辑部分的 js 是怎么执行的，与客户端，容器是怎么通信，怎么打包的，怎么编译的，编译出来的东西又是什么，怎么发布上架的，以及什么情况下使用小程序技术栈、什么情况下使用 h5 技术栈，等等等，这些没有搞明白的问题深深的让我对小程序产生了兴趣。
所以明年在技术上的一个目标就是深入小程序。
生活 家人 生活方面最令我开心的就是女朋友在 11 月份从上海辞职，来到了杭州，结束了 3 年的异地恋，每天下班后有个人在家里等的感觉真好！
旅游 西安旅游
国庆去西安旅游了，在去西安之前我们还先去南京溧水参加了【咪豆音乐节】。这次是准备得最充分的一次，还做了一些攻略。
重庆 Outing
重庆三峡博物馆
江景：重庆洪崖洞夜景</description>
    </item>
    
    <item>
      <title>原来我是个业务性选手</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/324/</link>
      <pubDate>Sat, 12 Sep 2020 21:22:24 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/324/</guid>
      <description>01 前几天我试用期转正答辩了，老板也给过了，给到我的评价大概是：业务型选手，接下来一两年很关键，如果能够在业务中深入挖掘，会是个好苗子，否则就比较平了。
这个评价其实我还是没想到的，或者说我之前根本没想过结果。
其实我从大学毕业以来，都觉得自己是个**技术型选手，**之前在蘑菇街的时候我也是按照技术路线走的。在蘑菇街的时候工作不是很忙，所以也有时间去研究技术，也乐于分享然后才经常写文章，才做了公众号。
02 不过在我年初的时候，我对技术的追求稍微弱了一点，这是在蘑菇街的时候准备晋升答辩过程中的一些变化。我的前辈呀、主管呀、HR 呀，在我准备 PPT 的期间都不断的给我灌输，你做的东西到底有什么业务价值？
在这期间，我的 PPT 找了好几位前辈包括自己的主管都 review 过，也给他们进行试讲，每次的给到我的建议都会有，要注重业务价值。
之后我的脑海里就深深的有了这么一个意识，技术是为业务服务的，技术的价值源之于业务的价值，而不是技术本身的价值。
所以我在后面的工作中，会更注重业务价值，在做需求的时候不再去追求高大上的新技术，热技术，而是花更多的心思去问这个需求的背景，能解决什么问题，能为用户带来什么价值，能给公司带来什么利益。 **
03 没想到我把这个意识也带进了蚂蚁，在蚂蚁的工作是非常忙碌的，我后面会写文章记录一下在蚂蚁有多忙，但是现在我只想说一点，反正忙到没时间去折腾新技术，注意是折腾不是学习，因为我在蚂蚁做的东西对于我来说，一直都是新的技术，但是没有时间去专研，学习新技术是为了完成需求。
在答辩的前三天我还在跟我的老板说，业务太忙了，没时间写总结了，目前只写了一个总结的目录(可能就 50 个字左右)；老板跟我说，在 9 月 2 号前一定要提交总结，不然系统会自动试用期不通过，在那时我快要崩溃了，项目这么急，哪有时间写总结呀，还要答辩。
真的是抽不出时间来写总结，每天加班到凌晨两三点，回家就想睡觉，根本没精力写。
在答辩的前一天晚上，大概 8 点多的时候，其他伙伴在工作的时候，我就抽了大概一个半小时的样子按照我之前的目录写完了，感觉写出来毫无亮点，看起来就是自己的血泪史。反正就当完成任务了，明天毕竟要答辩了，不可能啥都没有吧，然后写完继续改 bug。
那天我也回去得比较早，大概 12 点回去了。在这个点其实还是有点精力的，我就寻思着，我感觉自己写的总结很 low，没有亮点，给面试官留不下太多的印象。
04 回来之后我就思考怎么才能让面试官觉得我做的东西有价值呢？想了半天没想出来，但是突然想到一个点，我当时不知道这个点该不该讲，但是我很想讲，那就是我现在所做业务的大图。我们整个组都在做一个叫 xx 的项目(应该说是一个很大，很复杂的业务，是很多的项目)，每个人都负责其中的一块，我刚开始来的时候就对这个项目很好奇，因为我完全不能理解 xx 这个项目是一个什么样的项目，是用来干啥的。
甚至在我已经做了两个月的项目之后，我也仅仅只对我自己做的这块了解，对其他的人做的东西不知道有什么关联，但是我还是知道跟我肯定是有关联的，所以其实一直处于一种比较难受的地步，因为我不知道这个项目到底有多大的价值。
直到我在第三个月做了另外一部分的需求之后，我才慢慢的了解了这个 xx 项目到底是个什么样子的，我们的目标是什么，我们要做成什么样子，我们现在已经有了哪些能力。
那几天每天上下班的路上我就在思考这些东西，真的是每天想，后面终于想清楚了每个人做的东西之间的关联，感觉很舒服。
我觉得这个东西对于我来说价值很大，虽然他是纯业务的，或者说根本都不是我一个人做的，但是这真的是我的收获，所以我觉得站在更高的视角去介绍我们组现在做的 xx 业务，我就画了整个业务架构图，包含了我们组每个人所做的业务以及他们之间的关联。
然后就去介绍整个 xx 业务的背景，能解决什么问题，能为用户带来什么价值，能给公司带来什么利益(是不是觉得似曾相识)，最后再去介绍我做的东西在整个大图的意义的时候就很容易了。
在答辩的时候我差不多一半的时间都在讲这个，最后也给面试官留下了深刻的影响，说我提供的视角让他学到了新东西，他之前从来没有这么想过。
05 最后面试官给到我当面的评价也说到了我是一个善于思考的同学，喜欢去专研业务，还有其他的好的坏的评价，已经记不得了。
但是最后老板给我的试用期总评里直接说道我是一个**业务型选手，**这是我没想到的。但是我从他的评语中还得出，我在技术上的研究不够，如果后面我不深入业务的话，技术也没研究，那就真的很平了。
我后面多次思考了一下，我到底应该去做一个业务型选手还是技术型选手呢？我目前的答案是我应该去做业务型选手，因为我的理想是去创业的，感觉业务型选手更适合创业，如果以后想去做 CTO 啥的，还是选技术型选手比较好。
06 想一想你们自己是想做业务型选手还是技术型选手呢？欢迎在评论区说出你们的答案，最好能带上理由。</description>
    </item>
    
    <item>
      <title>蚂蚁、字节、滴滴面试经历总结</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/321/</link>
      <pubDate>Mon, 18 May 2020 12:49:46 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/321/</guid>
      <description>前言 最近两篇面试以及离职相关的文章不容错过哦。
离开蘑菇街后，我最近的一些想法
拼多多和酷家乐面试总结
今年面试还是比较顺的，面了五家公司(酷家乐、拼多多、字节、滴滴、蚂蚁)，都过了。
在文章里我不仅会列出面试题，还会给到一些答题建议，个人能力有限，也不能保证我回答都正确，如果有错误，希望能纠正我。
字节 一面 说一下浏览器缓存
浏览器缓存分为强缓存和协商缓存，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。
控制强缓存的字段有：Expires和Cache-Control，Expires 和 Cache-Control。
控制协商缓存的字段是：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。
cookie 与 session 的区别
Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。
详见：COOKIE和SESSION有什么区别？
浏览器如何做到 session 的功能的。
其实就是考察 http 怎么处理无状态是怎么处理的，具体可见 COOKIE和SESSION有什么区别？里面的答案。
解释一下：csrf 和 xss
XSS：恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。
CSRF：CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。
详见：前端安全面试题
怎么防止 csrf 和 xss
详见：前端安全面试题
跨域的处理方案有哪些
常用的：jsonp、CORS、nginx 代理，完整的大概是九种，可见：九种跨域方式实现原理（完整版）
CORS 是如何做的？</description>
    </item>
    
    <item>
      <title>Mac写作环境搭建</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/319/</link>
      <pubDate>Sun, 10 May 2020 21:35:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/319/</guid>
      <description>前言 写作是我一直都提倡每个人去做的一件事情，也许你是通过写作来进行总结，也许你是通过写作生计，也许像我一样写文章提升自己的影响力，不管怎么样，工欲善其事必先利其器，今天我将两年以来最好用的一套写作软件配置介绍给大家。
在这篇文章中你可以了解到三个工具：
最好用的 markdown 写作编辑器 mac 平台专属的图床工具 选取合适的工具美化排版 写作软件(Typora) 我使用过很多的 markdown 编辑器，bear、MWeb、UIysses、印象笔记等等，每个都号称最专业的 markdown 软件，但是这些软件对于图片的处理都不是特别满足我的需求。
只有 typora，让文字和图片完美的结合在一起，并且支持将文章复制到其他平台。
接下来，我将介绍一下 Typora 吸引我的几个地方：
1. 所见即所得的特性 实时预览，不需要分两栏。
2. 自定义主题。 你可以从官网下载主题，或者自己写主题。
3. 大纲与文章目录。 自动识别标题，展示出目录。
4. 可以方便的将图片自动上传到自己的图床上 大部分的写作编辑器都需要手动的去将图片上传到图床上，然后再把链接写到编辑器来，这样来回切换很麻烦。typora 可以自动识别图片然后直接上传上自己的图床上。
当你把图片直接拖到编辑器，或者说截屏之后复制到编辑器的时候，就会让你选择是否上传图片，点击上传图片就可以直接上传到图床上，然后将链接替换成图床的链接。
你只需要在偏好设置图像的上传服务设置为 iPic 即可，下面我会介绍 iPic。
上传服务这里还可以选择自定义命令，也就是说你可以自己写一个上传图片的 shell 然后上传到自己的图床上，图片处理非常的强大。
5. 可以直接复制富文本格式(包括主题样式)到公众号或者其他支持富文本的地方。 公众号后台排版其实不是特别好用，另外我们程序员往往喜欢写 markdown 而不是富文本，所以就需要一个将 markdown 转富文本的一个工具，typora 在这方面也很擅长。
图片处理(iPic 和 iPic Move) 怎么获得免费图床 对于图床这个东西，我觉得还是用自己的比较好，或者说付费的图床，而不是选用网上一些免费的，比如微博图床，其他网站的图床(比如掘金)，使用别人的图床虽然免费，但是一旦加了防盗链，你想迁移图片就非常的麻烦(我就踩过这个坑)，那么这个时候免费的其实就更贵了。
所以很早我就开始研究怎么能用上专业的，自己的图床，我就发现了七牛云这个良心云服务商。七牛云对于新用户免费送 10 个 G 的空间，你可以将图片通过对象存储的方式存在七牛云里。而且这些图片还是都可以增加 CDN 的。
具体如何去创建自己的对象存储空间，你可以参考官网教程。
有了图床，如何将图片上传到图床上面去呢？在 Mac 下 iPic 就是一个很好的工具。
iPic iPic 是一个 Markdown 图床上传工具，将你的图片上传到你的图床上后，你可以得到一个 markdown 格式的图片文本，然后你可以直接复制到你的编辑器中。</description>
    </item>
    
    <item>
      <title>拼多多和酷家乐面试经历总结</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/318/</link>
      <pubDate>Thu, 07 May 2020 13:17:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/318/</guid>
      <description>前言 离职原因看我这篇文章吧：离开蘑菇街后，我最近的一些想法，然后不得不去找工作恰饭呀。
我目前面了五家公司：滴滴、蚂蚁、拼多多、酷家乐、字节跳动，拼多多和酷家乐基本已拿到 offer，蚂蚁二面完了，滴滴和字节即将三面，我先把我已经面过的面经先总结出来，其他的不管过没过，这周内我都会总结出来，希望能给到正在找工作同学的帮助。
在文章里我不仅会列出面试题，还会给到一些答题建议，个人能力有限，也不能保证我回答都正确，如果有错误，希望能纠正我。
酷家乐 酷家乐是我最早面的一家公司，还没被裁的那周二刚好面完，结果周五就被裁了，可能这就是冥冥之中吧。
面试的部门是工具组，是酷家乐最核心的部门，四面面试官跟我说我面的组是工具团队中的最核心组，会涉及到一些图像相关的技术，比如 Tree.js、WebGL等，所以这个组其实也挺好的，感觉能学到不少技术。
一面(电话面) 你在项目如何优化的
我在简历里面写到了性能优化相关的，所以这个问题。
你做的项目有什么值得说的
基本上就是考察项目的亮点，可以说一些项目难点是如何解决的，或者介绍一些项目中用到的牛逼的技术。
Ts 有什么优势
讲道理所有现在在网上能查到的优势都是得益于静态语言的优势。
type 和 interface 的区别
这是一个高频题，如果考察 TS，这应该是最容易考察的，网上也都能查到相关的资料，但是很可能忽略一个点：type 只是一个类型别名，并不会产生类型。所以其实 type 和 interface 其实不是同一个概念，其实他们俩不应该用来比较的，只是有时候用起来看着类似。
React 事件机制
我觉得需要答的点：
React 为什么要用合成事件 事件机制：注册和分发的过程。这里面至少要说出事件注册都是在元素的最顶层 document 节点上。 参考资料：一文吃透 React 事件机制原理
聊聊 React 的 diff
聊 diff 建议先看看我之前写过的一篇关于虚拟 DOM 的文章：从 React 历史的长河里聊虚拟DOM及其价值，有助于理解 diff 的意义。
diff 的细节可以看我之前写的：详解 React 16 的 Diff 策略
React 优化
可以看之前我写的 React 函数式组件性能优化指南，对于类组件也有对应的 API。
怎么理解闭包
基础中的基础，虽然社招考得不多，但是如果连闭包都理解不了，应该会减分不少。闭包由于在规范里没有定义，所以很多人下的定义不一样，理解的角度也不同，但是自己要有一套正确的理解方式，如果按照我的理解 JavaScript 里面所有的函数都是闭包，因为有全局环境，所有的函数都可以访问全局变量。
节流怎么实现的</description>
    </item>
    
    <item>
      <title>离开蘑菇街后，我最近的一些想法</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/317/</link>
      <pubDate>Thu, 30 Apr 2020 16:19:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/317/</guid>
      <description>前言 被裁之后我就一直在家复习，面试，所以就一直没有写文章，没有太多心思搭理公众号，现在也拿了两个 offer 了，所以开始回到正途。
胎死腹中的 Vue 3.0 Beta 文章 4 月 17 日，早上我收到了浪浪(浪里行舟)的消息，给我发了一个微博消息，尤大在微博上宣布发布 Vue 3.0 Beta 了，然后跟我说这是热点，让我写一篇文章，我就暂停了前一天晚上定时发的文章，准备写一篇详细介绍 Vue 3.0 Beta 所发布的东西。
所以当天我早早的来到了公司，希望在上班前能搞定，然后就开始翻阅 vue-next 的文档以及草案，想从根源去探究 vue 3.0 Beta 能给我们带来什么。
没过多久，在我们技术部的群里有人就 @ 了所有人，让我们去看下邮件，邦哥(化名)发了一封邮件，每个人都要看一下。
我由于还在写文章，收集资料，就没那么快去看邮件，不一会儿，突然安静的 9L 就开始叽叽喳喳，议论纷纷，这时我感觉应该是一件大事儿。
我就迅速打开了邮件，第一段就描述着公司在今天要优化 140+ 的人，第二段描述着公司的核心方向，直播和品牌特卖，在这个时候，我已经能意识到，我可能要被优化了，也许我们组绝大部分人都会被优化，因为我们组基本是做内部系统的，跟核心业务极大的偏离。
我也加入到他们叽叽喳喳的氛围中，放下了手上所有的事情，和旁边的同事讨论着裁员的事情。
被裁 大概在十一点左右的时候，我左手边的一个应届生小声的说，我凉了，HR 让我去 11 楼一趟，然后我将这个事情传达给了我们的一个小群，以及我对接的后端，并询问他他们组的情况。
没想到聊着聊着，他跟我留下了一句，我中了，我先上去了。
接下来就眼睁睁的看着身边的人一个一个的都被喊上去，从工作一年的到两年的(包括我)，再到四年的，以及更多的。
到中午的时候，我们组只留下一个人没沟通了，是一个工作了四年多的老员工了，就坐在我旁边，他很慌，因为大家都拿着赔偿金(n+1.5)，他也想有。
一直等到一点、两点、三点、四点，五点，他放弃了，成为了我们这层楼我们组唯一个留下的。
后面就开始办理离职手续，交接项目，晚上我们整个前端到旁边的修舍酒店进行聚餐，虽然离别时悲伤的，但是被裁的人拿到高于常规的赔偿，是幸运的。
这次裁员对于应届生来说是最惨的，他们工作年限不久，不到一年，对于社招来说，是非常的吃亏的。工作年限不够，而且整个大环境来说又不好，现在又被裁没有工作，大公司很少会招工作年限这么短的，去小公司又有可能被压价。
唉，不想写这些消极情绪的了，在这被裁的两周里，空闲下来我也思考了很多，接下来说一些我的见解，希望能给到大家帮助。
定时更新简历 之前我在知乎上看到一个 HR 的回答里面说到，不管你跳不跳槽，其实都可以定时更新自己的简历。
我是比较赞成他的说法的，我倾向于半年更新一次简历，因为在更新简历的过程中你会去思考，去总结你在之前的这半年里，你做了什么有价值的东西，有没有什么亮点。
一旦发现在这半年里没有做出什么成绩，那么你也许需要在后面的时间里调整自己的工作方式，思考为什么没有值得写在简历里面的东西，然后给自己定目标，做规划，尽量在半年后可以有一些亮点可以跟别人吹。
多做总结 总结这个东西，其实每个人都会觉得应该做，但是很少人真正的去执行，也许是因为太忙，也许是因为懒，也许是因为觉得他不重要。
我相信很多人会有这样的感觉，当别人问你做的项目有没有什么难度，在做的时候遇到了什么困难，以及怎么解决的。你会感觉都已经做出来了，感觉没什么难的了。
其实在我看来，这其实就是没有及时的总结导致的。
我的建议是当你遇到难题并解决之后，马上记下来，因为这个时候是你最有动力，也是最清醒的时刻，一旦你想后面有空了再记，那么基本上就是不会记了。
另外就是每个项目完结之后也需要进行总结，遇到的问题，项目的架构，项目的价值等等，这些东西是以后可以跟面试官聊项目的资本。如果不记下来，当你写简历的时候，很可能会把关键的地方忘掉。
忙一点的公司挺好 可能对于这一点很多人会觉得我政治不正确，觉得理想的工作不应该是朝九晚六，到点下班么。
但是我最近在观察那些发展得好的企业，加班都比较严重，比如阿里、腾讯、字节跳动、拼多多等，当然这些公司都会给你更高的薪水。
为什么我会绝对忙的公司其实挺好呢？主要是因为公司发展迅速，意味着就会扩大生产，那么就需要更多的劳动力，但是对于招聘合适的人又是一个急不得的事儿，所以留在公司的人可能会很忙，得干超出正常一个人所干的事儿。
这样其实你可以有更多需求做，也许是重复的，也许是新的东西，不管怎么样，一旦你代码写得多，你能更可能发现到别人发现不到的痛点，也会给公司做更多的贡献，其实对于成长是有帮助的。
可能有人会觉得我只是一个打工的，在规定的时间把东西做完，下班时间再去学习，其实这种方式对于大部分人来说不是特别的高效，因为学习这件事其实是反人性的，下班了也许你更多的时间会用于其他娱乐中。
再说一下对于比较闲的公司，也许很多人都想去，比如外企，相对国内的大厂来说要轻松很多，但是闲的公司很容易让人养成懒的习惯，特别是对于工作不久的，一旦养成了懒惰的习惯，就会危害自己一辈子。
我希望这一点不要跟我争论，如果你希望去不忙的公司，你去就行了，也不用说服我。</description>
    </item>
    
    <item>
      <title>理解 JavaScript 中的执行上下文和执行栈</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/315/</link>
      <pubDate>Thu, 02 Apr 2020 16:52:06 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/315/</guid>
      <description>译者序 最近在研究 JavaScript 基础性的东西，但是看到对于执行上下文的解释我发现有两种，一种是执行上下文包含：scope(作用域)、variable object(变量对象)、this value(this 值)，另外一个种是包含：lexical environment(词法环境)、variable environment(变量环境)、this value(this 值)。
后面我查阅了不少博客以及 ES3 和 ES5 的规范才了解到，第一种是 ES3 的规范，经典书籍《JavaScript高级程序设计》第三版就是这样解释的，也是网上广为流传的一种，另一种是 ES5 的规范。
然后我接着又去翻了 ES2018 中的，发现又有变化了，已经增加了更多的内容了，考虑到这部分内容颇为复杂，准备后面再进行总结分享，查资料的时候看到这篇讲执行上下文(ES5 )的还不错，所以就翻译出来先分享给大家。
以后看到变量对象、活动对象知道是 ES3 里面的内容，而如果是词法环境、变量环境这种词就是 ES5 以后的内容。
以下是正文：
什么是执行上下文？ 简而言之，执行上下文是计算和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。
执行上下文的类型 JavaScript 中有三种执行上下文类型。
全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。 Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。 执行栈 执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）的数据结构，被用来存储代码运行时创建的所有执行上下文。
当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。
引擎会执行处于栈顶的执行上下文的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。
让我们通过下面的代码示例来理解：
let a = &amp;#39;Hello World!</description>
    </item>
    
    <item>
      <title>React 代码规范</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/314/</link>
      <pubDate>Thu, 02 Apr 2020 16:51:22 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/314/</guid>
      <description>基本规范 每个文件只包含的一个 React 组件： 联系紧密的组件可以使用「命名空间」的形式； 每个文件中可包含多个纯函数组件。 始终使用 JSX 语法，不要使用 React.createElement 创建 ReactElement，以提高编写速度、可读性、可维护性（没有 JSX 转换的特殊场景例外，如在 console 中测试组件）。 文件规范 组件文件使用一致的.js或 .jsx后缀。所有组件文件的后缀名从.js或.jsx中任选其一。不应在项目中出现部分组件为.js文件，部分为.jsx的情况。
每个存放组件的目录使用一个index.js/index.jsx以命名导出的形式暴露所有组件。同目录内的组件相互引用使用import Foo from &#39;./Foo&#39;;进行。引用其它目录的组件使用import {Foo} from &#39;../component&#39;;进行。
命名规范 文件名：使用大驼峰命名法（PascalCase），如 MyComponent.jsx；
组件命名：组件名称和文件名一致，如 MyComponent.jsx 里的组件名应该是 MyComponent；一个目录的根组件使用 index.jsx 命名，以目录名称作为组件名称；
引用命名：React 组件使用大驼峰命名法（PascalCase）；
高阶组件使用camelCase命名。高阶组件事实上并非一个组件，而是一个“生成组件类型”的函数，因此遵守JavaScript函数命名的规范，使用camelCase命名。
使用onXxx形式作为props中用于回调的属性名称。使用统一的命名规则用以区分props中回调和非回调部分的属性，在JSX上可以清晰地看到一个组件向上和向下的逻辑交互。
使用withXxx或xxxable形式的词作为高阶组件的名称。高阶组件是为组件添加行为和功能的函数，因此使用如上形式的词有助于对其功能进行理解。
带命名空间的组件 如果一个组件有许多关联子组件，可以以该组件作为命名空间编写、调用子组件。 class Form extends React.Component { // ... } class Row extends React.Component {} class Label extends React.Component {} class Input extends React.Component {} Form.Row = Row; Form.Label = Label; Form.</description>
    </item>
    
    <item>
      <title>从两个角度看 Typescript 中的类型是什么?</title>
      <link>/posts/%E8%AF%91%E6%96%87/302/</link>
      <pubDate>Tue, 03 Mar 2020 10:09:33 +0000</pubDate>
      
      <guid>/posts/%E8%AF%91%E6%96%87/302/</guid>
      <description>0. 作者以及原文介绍 作者是 Dr. Axel Rauschmayer，号称”德国阮一峰“，本文原文来自于他的博客：https://2ality.com/2020-02/understanding-types-typescript.html，不熟悉他的可以关注一下他的博客。
1. 每个角度都从这三个问题来解释 以下三个问题对于理解类型是如何工作的非常重要，需要从这两个角度中的每一个角度来回答。
myVariable 的类型 MyType 意味着什么？ let myVariable: MyType = /*...*/; Sourcetype 可以分配给 TargetType 吗? let source: SourceType = /*...*/; let target: TargetType = source; TypeUnion 是如何从 Type1、 Type2 和 Type3 衍生而来的？ type TypeUnion = Type1 | Type2 | Type3; 2. 角度 1： 类型是一组值 从这个角度来看，类型是一组值：
如果 myVariable 具有 MyType 类型，这意味着可以分配给 myVariable 的所有值都必须是集合 MyType 的元素。
如果 Sourcetype 可以分配给 TargetType，那么 Sourcetype 是 TargetType 的子集。 因此，TargetType 也允许 SourceType 所允许的所有值。</description>
    </item>
    
    <item>
      <title>读者问题|关于如何学习的讨论</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/299/</link>
      <pubDate>Mon, 13 Jan 2020 23:23:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/299/</guid>
      <description>一个读者的困惑，我做了简单的解答，希望能对他有所帮助。
## ##1. 如何把一个知识由浅入深的学习？
见问题 2
##2. 那些写技术文章的作者，为什么对某一知识或某一框架理解得那么深入，是如何学习的呢？
我觉得有以下几点：
使用的多，踩得坑多，经验丰富。 花时间深入研究过原理。 思考过这个东西的价值以及为什么会出现(这个点很容易被忽略，我的那篇从历史的长河中聊虚拟 DOM 的意义就是这个点)。 思考过这个东西能给自己的业务带来什么帮助，然后紧密的结合到自己的项目中。 如果你觉得这几个点感觉你都懂，那我问你几个问题，比如你在你们公司想引入 React 来做项目。
问题一：你为什么要用 React？ 问题二：用 React 能带来什么好处？ 问题三：如果用 Vue 或者 JQuery 能行吗？ 问题四：React 适合哪些场景？哪些场景又不适用？ 问题五：你觉得 React 存在的意义是什么？ 问题六：React 有什么缺点？ 问题七：你觉得引入 React 会有什么成本，收益和成本如何进行平衡？ 我想表达的是在学习一个东西，或者说想深入一个知识，不仅仅知道它是什么，怎么用，还要去了解它为什么会产生，能带来什么价值，解决了什么问题。这样在你判断是否引入这门新技术才有充足的理由，否则就是追风，看到这个东西比较火，可能你根本就不需要，然后引入了反而给自己增加负担。
在你想知道它解决了什么问题的时候，可能就会思考为什么它能解决这个问题，然后再去寻找这个答案的时候就会深入他的原理，加上自己大量的实践，慢慢的就成为这个东西的专家了。
##3. 什么时候去接触和怎么去学一些规范文档？
我想你说的规范文档应该是官方文档这种吧，然后下面讨论的都是基于官方文档。
官方文档我一直是把它当做完善我知识体系的东西来看待的，而不是入门教程。毕竟官方文档是给所有人写的，不管你是没使用过的，还是使用过很长时间的，所以就导致大部分的内容都是比较官方的，所以就导致不一定适合你。所以才有了各种各样的教程，因为每个人的所拥有的知识不一样。
另外官方文档也不会告诉你哪个知识点重要，哪个知识点常用，它只会告诉你有这个东西，这些东西都是需要在实战中去得知。
特别是对于 CSS 标准，或者 Javascript 标准这种，不到万不得已是不会去看的，东西又多，又不适合新手阅读，但是在你看到网上有不同答案的时候，就非常适合去看标准，平时就看看书、看看博客、看看视频教程就行。
4. 如何处理网上的技术文章以及实体书？ 我觉得首先要明白文章和书的区别是什么，然后才能正确的去使用他们。
我们一般对书的认知是对知识成体系的介绍，书是比较的全，是对整个知识比较全面的介绍，另外由于写书比较的耗时，所以往往书里面的内容都是晚于知识点出来很久的，比较适合那种很久不会变的知识。
知道了书的特性，那么我们何时需要去读书呢？
我觉得应该是在你想打造或者说完善你自己的知识体系的时候就一定要去读书，特别是像那种《xxx权威指南》这种，就特别的适合用来完善知识体系的。
但是一本书不可能把方方面面讲完，都是会有侧重点的，就拿学习 JavaScript 来说，想学好《JavaScript高级程序设计》又称红宝书、《JavaScript权威指南》又称犀牛书是不应该绕过的，那么这两本书又有什么区别呢，这两本书都很厚，理论上讲得都很全。
这两本书都会把 JavaScript 最重要的东西肯定都是会介绍的，但是红宝书侧重于程序设计，相对来说比较注重实战一点，所以对于原型、继承这种在程序设计方面较多的知识点会用大量的篇幅，然后举很多的例子，这样更利于我们的程序设计。
而对于犀牛书的话他的侧重点在于权威，那么他的侧重点就在于全，要比所有的 JavaScript 的书都介绍的更全，相对来说比较偏理论。
因为每本书都会有自己的特点，就是侧重点不同，所以在看实体书的时候就要看自己需求，如果想提高自己的程序设计能力，就看红宝书，如果想查漏补缺，看看自己是否对 JavaScript 全面了解，就看犀牛书。
其他的书也一样，对于技术书我一般的习惯都是带着目的去看，而不是像一些消费型的书随便翻。
再说说技术文章，技术文章他的特点就是可以做到很新，但是质量参差不齐，而且很容易传播错误的知识。</description>
    </item>
    
    <item>
      <title>你可能不知道的 React Hooks</title>
      <link>/posts/%E8%AF%91%E6%96%87/296/</link>
      <pubDate>Tue, 07 Jan 2020 21:50:00 +0000</pubDate>
      
      <guid>/posts/%E8%AF%91%E6%96%87/296/</guid>
      <description>本文是译文，原文地址是：https://medium.com/@sdolidze/the-iceberg-of-react-hooks-af0b588f43fb
React Hooks 与类组件不同，它提供了用于优化和组合应用程序的简单方式，并且使用了最少的样板文件。
如果没有深入的知识，由于微妙的 bug 和抽象层漏洞，可能会出现性能问题，代码复杂性也会增加。
我已经创建了12个案例研究来演示常见的问题以及解决它们的方法。 我还编写了 React Hooks Radar 和 React Hooks Checklist，来推荐和快速参考。
案例研究： 实现 Interval 目标是实现计数器，从 0 开始，每 500 毫秒增加一次。 应提供三个控制按钮: 启动、停止和清除。
Level 0：Hello World export default function Level00() { console.log(&amp;#39;renderLevel00&amp;#39;); const [count, setCount] = useState(0); return ( &amp;lt;div&amp;gt; count =&amp;gt; {count} &amp;lt;button onClick={() =&amp;gt; setCount(count + 1)}&amp;gt;+&amp;lt;/button&amp;gt; &amp;lt;button onClick={() =&amp;gt; setCount(count - 1)}&amp;gt;-&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); } 这是一个简单的、正确实现的计数器，用户单击时计数器的增加或减少。
Level 1：setInterval export default function Level01() { console.</description>
    </item>
    
    <item>
      <title>2019 个人深度总结</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/295/</link>
      <pubDate>Fri, 03 Jan 2020 17:01:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/295/</guid>
      <description>又一年过去了，2018 年写年终总结的场景还历历在目，写这篇文章之前还专门去看了下 2018 年的年度总结，主要是看自己在 2018 学的东西自己还能记得啥。
印象最深刻的应该是还是函数式编程相关的东西，因为确实在我深入的去接触它过后，我的很多编程思维都被它所影响。虽然在项目中不会去用很多函数式的方式去写，但是函数式的那些特点深深的指导着我如何去设计一个更容易维护的函数，其中一些思维可以见我去年的写 函数式编程，真香。
做个预测：三年之内，函数式编程要火一波，原因是 serverless 的兴起。
回顾了过去，我对今年的整体总结是：输入很多、输出不够。
输入 自我感觉自己是一个焦虑的人，焦虑也许来源与社交(周围优秀的人太多，见了太多比自己年轻或者同龄人)、也许来源于自己见识更多(处于达克效应里面「知道自己不知道」的境界)。
图片来源于网络
如果按照这张图来的话，我现在处于自信崩溃区，不知道自己是否处于绝望之谷，但是希望明年能进入开悟之坡。
从这张图里可以看到，自信程度高也不一定约好，很可能是处于愚昧山峰。
自我感觉自己还算坚强，没有被焦虑或者自信崩溃打败，相信自己通过努力，提升自己的专业知识和能力，总会逃离绝望之谷，所以我今年比以前都更努力的去学习，得到结果是我感觉自己今年在见识上提升了非常的多，见识越多，意味着格局会慢慢变大，格局越大，就越能成功(这只是我自己的人生逻辑)。
虽然在精神上的收获了很多，但是从今年各方面的产出来看，不管是职业还是影响力都没有实质性的进展，但是我没有着急，平时安慰我自己的话就是：还没到爆发的时候，现在一直积累就行。
读书 读书是我今年最满意的一项输入，读了 20 多本书，虽然这个成绩不算好，但是对于我来说是一个非常大的进步，因为我从小就特别讨厌读文字，小说也不例外。现在一年能读 20 多本，差不多半个月读一本，进步非常的大了。
最开始想读书也是自己接触的很多大佬，或者在网上看到一些大佬的文章等，了解到读书非常的重要，所以就开始买书来读，刚开始读得很慢，而且很枯燥，一本书可能要花一个月才能读完，大概读了两个月后，自己养成了读书的习惯了，每天花 30 ~ 60 分钟的时间读书，周末就花多一点，一周就能读一本书。
那个时候成就感就来了，对读书产生了兴趣，然后读书 对于我来说就不算什么难事儿了，反正有大段的空闲时间就会用来读书。
在书的媒介方面我还是比较传统，喜欢纸质书翻书的感觉，所以我读的大部分书都是纸质书，基本每个月都会买 3、4 本书，主要是每个月基本上当当都会搞活动，打 5 折或者满 100 - 50，另外还有满 200 - 30 的券，然后由于我会每个月自费给公众号里的读者送书，正好就一起会买六七本书，差不多 200 块。
下面是我今年读完的书，没读完的没有列出来，明年再继续读，大部分都是纸质书。我目前读书还没有进行主题阅读，基本上都是泛读，涉及的不仅仅是技术书，也有心理学、品牌、历史、理财、个人成长各个方面。
电子书
《实用性阅读指南》三星 《麦肯锡精英高效阅读法》三星 《半小时漫画中国史》1-4 册 三星 《小狗钱钱》五星 《如何有效阅读一本书》三星 纸质书
《现代前端技术解析》四星 《你不知道的 JavaScript(上)》五星 《高效前端：Web 高效编程与优化实践》四星 《重构(第二版)》五星 《React 状态管理与同构实战》四星 《见识》四星 《被讨厌的勇气》五星 《刻意练习》四星 《高效能人士的七个习惯》五星 《超级符号原理》三星 《学会写作》三星 《少有人走的路 4：在焦虑的年代获得精神的成长》四星 《原则》五星 《语言学的邀请》五星 《文明之光(第一册)》五星 打五星的都是我自己读完之后感觉收获很多的，每个人可能感受不同，三星就是我觉得可读可不读的书。</description>
    </item>
    
    <item>
      <title>通过fetch发送 post 请求下载文件</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/284/</link>
      <pubDate>Fri, 22 Nov 2019 17:46:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/284/</guid>
      <description>背景 最近遇到一个下载的需求，由于 url 参数太长(常用的下载方法 a 标签或者 location.href 的方法都是 get 请求，get 请求参数长度有限制)，无法下载，考虑了好几种方案，最终还是觉得通过 ajax 的 POST 方法进行下载，比较容易实现，下面记录实现过程以及遇到的问题。
但是由于 AJAX 并不会唤起浏览器的下载窗口，AJAX设计的初衷就是用来实现异步刷新的，用以改善原始的 form 表单提交刷新页面的问题，那么如何来解决呢？
POST 方法下载实现原理 通过 fetch 请求获取文件，然后利用 Blob 对象来接收处理，在接收到后端返回的文件后，把其转化一下，放入a标签的href中，并触发下载行为。
实现的代码如下：
fetch(url, { method: &amp;#39;POST&amp;#39;, body: JSON.stringify(params), header: { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json;charset=UTF-8&amp;#39; } }).then(function(response) { return response.blob(); }).then(function(blob) { const link = document.createElement(&amp;#39;a&amp;#39;) link.style.display = &amp;#39;none&amp;#39; link.href = URL.createObjectURL(blob) document.body.appendChild(link) link.click() // 释放的 URL 对象以及移除 a 标签 URL.revokeObjectURL(link.href) document.body.removeChild(link) }); 这里需要注意的是要记得要调用 response 的 blob 方法，这样才会返回一个 blob，如果你没用过 blob 的话，可能你以前只知道 json 和 text，其实 response 的 body 还可以转化为 arrayBuffer 和 formData。</description>
    </item>
    
    <item>
      <title>如何对 React 函数式组件进行优化</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/280/</link>
      <pubDate>Tue, 19 Nov 2019 08:32:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/280/</guid>
      <description>前言 目的 本文只介绍函数式组件特有的性能优化方式，类组件和函数式组件都有的不介绍，比如 key 的使用。另外本文不详细的介绍 API 的使用，后面也许会写，其实想用好 hooks 还是蛮难的。
面向读者 有过 React 函数式组件的实践，并且对 hooks 有过实践，对 useState、useCallback、useMemo API 至少看过文档，如果你有过对类组件的性能优化经历，那么这篇文章会让你有种熟悉的感觉。
React 性能优化思路 我觉得React 性能优化的理念的主要方向就是这两个：
减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconction(简单的可以理解为 diff)，如果不 render，就不会 reconction。
减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。
在使用类组件的时候，使用的 React 优化 API 主要是：shouldComponentUpdate 和 PureComponent，这两个 API 所提供的解决思路都是为了减少重新 render 的次数，主要是减少父组件更新而子组件也更新的情况，虽然也可以在 state 更新的时候阻止当前组件渲染，如果要这么做的话，证明你这个属性不适合作为 state，而应该作为静态属性或者放在 class 外面作为一个简单的变量 。
但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？
React.memo 首先要介绍的就是 React.memo，这个 API 可以说是对标类组件里面的 PureComponent，这是可以减少重新 render 的次数的。
可能产生性能问题的例子 举个例子，首先我们看两段代码：
在根目录有一个 index.js，代码如下，实现的东西大概就是：上面一个 title，中间一个 button(点击 button 修改 title)，下面一个木偶组件，传递一个 name 进去。</description>
    </item>
    
    <item>
      <title>在mac上安装XAMPP并搭建 typecho 博客</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/272/</link>
      <pubDate>Thu, 14 Nov 2019 21:45:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/272/</guid>
      <description>在 v 站上看一个自己非常喜欢的博客主题：阿星Plus，但是由于是用 .Net 写的，自己完全不熟悉 .Net，所以就准备自己按照他的博客风格写一份 typecho的主题。
我也没接触过 PHP，在安装环境这一步就把我难住了，历经磨难，最终选择了 XAMPP 来搭建 PHP 环境，在这里记下搭建的过程和遇到的坑。
我刚开始去搜索 「XAMPP 搭建 typecho」，然而由于 typecho 资料太少，根本搜不到，所以选择了搜索「XAMPP 搭建 wordpress」，然后才一步一步的安装好了 XAMPP。
什么是 XAMPP XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。
安装 XAMPP 首先要知道 XAMPP 有两中安装方式：
第一种：OS X的XAMPP是OS X的本地安装程序。它将Apache，PHP和其他XAMPP组件直接安装在OS X系统的 /Applications/XAMPP 文件夹中。 第二种：XAMPP-VM是OS X的虚拟机，它包括Apache，PHP和其他XAMPP组件，并在OS X系统上的基于Linux的虚拟机中运行它们。 这两种方式我都试过，相信我，采用第一种安装方式。
值得提醒的是在 XMAPP 首页下载的是 OS X 的虚拟机的，下载的时候文件名称会有 vm ，要下载安装程序的，要去 Download 里面下载，文件名称会有 installer 的字样。
使用 XAMPP 这里我写的会比较简单，自己随便看看就知道怎么用了。
安装好了进入界面，直接点 Start All就行，如果上图中花框的灯是像我图中的绿色就代表启动成功，失败了就会是红色。
安装 typecho 将官网下载的 typecho 安装包下载下来。 将安装包移动到 htdocs 文件夹下并解压，htdocs 文件夹路径如图，在应用程序 -&amp;gt; XAMPP-&amp;gt;htdocs 访问 localhost/build 即可进入安装页面进行 typecho 的安装。 遇到的问题 1.</description>
    </item>
    
    <item>
      <title>如果解决虚度时光，首先做到要事第一</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/270/</link>
      <pubDate>Thu, 07 Nov 2019 21:51:07 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/270/</guid>
      <description>阅读文章之前你可以花半分钟想想你觉得你自己最虚度的时光是时候？
夸自己 可能在很多人的眼里，我以及算是一个努力、上进的人了，那是因为他们只看到了我努力的时候，没有看到我虚度的时候。
一般在工作日我还是非常的恪守自己的原则，在不上班的时候都会提升自己，比如看书、听课、阅读、写作等方式。跟一般的人比起来更努力的点就是早上我会先学习一个小时，我一般 7 点半就会起床，然后看书或者听课一小时后，也就是 8 点半的时候才会去洗漱，下班回来也很少除了和女朋友每天至少视频半小时外，其余时间用得都很充分(用的方向对不对先不谈)。
虚度 接下来就说到重点了，虚度的时光。
我觉得我最虚度的时光就是周末，本来会有充足的时间来学习，但是当打开电脑突然不知道应该干什么(这个时候非常的难受，经常在这个时候想做人的意义是什么)，然后就去看书，看了一会儿还是会觉得无聊，然后就说打会儿游戏吧，我一般有个习惯就是一直会打到输才会停止，往往经常又是连赢好几把，导致有可能一打就是一上午或者一下午过去了，然后就去做饭吃。
一旦到晚上七八点的时候，那个时候突然又觉得学习的奋劲儿又来了，然后会认真看书，看课程写文章等自己觉得对的事儿。然后就开始感叹自己白天的时间又浪费了，晚上再来补，那我们重庆人的话来说就是：「早不忙，夜慌张」。
为什么 很好奇的是为什么工作了才会出现这种情况，而在高中大学没有出现。
在高中的时候，我们大家的目标非常明确，就是考大学，每天要做的事情就是看书，做题就行，目的很明确，要做的事情非常的清晰，所以不会有这种不知道该干啥的情况。
到大学的时候我长期呆在实验室，每天 11 点才到寝室，然后觉得自己应该放松了，就玩玩手机，聊聊天是应该的，这在我的大脑里是应该做的，到了周末的时候，我也觉得应该放松，所以在放假之前已经给自己订好了周末要做的事情，会出去玩，或者打游戏等。
我觉得我就是没做好《高效能人士的七个习惯》里的要事第一。
有兴趣的话我也可以写写这本书的读后感，这本书是今年我读的书里收益最大的书。
相信要事第一还是不难理解，就是把最重要的事情先做。所以首先我应该找出对我来说最重要的事情，然后我没找出来，或者说我没去认真思考对于我来说最重要的事情是什么，导致我有空闲的时候不知道应该干什么，因为想干的事情太多，导致觉得都不重要，你想想你会不会有过这样的感受。
我再说一种情况，我觉得大部分人也有过这种经历，在工作日的时候想做的事情很多，然后把原因归结为上班太忙，所以在工作日不做，准备打算到周末去做，然而到周末了，往往又由于想做的事情太多，导致最后不做了。
然后我回想我工作以前为什么没有这种状态，感觉每天都知道自己应该干啥，就算是打游戏也知道自己该打游戏了。
如何解决 这些都是没有做到要事第一的第一步，找出最重要的事情。
那么如何找到最重要的事情呢，我觉得一个很好的方法就是「做减法」。做加法谁都会做，想到什么事情就忘自己的待办事项或者大脑里面加就行了，但是这样就会导致要做的事情越来越多，最后太多了，然后都不做了。
如果做减法我觉得可以用《搞定》书中的 GTD 方法来帮助我们完成，相信很多人对 GTD 的印象只是存在于写 Todo List，然后把做完的事情标记为完成。其实这只是其中的一个小步骤，GTD 最核心的思想是想通过工具把事情从我们的大脑里面清空，让我们的大脑能专注做一件事情，而不是在做某件事情的时候，又想到其他事情没做，这样就会分心，效率就会大大的降低。
GTD 会有五个核心步骤：收集、处理、组织、检查、做。其中收集的作用就是把你的想法从大脑清空，通过工具帮你把想法记下来，处理过程就是我们做减法的过程，将一些不重要的东西给丢掉。
如果有兴趣，GTD 后面我专门写一篇文章来介绍，非常有效的一种习惯。
丢掉之后还有一些你需要的做的事情，然后再把这些需要做的事情再去认真思考什么事情是最重要的，然后再去做。
总结 文章写了为什么会有虚度的感觉，然后为什么会产生虚度的感觉，然后结合 GTD 给出了解决方案，希望能给你带来启发。
希望你在留言区里留出你什么时候会最感觉自己虚度了，然后又是怎么去解决的呢？</description>
    </item>
    
    <item>
      <title>如何让 useEffect 只在依赖变化的时候执行</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/271/</link>
      <pubDate>Mon, 14 Oct 2019 21:51:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/271/</guid>
      <description>遇到问题 今天遇到一个 useEffect 的问题，遇到一个问题：在 useEffect 里面发异步请求，然后第二个参数的依赖也是异步请求之后得到的结果，然后就导致最终结果会请求两次 useEffect 里的函数。
const [metaKey, setMetaKey] = useState&amp;lt;string[]&amp;gt;([]) // useEffect1 useEffect(() =&amp;gt; { getServiceCoreIndexParam().then((res: IResult) =&amp;gt; { setMetaKey(res.data.defaultValue) return res.data }) }, []) // useEffect2 useEffect(() =&amp;gt; { getAdvisorIndexTable({ visitdate: props.visitdate, advisorSupervisor: props.advisorSupervisor, comparevisitdate: props.comparevisitdate, metaKeys: metaKey || [] }).then((res: IResult) =&amp;gt; { res.success &amp;amp;&amp;amp; setTable(res.data) }) }, [props.visitdate, props.advisorSupervisor, metaKey, props.comparevisitdate]) 分析一下这段代码，首先在组件 mount 的时候，useEffect2 会调用一次 getAdvisorIndexTable，当 useEffect1 执行完毕之后 setMetaKey 后，由于 metaKey 发生改变，导致 getAdvisorIndexTable 还会调用一次，这很明显是我们不想看到的结果，因为这只是一个默认请求，然而发了两次请求。</description>
    </item>
    
    <item>
      <title>看到这段话，真的觉得现在的读者要求比较高</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/255/</link>
      <pubDate>Mon, 09 Sep 2019 21:35:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/255/</guid>
      <description>最近看到这样一段文字，然后掘金的运营还发了一个沸点，看了心理觉得真不是滋味呀。
图片具体内容如下：
如果你在阅读文章的过程中，觉得有不同意的，请憋住，把文章看完再说。
现在的作者写个文章太难了呀。
写个文章还要被喷写得不好，写得不够有深度要被说没有干货；
写得有深度的又有人说看不懂，这怪作者吗？
咋不怪读者要求太多，自己看不适合自己的水平的文章，自己知道的东西就觉得人人都知道，却不知道在中国随便一个你觉得理所当然的小知识点，或者说常识，都会有至少 1 亿人不知道。
很多人在评论里说现在很多面试文章，或者 list 文章没啥质量，然后获赞很多，然后自己辛辛苦苦的写的干货没人点赞，在这个社会不是很正常么，想想马云工作的强度和在工地里工作的工人相比，工人不努力吗，难道不是辛辛苦苦吗？但是赚钱的差距就是这么大，这个社会就是这么现实，归根到底工人所做的工作价值太少了，为什么有些干货价值少，请继续阅读。
##面试题和 list 文章 VS “所谓的干货”
说说为什么面试题和 list 文章，面试题和 list 解决了什么问题？
为什么会有这么多人习惯给这些文章点赞，我觉得最主要的一个原因是缓解了读者的焦虑，第二个原因是仅仅是为了收藏。
缓解了读者的焦虑
对于面试，肯定是永恒的话题，总想着换个好公司，涨工资，但是自己又太菜，想着有没有什么捷径，想了想，刷面经吧，刷了就等于会了，会了就等于能进大公司了。这种心理就跟买课一样，买了就觉得会了，然后生怕错过什么技术，买了一大堆，结果每个课程就只看了前面的开篇就没下文了，你能说这些卖课的不对吗？是你自己不看，能怪别人么？
然后说道别人发面试题，就想分享给大家，毕竟面试题往往都是对于前端开发来说比较重要的东西，是可以给你不仅是面经方面的东西，而且对于刚入坑前端的来说，不知道应该学啥，什么东西重要，什么东西应该先学什么的一个方向。
收藏
list 愿意点赞的往往是想收藏，然后可能是设计的原因，不管是哪个平台都一样，把点赞这个功能做得特别的容易，而收藏就要繁琐或者说不那么让用户想去点。
然后给大家一个建议，收藏这功能真的比点赞好用，可以对文章进行分类，自己可以梳理你的知识体系，然后建好分类，然后再分类收藏文章，这比起你点赞了，然后后面想去看的时候发现太乱了，又不好找，就给你不看文章找了个借口，导致点赞了一大堆，最终有收获的并不多。
我觉得在收藏这方便来说，个人觉得思否做得比掘金好(思否小姐姐是不是要给我广告费了)。
所谓的干货
干货这个词我的理解就是有价值，如果这篇文章对你有价值，那么就是干货，没有价值，你可能就会觉得是水文。
注意，我这里说的是对你有价值，才算是干货。因为一篇简单的文章，对于新手来说有价值，那么他觉得这篇文章就是干货，对于一个老手来说，几年前都会的东西，那么他可能就会觉得是水文。
所以，上面说到什么「浅谈」、「说说」都是没有干货的理论，根本是个人主观臆断，这些文章对于刚入门的同学来说，可能是带来了非常大的帮助。
注意，绝大部分人是知识的搬运工，传播者，而不是创造者，官网文档上有的东西，如果能用一种一部分人觉得通俗易懂的方式写出来也是有价值的，官方文章是普适的，但并不一定是最好的教程，而一些作者就是知识的传播者，可以理解为老师，把一些枯燥，正统的知识，通过一种针对特定人群的方式传达出来，然后学生能理解，那么就是一个好老师，好作者。这就跟你学牛顿三大定律不是去看他发布的论文一样。
总结
所以我觉得现在这样的面试题和 list 文章，并没有什么问题，有问题的是读者对于『点赞』可能理解得不够深刻以及没有正确的认识面试和 list 文章的价值。然后就是没有绝对的干货，一篇文章对于不同水平的人所得到的的价值是不一样的，当然我也更喜欢稀缺资源的文章，这样能给整个社区带来更大的价值。
声明下，我基本上是不写面试题和 list 文章的，所以我并不是为了自己写了这种文章而强词夺理。
给掘金说的 再给掘金提一点建议把，想让作者给你们带来更好的内容，这确实是双赢的局面。
你们对于用户的非常的关心，这是应该的， 但是，是不是应该给作者一些关心呢？
比如，对于评论的控制功能，对于投诉的功能，我看到有些作者写个文章被喷得很惨，心里真的很为她们难过，但是作为作者，一个删除评论的功能都没有，或者说不允许评论。
一些负面的评论真的会给作者带来很大影响，其实作为作者非常的希望大家友善的提出自己的建议，当有人说一些恶意伤人的话，有时候会影响到他上班工作的心情，甚至退出掘金平台，我已经看到过好几个优秀的作者，由于受不了掘金用户的评论，然后退出了掘金。
或者说除了赞，有一个踩的功能也挺好的，这样读者知道这篇文章写得不够好，然后自己会去改进，而不是一些「键盘侠」进行语言暴力。
作者和读者是一个双向的关系，维持双方的利益才是正确之道，不是作者把文章写的好就能改善整个社区的，反思的不仅仅是作者，用户也应该反省一下。
我见过最好的社区就是 Emacs 的社区，社区文章质量很高，社区里面基本上不会出现「娱乐化」，也没看到过「键盘侠」，也许是 Emcas 太难学了，导致过滤了很多不符合 Emcas 社区理念的人吧，所以 Emcas 社区不管是作者，还是仅仅是个社区的读者，都有非常高的素质，以至于社区环境很好。再次强调，不是作者写得好，社区就能搞得好的，好的作者也可能被读者被迫离开社区。
由于我做公众号，也在掘金写文章，所以和很多的作者进行交流过，非常多的作者会以给读者带来了帮助而激发自己写更好、更多的文章，我觉得用户给到作者的不是意见而应该是建议。这样双方处于和谐、和平的状态，才更有利于社区的发展。
我的看法 说说这位掘金用户说的东西，我相信你的初心是让社区变得更好，您说的也没有毛病，我也很赞同。
不过您是站在道德的制高点去要求作者，要有深度，要有独立思考能力，要有干货等等要求，但是您又没有给作者钱，他并没有义务按照每个人的要求来写文章。
这不就是白嫖要求还多的表现么。难道您说的这些要求，难道写文章的作者不知道吗，别人也许只想写下来做个笔记，好心随便分享给大家看一下。
这就跟朋友请你到他家吃饭，亲手做菜给你吃，然后你嫌弃这个咸了，那个淡了，这个不好吃，那个卖相太丑了，白吃白喝还要色香味俱全。
在掘金这个平台上，除了小册，没人有责任和义务把文章写得要满足所有的读者。如果小册写得不好，那确实应该要求作者改改，毕竟你花了钱，你就是『爸爸』，你就是顾客，顾客是上帝。
所以，我觉得现在社区不仅要控制文章的质量，还要控制社员的质量，比如像之前创建小号来喷京东小姐姐刘小夕，以及小生方勤的，这种文章就不应该出现在首页，这样会给作者带来了巨大的创伤。</description>
    </item>
    
    <item>
      <title>新手学习 React 迷惑的点</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/257/</link>
      <pubDate>Thu, 05 Sep 2019 21:37:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/257/</guid>
      <description>网上各种言论说 React 上手比 Vue 难，可能难就难不能深刻理解 JSX，或者对 ES6 的一些特性理解得不够深刻，导致觉得有些点难以理解，然后说 React 比较难上手，还反人类啥的，所以我打算写两篇文章来讲新手学习 React 的时候容易迷惑的点写出来，如果你还以其他的对于学习 React 很迷惑的点，可以在留言区里给我留言。
为什么要引入 React 在写 React 的时候，你可能会写类似这样的代码：
import React from &amp;#39;react&amp;#39; function A() { // ...other code return &amp;lt;h1&amp;gt;前端桃园&amp;lt;/h1&amp;gt; } 你肯定疑惑过，下面的代码都没有用到 React，为什么要引入 React 呢？
如果你把 import React from ‘react’ 删掉，还会报下面这样的错误：
那么究竟是哪里用到了这个 React，导致我们引入 React 会报错呢，不懂这个原因，那么就是 JSX 没有搞得太明白。
你可以讲上面的代码(忽略导入语句)放到在线 babel 里进行转化一下，发现 babel 会把上面的代码转化成:
function A() { // ...other code return React.createElement(&amp;#34;h1&amp;#34;, null, &amp;#34;前端桃园&amp;#34;); } 因为从本质上讲，JSX 只是为 React.createElement(component, props, ...children) 函数提供的语法糖。</description>
    </item>
    
    <item>
      <title>高级程序员与初级程序员差别在哪里？</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/258/</link>
      <pubDate>Thu, 15 Aug 2019 21:39:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/258/</guid>
      <description>之前在公众号里有个读者给我留言：
请教个问题，公司高职级和初中级，都是写业务代码，那么高职级的价值在哪里呢？
由于公众号回复留言的限制，当时我就简单的回复了如下的几个点：
初级多在写代码，高级多在设计代码； 初级多在解决一个问题，高级多在解决一类问题； 初级多在考虑技术问题，高级还要参与业务上的需求； 初级工程师只管接需求，导致自己忙不过来，高级工程师会砍需求， 用自己得经验告诉产品这个需求不需要，告诉设计师这个交互没必要； 初级工程师可能做完一个项目就完了，高级工程师可能会封装几个组件，整理一个脚手架出来。 还有很多很多，初级工程师和高级工程师差距不仅仅是代码质量上，而且其他能力上，解决问题的能力，抽象问题的能力！
今天有时间，想详细的跟大家谈谈我所遇到的、见到的厉害的程序员，同样是写业务代码，为什么会比初级程序员拿的工资高？
初级多在写代码，高级多在设计代码 一般人可能拿到需求，就开始写代码了，写着写着由于页面功能越来越多，感觉代码越来越复杂，自己都会觉得难以维护了。
我拿我自己举个例子，之前有一次我写完一个页面之后，然后给另外一个同事(可以理解为高级程序员)让他帮我 Review 代码，看到我的代码之后就觉得这个写得不对呀，怎么会这么去设计呢？
然后他给我理了下整个页面应该如何去设计，一个页面分为哪些块，有哪些事件，每个事件应该 dispatch 哪些 action，然后整个模块有哪些数据放在 store 里，哪些模块放在 state 里，当时反正听他理完之后，感觉自己写的代码真的很垃圾，然后花了两天时间把上周写的代码重写了一边。
注意，这里是重写，不是重构，重构是对软件内部结构的一种调转，目的是不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。那么如果保证不改变软件可观察行为呢？就需要写测试用例，保证测试用例能跑通的情况下进行重新构造代码才是重构的第一步，没有测试用例的重构就是耍流氓。
那么如何提高设计代码的能力呢？
我觉得有一个方法对于提高设计代码的能力非常有帮助，那就是采用 TDD(测试驱动开发)。
TDD 的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。 &amp;ndash;来源百度百科
为什么 TDD 会提高设计代码的能力呢？可以看到 TDD 的原理是要在写代码之前就要写测试用例，在写测试用例的时候你必然得去思考你的每个函数，每个模块，每个组件应该如何去设计才能使得易于测试，往往易于测试的代码都比较好维护。
这就可以达到在写代码之前先去设计代码，然后才写代码，也就是先思考，后行动。
我只是说 TDD 可以提高设计代码的能力，并没有说我就特别提倡 TDD，说 TDD 很麻烦，难以实施的人就不要跟我讨论了。
初级多在考虑技术问题，高级还要思考业务上的需求 我们要知道，技术是为业务服务的，没有业务谈技术的好坏都是瞎扯淡！
常常可以看到很多实习生，或者刚来的应届生会吐槽以前的老代码用的框架老，用的技术旧，然后就去改成新的，自己觉得牛逼的，然后没有多个环境测试，发上线就挂了，这种例子很多很多，别说我们公司，就连我们组都出现过好几次这样的情况了。
这种就是只考虑技术问题的，而没有去考虑为什么以前前人要这么写，前人没有用这些东西，难道仅仅是因为那个时候没有新东西，或者说认为前人比你差。
很可能就是他们考虑到了业务上的需求，比如要兼容 IE、或者比如考虑到了有很多用户用 iOS，Safari 不支持 webp ，或者比如考虑到很多用户是低端机，性能不好，不能用一些新特性等等问题。
对于老板来说，他根本不管你用什么新技术，新特性，也许你用了新特性确实让代码更简洁了，但是，但是，但是，发到线上挂了，那么你写的东西就是垃圾，连最基础的稳定性都保证不了，更别说流畅性，高并发。
初级工程师只管接需求，高级工程师会砍需求 经常看到很多初级工程师就是，不管产品、运营甚至后端提出一些需求，他也很友好，只要是需求，他都接，然后整天忙忙碌碌，还经常加班，但是实际上，很多需求做了没有什么价值，也许还有些是重复工作，还把自己搞得很辛苦，这种情况真的很多很多。
然后还有一种情况是有一个产品需求来了，然后 balabala 一顿需求讨论之后，产品给出一个期限，初级工程师满打满算，可能能完成，然后就说能行，结果要么对自己能力估算错误，要么很多突发情况，然后不能按时上线。
而高级工程师基本上不会出现不能按时上线的情况，我思考了几点原因：
会给自己留 buffer，来避免突发情况导致时间的耽搁。 在需求分析的时候会思考每个需求是否有必要，如果有些需求觉得没必要，会和产品讨论，拿出充分的理由将需求砍掉。如果都有必要，然后时间又不太够，会去和产品谈是否能使交互简单一下，一期先出个什么样子，下一期再做完整一点。 对需求的评估以及自己能力的评估更准确。 这里我想要表达，不是所有的需求都是有必要的，不要每个需求都去接。
那么如果来判断一个需求是否应该接呢？
我觉得主要是去思考他背后的价值，为什么要做这个东西，做了能达到什么样的效果，如果产品说不出来价值，或者说产生的价值与你花费的时间不匹配，那么这个需求就是有待商讨的。
初级多在解决一个问题，高级多在解决一类问题 很多初级工程师可能昨晚一个项目就完了，还觉得很 OK 呀，然后也把在项目中的问题一个一个的解决了，按时按量的完成了任务。</description>
    </item>
    
    <item>
      <title>Deep In React 之详谈 React 16 Diff 策略(二)</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/261/</link>
      <pubDate>Tue, 30 Jul 2019 21:42:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/261/</guid>
      <description>文章首发于个人博客
这是我 Deep In React 系列的第二篇文章，如果还没有读过的强烈建议你先读第一篇：详谈 React Fiber 架构(1)。
前言 我相信在看这篇文章的读者一般都已经了解过 React 16 以前的 Diff 算法了，这个算法也算是 React 跨时代或者说最有影响力的一点了，使 React 在保持了可维护性的基础上性能大大的提高，但 Diff 过程不仅不是免费的，而且对性能影响很大，有时候更新页面的时候往往 Diff 所花的时间 js 运行时间比 Rendering 和 Painting 花费更多的时间，所以我一直传达的观念是 React 或者说框架的意义是为了提高代码的可维护性，而不是为了提高性能的，现在所做的提升性能的操作，只是在可维护性的基础上对性能的优化。具体可以参考我公众号以前发的这两篇文章：
别再说虚拟 DOM 快了，要被打脸的
深入理解虚拟 DOM，它真的不快
如果你对标题不满意，请把文章看完，至少也得把文章最后的结论好好看下
在上一篇将 React Fiber 架构中，已经说到过，React 现在将整体的数据结构从树改为了链表结构。所以相应的 Diff 算法也得改变，以为以前的 Diff 算法就是基于树的。
老的 Diff 算法提出了三个策略来保证整体界面构建的性能，具体是：
Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。 基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化。
具体老的算法可以见这篇文章：React 源码剖析系列 － 不可思议的 react diff</description>
    </item>
    
    <item>
      <title>针对华为事件，我思考了四点</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/263/</link>
      <pubDate>Thu, 23 May 2019 21:43:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/263/</guid>
      <description>本来我是不喜欢追热点的，不过今天有个群友在群里发了这样一段话。
结果被我怼了： 后面的我就不截图了，反正我提倡的是，随时我们能做的是好好的提升自己，只有提升自己才是最重要的。
有些人同意我的看法，有些人不同意我的看法，这都不是我今天说的重点，只是这个导火线引发的我的一些思考。
不要让别人的文章限制了你的思维 这是我后来跟那个在群里发文章的那个老哥说的话，但是他也没有回我，这都不重要，重要的是我想表达的观点。
不要让网上的文章限制了你的思维。现在网上很多自媒体都是无脑夸华为牛逼，世界第一，美国傻逼，你转发他的文章代表你就是爱国的。你的这些感受都是作者想看到的，都是作者设计好的，你可以去看现在线上的一些写作课程，理论上都会有一些技巧是如何调动读者的情绪，引发共鸣等。
我不是说这种技巧不对，反而我觉得他写得很棒，他做到了他想要的结果。这样的小编很棒，我也希望我能写出这样的文章，双十万加(阅读量和点赞超十万)。
而是作为新时代的读者，我们不仅应该有爱国情怀，更应该有自己的想法，不要局限于作者的思路，应该以更大的视角，更全的视角去看待问题。
在《少数人走的路》里面就提到一条，思考是需要整体的，一旦你整体的去思考这个问题，就会产生矛盾，有了矛盾，才会使我们更深刻的去思考问题。
所以我们不要无脑的觉得转个文章，留个言这就是爱国，真正的爱国是什么：知道自己的技术不足，好好的搞技术，知道自己能力差，好好的提升能力。这才是支持国家，为国家做贡献了。
**穷者独善其身，达者兼济天下。**我们连独善其身都没做到，就有一股兼济天下的冲动。我还是之前在我看 996 那篇文章中提到的，一般人我们能做的就是好好的提升自己，等你有能力了，有钱了，给贫穷山区盖个小学，给慈善基金捐点钱这就是算开始兼济天下了。
另外一个群友发表了一个观点，我觉得还是有点用吧。
连马云这种等级的人都觉得自己的事儿忙不过来，何况一般人呢？
最后，如果想有更大的视角去看待华为，可以看看这些文字，视角不同，也许会改变你现在的想法：
任正非回应美国封杀：不要煽动民族情绪，不能狭隘认为爱华为就用华为手机 重磅！任正非最新万字访谈，回应关于华为的一切 | 深网 真的，老爷子的这番采访我特别的佩服，建议每个人看个一两遍。
不要总想着自己能得到什么，而是你能给公司(其他人)带来什么好处 这点我是在任老爷子采访里面这段话突然想到的。
可以看到，华为之所以这么牛逼，不是靠每天员工们 965 ，上班划划水，喊喊口号就能这么牛逼的，都是加班加出来的，一般人有他们辛苦吗？虽然别人公司顶着那么好看的光环，都是员工们努力、奋斗，用汗水换的。
很多人就是，又想公司强，又想工资高，又不想加班。当你站在公司外的角度的时候，又希望公司强，能抵制一切风险，工资高。但是作为员工，又不喜欢加班来使公司更强，总希望做受益者而不愿意去做点事情。
我们在与别人合作的时候也是这样，在去和别人合作的时候，请教别人问题的时候，别人能有什么好处呢？没有好处为什么要帮你呢？他又不是你的父母，无条件帮你解决一切能解决的事儿。
合作都是一个双赢的事儿，不要总想着占便宜，占便宜的事儿百分之百干不久的。
很多人在问问题的时候也是有问题的，本来群主有个技术交流群，不在群里问，非得去私聊群主(我已经听到很多群主抱怨过这个问题了)，不知道是因为觉得群里问效率低，怕浪费时间，还是觉得自己问的问题蠢，怕被别人嘲笑。其实这都是不太好的一种做法，不然群主创建交流群来干啥呢？不就是想大家一起交流，别啥事儿都问他么。
如果你是觉得问问题怕浪费时间，那别人回答问题就不花费时间吗？如果你确实着急，那你二话不说，红包先上，肯定有效。别上去就是：“在吗；有空吗”，这会体现一个人不会用微信聊天。
我在一个星球里看到这样一段话：
和别人交流时，先搞清楚一个问题，这是交流还是请教，如果要谈的话题，你已经掌握了 90%的知识，这个叫交流；如果不到 90%，这个叫请教。无论哪种，都会花费别人时间。所以无论是否对你有帮助，都应该首先发红包。 我在之前的文章也说过，发红包不是因为回答的人差你这点红包，而是这是一种礼仪，知道你是麻烦了别人，表示一点心意。
不要想着总能说服别人 有这么一个故事：孔子的有一个弟子有一天跟一个人争论，争论啥呢？一年是三季还是四季的问题，然后这个弟子说服不了那个人，然后就带着他找孔子，弟子把事情说清楚了之后，孔子最后说的是一年只有三季。后来弟子就很疑惑，一年不是有四季吗，为什么你要跟他说三季？孔子就说，他一年只有三季了，你还跟他争论什么。
我当时在群里说了这么一段话，然后就有一个小伙伴不同意我的观点。
后面想了想，我也没跟他争辩，有可能我是错的，也有可能我是对的，我想了下，我没办法说服他，我就没有回复他。
我没有说这个小伙伴就是孔子故事里面那个三季的人，而是想表达当一个人所掌握的知识跟你差太远的时候，你没办法去说服他，他也没办法说服你，这个时候自己持有自己的观点就好，慢慢的，时间长了，学到的知识多了，见识广了，就能判断对与错了。
不要轻易相信别人的结论 吴军老师在得到课程《硅谷来信》里说过：科学是用来怀疑的，而不是用来信仰的。科学看重的是方法和过程，而不是结果。另外，科学的结论也未必等于正确的结论。
你可能会说，不是说不要轻易相信别人的结论，为啥你就觉得吴军老师说的这个话就是对的呢，岂不是和你说的互相矛盾吗？
我相信吴军老师说的结论，是因为他在课中所分析的逻辑，举的例子令我信服。所以我才相信他的结论。具体逻辑可以看《硅谷来信》的第 36 封信|科学的结论未必是正确的。
所以，我上面说的结论，也都有可能是错的，就连科学家得出的结论都有可能是错的。那我们应该怎么办呢？
我们在看有观点的文章的时候，应该注重得出观点的逻辑是否正确，而不是直接去判断观点。观点这种东西人人都能说，我说明天股票会涨，他说会跌。但是，说出一个合理的解释，这就不是每个人都能做到的。作为一个合格的读者，我们应该有自己的思想，自己的判断逻辑，而不是一味的去接收观点。
然后随便我们扯到学技术吧，我们在学习框架的时候，所有的大牛都会推荐你去学习框架、库的原理，而不仅仅是 api。原理就是上面说道的底层逻辑，而 api 只是最终的一个结果。</description>
    </item>
    
    <item>
      <title>每个前端工程师都应该了解的图片知识</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/264/</link>
      <pubDate>Mon, 20 May 2019 21:44:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/264/</guid>
      <description>前言 随着web的发展，网站资源的流量也变得越来越大。据统计，60% 的网站流量均来自网站图片，可见对图片合理优化可以大幅影响网站流量，减小带宽消耗和服务器压力。
有时候你花大力气去配置 webpack 使打包体积减少，不如好好优化几张图片，这篇文章就是让你明白如何选择正确的图片，并且让你明白这么多图片格式，在什么场景下使用什么格式，如果想看答案，那么直接滑到文末看图即可。
我的更多文章可以看 GitHub博客,
基本概念 在进入正题之前，先聊聊一些图片相关的基本概念。
一张照片（位图）不断放大之后，会看到一个个小格子，这些小格子，叫像素。
一个格子（像素），在计算机中，用二进制来表示，使用的二进制位数越多，像素的色彩就越丰富。
举个例子，如果一个像素用一位二进制数表示，能有多少种颜色呢？
两种，一个二进制位，要不放 0（表示黑色），要不放 1（表示白色）
下图展示了一个像素二进制的位数最多可以展示多少种颜色。
在对图片有了基本的了解之后，接下来对图片进行分下类，有利于理解各种格式图片的特点。
根据图的类型分类 点阵图(位图) 矢量图 位图(点阵图) 位图，也叫做点阵图，像素图。构成点阵图的最小单位是像素，位图就是由像素阵列的排列来实现其显示效果的，每个像素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个像素，我们可以改变图像的色相、饱和度、透明度，从而改变图像的显示效果。
前面介绍中的那种不断放大会有小格子的图就是属于位图。
常见的比如：jpg、png、webp等，我们平时遇到的大多数都是位图。
矢量图 矢量图，也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一幅矢量图的时候，软件对图形对应的函数进行运算，将运算结果图形的形状和颜色显示给你看。
无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同(不失真)。
常见的就是 svg 格式的。
根据压缩分类 无压缩。 无损压缩。 有损压缩。 无压缩 无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。BMP 格式就是其中之一。
有损压缩 指在压缩文件大小的过程中，损失了一部分图片的信息，也即降低了图片的质量，并且这种损失是不可逆的，我们不可能从有一个有损压缩过的图片中恢复出原来的图片。
常见的有损压缩手段，是按照一定的算法将临近的像素点进行合并。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸。其中的代表是 jpg。
无损压缩 在压缩图片的过程中，图片的质量没有任何损耗。我们任何时候都可以从无损压缩过的图片中恢复出原来的信息。
压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸。
png 是其中的代表。
小结 使用有损压缩处理图像，是去除某些像素数据，无法找回原图。 使用无损处理图像，是对像素数据进行压缩，可以找回原图。 常见的图片格式解析 GIF 关键词：无损压缩、索引色、透明、动画
GIF(Graphics Interchange Format) 的原义是“图像互换格式”，是一种基于 LZW 算法连续色调的无损的基于索引色的压缩格式。其压缩率一般在 50% 左右，它不属于任何应用程序所以几乎所有相关软件都支持它，公共领域有大量的软件在使用 GIF 图像文件。
GIF 是一种无损压缩，所以它只是对像素数据进行压缩，其实 LZW 算法只是一个压缩数据的算法，如果你懂哈夫曼算法的话，可能就比较好理解压缩数据是怎么回事儿了。
GIF 的特性是帧动画。</description>
    </item>
    
    <item>
      <title>中肯的看待 996</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/267/</link>
      <pubDate>Wed, 03 Apr 2019 21:46:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/267/</guid>
      <description>最近 996.ICU 太火了。我本来不太想蹭这个热点，因为我的观念与很多人可能不相同，所以担心被骂，最近有读者问我为啥最近没有更新，最近我在准备晋升的事儿，所以也没怎么准备技术上的内容，但是对于 996 这件事儿上，我最近还是有很多想法，跟大家交流下吧！
后面我会将最近晋升的一些心得总结出来跟大家交流一下，毕竟涨工资呀，所以希望对大家有帮助。
一、反对 996 的本质原因 为什么要反对 996，说到底，就是钱给的不够。
这句话可能说到了心坎里去，咱们来理一理这个逻辑。
如果，发工资不按照一个月一个月发，不按照一天一天的算，而是按照小时、或者分钟、甚至秒来算，你会不会愿意每天多工作一阵子。 加入你现在工资每个月 10000，那么每天的日薪差不多是 480 左右，一天八小时，时薪就是 60。你每多工作一小时就可以多得 60 块，如果你不是三和大神(不知道三和大神的搜索一下，不然你可能不太好理解)的话，你大概率不会只工作 8 个小时。
所以，我觉得说到底，反对的就是企业搞 996，加班不给加班工资导致的问题。
对于头条，阿里这样的企业，虽然知道他们加班很严重，但是工资高呀，所以很多人拼了命的想去。
今天我在小道消息里看到这样一个观点，加班的时候不愿意加，看到别人拿年终奖拿得多又羡慕；自己体会这句话吧。
二、我的一些观点 讨论完了本质，我再说一下我的一些观点。
**首先声明，我是极力反对 996 的。**但是对于现在很多人的行为不是太赞同，所以写出来跟大家讨论下。
1. 不喜欢就走 在这场革命(说得似乎有点严重了)中，不少人想到终于有机会吐槽自己的公司了，垃圾公司，压迫员工，还搞 996。
对于这种行为我的观点是既然觉得在公司干得不爽，为何不走呢？
心里可能想着：我也想走呀，但是没其他公司要我咋办。
这种想法我感觉是一种弱者的态度，即表现出了自己弱，然后又抱怨现状。这种行为就像这样一群人，整天自己不努力，然后抱怨世界不公平，为什么我的爸爸不是王健林；为什么同一个老师教的，他的成绩那么好；为什么同一个班的，他的工作那么高；为什么一起进公司的，他为什么涨工资。
如果你有能力，不喜欢这个公司的制度，不能忍受 996，选择离开就行了呗。
所以，提升自己，让自己变得更强，不喜欢就走。
2. 其实我们已经很幸运了 作为程序员的我们，其实已经很幸运了，还有假期，还有双休，已经很不错了。有很多行业，根本没有休息，一年可能就只有过年的那几天会放，没错，我爸爸的职业就是这样，建筑工人，他们没有周末，没有节假日。
另外你在外面看到的环卫工人，外面开早餐店，饭店的，有过双休吗？
我说这点其实主要是想表达，我们应该少点抱怨，我们还是不错了，咱们让自己变得更强，多为社会做点有价值的事儿，让更多的人拥有双休，拥有节假日。这肯定不是取去革命能解决的事儿，不是去抵制资本家能干的事儿。
3. 多花时间来提升自己的工作效率 说实话，大部分人工作时间的三分之一都没有为公司产生价值。
这三分之一的时间你可能会早上用来刷下咨询，各大群水一下，看看各大新闻网站等待。也许还会去抽抽烟，跟同事聊聊天，以及有一些时间你无法专心工作等。
当然，不可能有人做到每天都百分之百的投入，但是投入的比例就是人与人之间的差距，这是一个影响效率的地方。
众所周知，在公司级别比你高的，经验比你丰富的，代码敲得比你快，完成任务比你好，这肯定嘛，别人工资拿得也高，所以干活也多。反过来也成立，活干得多，工资拿得高。你给公司创造的价值越大，那么你就应该拿更多的工资，后面我将晋升也会说到这个。
所以我们已经想办法提高自己的工作效率，在一定的事件内干更多的活，那么你就需要提高自己的能力，这样你就能在规定的事件内完成任务，当然就不需要加班了。
可能有人说，公司就是给你的任务是无论怎么做都做不完的，那么这种公司对于资源不合理安排，你可以选择第一点，不喜欢，咱就走。
三、这件事情我思考了哪些？ 我在跟我周围讨论相关话题的时候，我感觉我思考的问题跟他们不同。比如：
为什么这个仓库，或者说这个网站会传播得这么快？在最开始的几十，几百颗 star 是怎么来的？为什么同样类似的项目，godie996(方应杭的项目，地址是：https://godie996.com)没有火起来呢？当时我们讨论了两个原因：一个是各大群的宣传，另一个是 996.ICU 界面做得好看。另外的原因供大家思考，欢迎在评论区给出你的答案。 为什么那么多人不满意自己的公司，而不选择离开呢？ 为什么会这么多公司会搞 996 呢？ 同样是互联网公司，为什么国外的大厂不搞 996 呢？ 等等很多问题我觉得才是我们应该去思考的地方，我们只有去思源，才能从根本上解决问题，从表面现象去解决问题很多时候会走很多弯路。
对于这个我举个例子，古代的铁匠都知道百炼成钢，把铁红了，然后拿出来锤，然后又拿进去烧，反复几次，就会发现做出来的铁具很硬，但是不知道为什么，其实就是因为铁里面融入了炭。所以近现代的就直接在熔铁的过程中加入炭，就不需要反复锤炼了。</description>
    </item>
    
    <item>
      <title>为什么现在面试都是面试造火箭</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/268/</link>
      <pubDate>Sun, 17 Mar 2019 21:47:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/268/</guid>
      <description>文章首发于个人网站：前端桃园
很多人总是抱怨面试官问一些平时不常用的知识点，比如算法呀，网络(TCP)等等，也就是大家常说的：面试造火箭，工作拧螺丝。
但是有没有想过为什么整个前端圈，或者绝大部分面试，不仅是前端，各种职位都是这样呢？难道就没人来解决这个问题吗？
我觉得，事实上，这是一种合理的行为，并不是因为存在即合理，而是本来就应该这样，接下来我以两个方面阐述我的观点。
一、 考验对专业知识的掌握的扎实程度 在张鑫旭的十问十答里的一个问题是，「前端开发基础扎实的标准是什么？」
这里面他对「扎实」的解释我觉得很适合来答这个问题。
「扎」其实可以理解为深度，你可以想象一个用一根针，扎你的皮肤，对一个点的压力，可以让你痛不欲生。
那么如何理解知识的深度呢？
我还是拿前端面试来举例，比如考一个快速排序，很多人就觉得这有什么好考的嘛，平时又用不到，引擎底层已经写好了 sort 方法，什么数量级用什么排序底层也已经实现好了，没必要考了呀。
但是其实面试官并不是想考你快排的代码是如何写的，说实话，花个十分钟，最多半小时，一个快排的代码你肯定可以记住。但是其实考察快排的真正原因可能不仅仅是考察代码，而是考察它的思想，分而治之(分治法)，划分算法的运用。
另外可能会再问你，它的时间复杂度是多少，如何计算等这些问题，这些问题也不是来考你这一个算法的计算，而是通过这一个算法来看你知道怎么算时间复杂度不？以此来引导你为什么快速排序快，为什么同样是分治法的归并排序没有这么快。等等相关的算法方面的知识。
面试官所考察的问题只是各种底层思想的一个运用，通过这个实例应用来考察对底层思想的理解程度。所以很多时候大厂的面试总是从浅入深的问问题，直到把你问到不知道为止。
再谈谈「实」，实则可以理解为满，考察知识的广度。
想象一下什么样的情况你才会说一个东西实，给你一晚装满的米饭，并且还压一压，再放进去一些米饭，直到压不下去了为止，这个时候你会说满满的一晚米饭，很实在。
所以对「实」的理解就可以理解为满，全。
如何来体现你对知识的广度呢，也就是实。
比如可以考察一些你平时不常用的，但是你也许会用到的知识点。比如一些简单的算法和数据结构，链表呀，网络里面的 tcp/ip 协议族呀，函数式编程呀等等，一些 html5 的特性(比如 web-compoennt)等等。
你可能在平时编程中没用到，或者大多数前端工程师平时不会用到，但是这些是基本功是需要知道的，比如 React 源码中就用到一些简单的数据结构，链表(Fiber 树就是用链表的结构存的，是一个单链表，以及里面还有循环列表的增删改查)，如果不知道树可以用链表存，如何对链表进行操作，那么可能你看源码就很成问题。里面还有一些位运算等，位运算平时也不常用吧，但是 fb 的工程师就用它来解决实际问题。
再比如 web-component，这已经是 w3c 提出的一个前端组件化的标准了，我国也有大佬用 web-component 实现了一些库，比如腾讯出的 OMI。
地址： https://github.com/Tencent/omi
所以狼叔在 「2019 大前端技术趋势深度解读」里提到可能他是下一代框架的标准。
我们前端变化得快，新东西也多，如何不跟上时代，多了解(主要了解，不是每个新东西都要去深究，因为你没那么多时间，大多数时间还是要用在平时用得到的地方)一些新东西。跟不上时代，也行就会慢慢的被淘汰，所以现在前端招聘基本上都会需要你会一门框架，不管是 React 、Vue、Angular，这些都是趋势，数据驱动，不再是以前拿起 jQuery 就是干了。
小节 在工作中常用的知识点，那些是最重要的，那么大家都会这些，**如果你不知道点，别人不知道的东西，这些东西比别人掌握得更深一点，面试官为什么要你？**也许你还是个双非（非982、211）。
我觉得在任何领域都适合一个定律，就是「T」字形发展，先把专业搞深一点，然后往两边扩展。
二、醉翁之意不在题 另外面试官也许会考你一些软技能，考你的不仅仅是面试题完成了那么简单。这点注意，越简单的题越不简单(好好理解这句话)。
我拿我自己的经历来举例，之前做小米的笔试题(是那种把题目发给你，两天内做好了发给他)的时候，有一道题是：求最大公约数的题目。
很多人看到这道题觉得很简单嘛，几行代码就搞定了，当时跟我一起做笔试题的几位竞争者也是，他们就写了一个算法。
而我当时想到，我觉得面试官在检查这道题的时候如果看代码还是有点麻烦，所以我就写了一个界面，界面上提供了可以点击的数字，还有输入框，还有几个计算按钮，一个结果框，用户可以通过点击数字，或者在输入框里输入数字进行计算最大公约数，还做了一些错误提示等。
这相当于做了一个应用，一个可以给用户使用的应用，所以最后因为这道题，我被录取了。
我被录取的原因，这些都是进去之后，老大告诉我的，当时很惊讶，竟然是因为这个。
所以之后我就越来越注重用户体验，多一些思考，让别人用自己做的东西的时候更舒服，更方便。
我期望的面试官 声明：我没当过面试官，所以以上内容大多是我思考(猜测)的，也可以用说用一种合理的解释，来解释了现在这种现象。
我期望的面试官是这样的，或者说如果我以后当了面试官我会怎么做。
作为面试官不是把面试者考倒，而是尽量挖掘面试者擅长的地方，然后去打破砂锅问到底的看对擅长的地方研究有多深，考察深度。 在考察的时候先考察广度，再考察深度，从广度的问题中提取擅长的点，然后再问下去。 一些小提示 一般面试官不会因为你某道题没答出来就否定你的。 面试官不喜欢简历上写的啥都会，一问每个知识点都掌握得很浅。 对于平时常用的框架，至少要知道核心原理。 这些是之前我们组面试官在讨论的时候提到的，希望能给大家帮助。</description>
    </item>
    
    <item>
      <title>pm2 使用教程</title>
      <link>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/238/</link>
      <pubDate>Wed, 30 Jan 2019 10:10:00 +0000</pubDate>
      
      <guid>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/238/</guid>
      <description>简介 PM2 是 node 进程管理工具，可以利用它来简化很多 node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。
安装 npm install -g pm2 快速使用 pm2 start app.js 常用命令 启动 参数说明：
--watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。 -i --instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。 --ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如--ignore-watch=&amp;quot;test node_modules &amp;quot;some scripts&amp;quot;&amp;quot; -n --name：应用的名称。查看应用信息的时候可以用到。 -o --output &amp;lt;path&amp;gt;：标准输出日志文件的路径。 -e --error &amp;lt;path&amp;gt;：错误输出日志文件的路径。 --interpreter &amp;lt;interpreter&amp;gt;：the interpreter pm2 should use for executing app (bash, python&amp;hellip;)。比如你用的coffee script来编写应用。 重启 pm2 restart app.js 3.3 停止 停止特定的应用。可以先通过pm2 list获取应用的名字（&amp;ndash;name指定的）或者进程id。
pm2 stop app_name|app_id 如果要停止所有应用，可以
pm2 stop all 停止 类似pm2 stop，如下
pm2 stop app_name|app_id pm2 stop all 从进程列表删除进程 // pm2 delete [appname] | id pm2 delete app // 指定进程名删除 pm2 delete 0 // 指定进程id删除 删除进程列表中所有进程 pm2 delete all 查看进程状态 pm2 list // 或者 pm2 ls 查看某个进程的信息 pm2 describe 0 负载均衡 命令如下，表示开启三个进程。如果-i 0，则会根据机器当前核数自动开启尽可能多的进程。</description>
    </item>
    
    <item>
      <title>发布 react 组件到 npm 上</title>
      <link>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/235/</link>
      <pubDate>Mon, 28 Jan 2019 15:43:00 +0000</pubDate>
      
      <guid>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/235/</guid>
      <description>我发布了我的第一个 npm 组件，一个基于 react 的 3d 标签云组件。在这途中我也是遇到了很多的坑，花在完善整个发布流程的时间远多于写这个组件本身的时间，所以我记录下我觉得一个正常的 react 组件的发布流程
最后记录这篇文章花的时间比我完成整个组件的时间都多，最终希望能给新手带来帮助
在整个发布组件的过程我做了如下几件事儿：
开发组件 编写 Readme 推送到 github，并且把 demo 放到 github page 上 发布组件到 npm 上 开发组件 创建项目文件夹并初始化 npm package ，确保你创建的组件名称没有在 npm 上被使用过， 这里我们用 react-demo 作为示例
mkdir react-demo cd react-demo npm init npm init 是生成初始的 package.json 的命令，在 npm init 的时候，你可以根据你自己的需要进行填写你的组件信息。或者直接使用 npm init -y 采用默认的，后面自己再去修改。
首先安装 react 相关的包：
npm i react react-dom -D 采用 babel 编译相关的依赖：
npm i @babel/cli @babel/core @babel/preset-env @babel/preset-react -D 采用 webpack 做构建，webpack-dev-server 作为本地开发服务器，所以需要安装如下依赖：</description>
    </item>
    
    <item>
      <title>git 之修改 commit 以及 rebase 的使用</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/228/</link>
      <pubDate>Tue, 22 Jan 2019 18:27:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/228/</guid>
      <description>我在提交中犯了一个错误，我该如何解决？
我的提交历史一团遭，我改如何让它整洁？
如果您有过上述问题，那么这篇文章适合您。这篇文章介绍了一个让你成为 Git 专家的主题列表。
如果您不了解 Git 基础知识，请单击此处查看我的 Git 基础知识博客。您必须了解 Git 的基础知识才能充分利用本文。
我的提交中犯了一个错误。我该怎么办？ 情景 1 假设您已经提交了一堆文件并意识到您输入的提交消息实际上并不清楚。现在您要更改提交消息。为此，您可以使用 git commit --amend
git commit --amend -m “新提交消息” 情景 2 假设您想提交六个文件，但是，错误地，您最终只提交了五个文件。您可能认为可以创建新提交并将第6个文件添加到该提交。
这种方法没有错。但是，为了保持整洁的提交历史，如果你真的可以以某种方式将此文件添加到您之前的提交本身，那会不会更好？这也可以通过以下方式完成 git commit --amend：
git add file6 git commit --amend --no-edit --no-edit 表示提交消息不会更改
场景3 无论何时在 Git 中进行提交，提交都会附上作者姓名和作者电子邮件。通常，当您第一次设置 Git 时，您需要设置作者姓名和电子邮件。您无需担心每次提交的作者详细信息。
也就是说，对于特定项目，您可能希望使用不同的电子邮件 ID。您需要使用以下命令为该项目配置电子邮件 ID：
git config user.email “你的电子邮件ID” 假设您忘记配置电子邮件，并且已经完成了第一次提交。Amend 也可用于更改先前提交的作者。可以使用以下命令更改提交的作者：
git commit --amend --author“作者姓名&amp;lt;作者电子邮件&amp;gt;” 注意：仅在本地存储库中使用该 amend 命令。使用远程存储库可能会造成很多混乱 amend
我的提交历史是一团糟。我该如何处理？ 假设您正在处理一段代码。您知道代码大约需要十天才能完成。在这十天内，其他开发人员也将提交代码到远程存储库。
将本地存储库代码与远程存储库中的代码保持同步是一种很好的做法。这会在您提出拉取请求时避免很多合并冲突。因此，您决定每两天从远程存储库中提取一次更改。
每次将代码从远程存储库提取到本地存储库时，都会在本地存储库中创建新的合并提交。这意味着您的本地提交历史记录将会进行大量的合并提交，这会使审阅者感到困惑。
如何使提交历史看起来更整洁？ 这就是 rebase 拯救的地方。</description>
    </item>
    
    <item>
      <title>前端书籍推荐</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/227/</link>
      <pubDate>Tue, 22 Jan 2019 17:34:33 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/227/</guid>
      <description>HTML 与 CSS 《Head First HTML与CSS(第2版)》&amp;ndash;豆瓣评分 9.3。入门真的是经典书籍，手把手教学，丰富的案例让你从 0 开始学前端。 《CSS权威指南(第三版)》&amp;ndash;豆瓣评分 8.5。这本书也是非常的经典了，2007 年的书了，但是无不影响这本书作为 CSS 的经典著作，把原理讲得非常的通透，除了 w3c 标准，算最权威的一本了，毕竟权威指南。这本书都是 css 2.1 的，与张鑫旭的《CSS 世界》可以说是一个类别的，我没看过这本书，但是据我朋友说没有权威指南好，口水话太多，也许是让读者好理解，权威指南这本我是看过的，学 CSS 必读经典。 《CSS揭秘》&amp;ndash;豆瓣评分9.4。神书，47 和 css 技巧让你在面对各种 css 问题的时候游刃有余。豆瓣评分 9.4 ，是 css 书籍中评分最高的了，css 进阶必备。 总结：所以对于 css 来说，《Head First HTML与CSS(第2版)》是入门，权威指南是基础，css 揭秘是进阶，可以按照这个顺序来阅读。
JavaScript 《javascript语言精粹》&amp;ndash;豆瓣评分 9.1。这本书可以在入门之前了解一下基本语法，以及在学习之前可以了解下 JS 里面的精粹以及糟粕，虽然这本书很薄很薄，但是值得反复去读的一本书，当时学习前端半年，一年再回来看这本书会跟你第一看应该有更深刻的理解。 《JavaScript DOM编程艺术(第2版)》&amp;ndash; 豆瓣评分 8.7。本 书在简洁明快地讲述JavaScript和DOM的基本知识之后，通过几个实例演示了专业水准的网页开发技术，透彻阐述了平稳退化等一批至关重要的 JavaScript编程原则和最佳实践。 《JavaScript权威指南》：犀牛书是每个FE都绕不过的一本书，可以先大致通读几遍，也可以把其当作工具书，时时翻阅。 《JavaScript高级程序设计》：红宝书虽然号称高级，但其实是帮助入门的，Zakas大神把概念深入浅出，将JavaScript的语法要点讲清楚明白。小红书配合犀牛书，相互印证，谁读谁知道。 《你不知道的JavaScript 上中下》：这本绝对是神书，让你了解JavaScript不为人知的另一面，把闭包、异步这些讲得很通透。 《ES6 标准入门（第3版）》&amp;ndash;豆瓣评分 8.9。阮老师的书，国内最好的一本 ES6 ES7 ES8 的入门书籍，第三版相对于第二版多了 ES8 的内容，所以也厚了很多。因为现在框架盛行，特别是 React 基本是已经完全拥抱了 ES6 了，还没学 ES6 赶紧补起来，不然要落后了。 《深入理解 ES6》&amp;ndash;豆瓣评分9.</description>
    </item>
    
    <item>
      <title>Mac Brew 常用命令笔记</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/223/</link>
      <pubDate>Wed, 16 Jan 2019 13:12:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/223/</guid>
      <description>简介 Homebrew 是一款自由及开放源代码的软件包管理系统，用以简化 macOS 系统上的软件安装过程。每个操作系统都有类似的，比如 Ubuntu 的 apt，Centos 的 yum。
常用命令 安装 brew ruby -e &amp;#34;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&amp;#34; 使用brew安装软件 $ brew install git 使用brew卸载软件 $ brew uninstall git 使用brew查询软件 有时候，你不知道你安装的软件的名字， 那么你需要先搜索下, 查到包的名字。
brew search /wge*/ 其他brew命令 brew list 列出已安装的软件 brew update 更新brew brew home 用浏览器打开brew的官方网站 brew info 显示软件信息 brew deps 显示包依赖 brew upgarde 更新所有 brew upgarde [包名] 更新指定包 brew cleanup 清理所有包的旧版本 brew cleanup [包名] 清理指定包的旧版本 brew cleanup -n 查看可清理的旧版本包，不执行实际操作 卸载 brew cd `brew --prefix` rm -rf Cellar brew prune rm `git ls-files` rm -r Library/Homebrew Library/Aliases Library/Formula Library/Contributions rm -rf .</description>
    </item>
    
    <item>
      <title>2018 年度总结, 三个角色的转变</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/221/</link>
      <pubDate>Tue, 15 Jan 2019 16:54:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/221/</guid>
      <description>2018已经结束了，总结自己这一年来就是三个角色的转变：自己从一个学生成为了一个社会人，从一个读者变成了一个自媒体人，从一个在校学习者变成了终身学习者。
每一种角色的转变意味着责任的转变，每多一种角色，就会多承担一份责任。角色变得越大，责任也会承担得越大，当然收获得也更大。
技术成长 对于技术成长，我感觉我莫名其妙的就走在了前端的前沿，刚刚在知乎上看到一个帖子2019 前端技术规划该包含什么？很多大佬在规划里面都谈到 Rxjs、Typescript、函数式编程、Flutter、PWA、Node 相关, 然而事实就是这么巧(或者可以说我眼界比较远，偷笑)，在 2018 年我很多都已经接触过了，比如 Rxjs、TS、函数式编程、Node 等。
聊 Typescript(TS) 特别是对于 TS，我在公众号，然后我维护的微信群里早就已经说过，TS 最近会火起来的，没学的赶紧学起来，不知道有多少人听了我的，看了那么多大佬的规划，我更加的坚信了 TS 将会变成未来前端工程师一项必备的技能。
然后对于 TS 的学习，我看过这些东西，我推荐一下，不过对于 TS 我仍然是个初学者，不敢说有多精通，我只在我自己的小项目中用过，没有在公司的项目中使用。
TS 官方文档 技术胖的 ts 教程 TypeScript极速完全进阶指南 深入理解 TypeScript 如果问我使用 TS 感觉是什么样的，我只能说相逢恨晚，就跟 vim 一样，用过之后就像一直用。
聊 Rxjs 对于学 Rxjs 来说，我想说的是，Rxjs 是我学过最难学的一个库了，目前为止没有之一。现在回想起来，要是早点接触函数式编程就好了，如果先是研究函数式编程，再去学习 Rxjs，我相信会轻松 40% 以上。但是目前为止，我并没有拿到真正的生产环境去用过，只是写过一些简单的 demo，然后看过一些资料和书籍，同时也在团队做过相关的普及。
Rxjs 难的就是思维方式以及 api 很多，然后就是由于一些概念不知道为什么要这么设计(很多思想我相信学了函数式编程就会明白了)。
对于 rxjs 的学习看过很多的文章，我这里还是推荐三个我觉得比较全的学习资料。
Rxjs 官网 30 天精通 Rxjs 程墨老师的深入浅出 Rxjs 聊函数式编程 学习函数式编程给我最大的感受就是让我拓宽了我的眼界，突然的就弥补了以前知识体系缺的点。比如对于 compose、curry 这些 js 里面也算一直提及的重要概念，但是总是记了又忘，忘了又记，就算自己手写来实现过了，但是隔了几个月还是又忘了，因为没用过。但是学了函数式编程以后，发现全是这些东西，compose 呀、柯里化呀、部分应用呀，就跟用数组的 map、reduce 这些方法那么熟练，所以，现在闭着眼睛也能写出来，就几行代码的事儿。</description>
    </item>
    
    <item>
      <title>函数式编程里面的基本工具函数实现</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/218/</link>
      <pubDate>Wed, 09 Jan 2019 13:12:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/218/</guid>
      <description>compose 实现 function compose(...args) { return (result) =&amp;gt; { return args.reduceRight((result, fn) =&amp;gt; { return fn(result) }, result) } } pipe 实现 function compose(...args) { return (result) =&amp;gt; { return args.reduce((result, fn) =&amp;gt; { return fn(result) }, result) } } 柯里化实现 function currying(fn, ...args) { if (args.length &amp;gt;= fn.length) { return fn(...args) } return function (...args2) { return currying(fn, ...args, ...args2) } } 部分应用实现 function partial(fn, ...args) { return (..._arg) =&amp;gt; { return fn(.</description>
    </item>
    
    <item>
      <title>群里提问的艺术</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/215/</link>
      <pubDate>Thu, 03 Jan 2019 15:16:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/215/</guid>
      <description>现在互联网发达的时代，大家都会有很多的群，xxx 交流群、xxx 技术交流、xxx开发群、xxx技术学习群等，大家的初心可能都是想交流的，遇到点问题然后就可以在群里问。
然而很多时候你问的问题没人回答；也有时候问了半天还是没找到答案；也有时候当你把问题发出来了，别人正准备回答你的时候，你说知道了；然后刚开始群里很活跃，慢慢的就死了。
其实以上问题，都是大家不想看到的，然而在群里提问是我们加入群的初心，但是很多人做不好，最终导致你的问题无人解答，群慢慢的失去意义。
今天我所谈的就是群里提问的艺术，让你的问题快速得到解决。
我将今天的问题分成以下三部分进行介绍：
提问之前 提问之时，怎么提问 注意事项 提问之前 在群里提问之前首先我们应该做好功课，看自己是否完成以下步骤，否则你的提问将一塌糊涂，大概率得不到想要 的答案。
尝试自己解决 不能自己解决应该准备的哪些 尝试自己解决 尝试自己解决是非常重要的一步，这也是我们能否经过这个问题能够成长的关键所在。
通过搜索引擎搜索：baidu 或者 google(推荐)，搜索结果中前三页如果找不到你想要的信息，就进行下一步吧。对于成熟的开源项目，你遇到的问题，很可能别人也遇到过。这时通过 Google、StackOverflow 等网站的搜索服务，可以帮你快速定位并解决问题。永远记住，地球上的你并不孤单，包括你遇到的问题。 **查阅手册/文档：**确保自己阅读过至少一次官方文档。这样在遇到问题时，如果能回忆起只言片语，就可以再去读一遍相关文档，问题往往也就解决了。 **查阅社区/论坛：**阅读常见问题文件（FAQ）或者开源项目的 issue，或者论坛(类似 react china) **询问朋友：**如果你使用的开源软件，在朋友圈或同事圈里也有人使用，那么抬起你的脚、或拿起你的电话，真挚诚恳的探讨不会遭遇拒绝，而会增进友谊。不要犹豫，你的内心渴望面对面交流，你的朋友也是。 **自检并不断测试：**试自己检查或试验以找到答案。 **阅读源码(这步非必须)：**如果你是程序开发者，尽量尝试阅读源码以找到答案。 经过以上 6 步或者 5 步你都无法解决遇到的问题，那么你确实针对这个问题能力有限，准备去群里请教了，那么在尝试自己解决之后无果，应该做哪些准备呢？
不能自己解决应该准备的哪些 一定要明白自己想要问什么问题：不能自己都说不清自己想要问什么问题，那么群里提问你也问不出什么来。 梳理准备您的问题：要说明之前你都干了些什么。 要用言简意赅的语言：这个是我们作为职场一个必备的技能，说重点，言简意赅。 怎么提问 抱着平和对等的心态，找到合适的途径后，就得静下心来将遇到的问题写成文字。书写文字不是一件简单的事情，我们可以从遵循一些简单的规则开始。
用词准确，问题明确 标题要简洁清晰，要言之有物。
Bad：救命呀/急/跪求，遇到了一个 react 问题，xxx 组件渲染不出来
Good：在使用 xxx 版本的 react ，我操作了 xxx，也写了 xxx，但是 xxx 组件渲染不出来
一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。
描述清晰，信息充足 **准确有效的信息：**描述事实，而不是猜测，如果你想给出你的猜测，一定要先描述事实，给你的猜测一些证据，不然就不要猜测。
**问题表现/内容：**按照时间顺序列出问题症状。问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。
**简单的做过什么尝试：**在描述你做过什么尝试的时候，简单的你描述你做了哪些尝试就行，为什么要这么做其实不是那么重要。
如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。
经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。
玉伯有句话是这么说的：
提问者选择的路本身就是一条崎岖之路，对于要解决的问题，实际上有更好的方式。这种情况下，描述清楚目标，讲清楚要干什么非常重要。</description>
    </item>
    
    <item>
      <title>破坏开发人员生产力的十二件事</title>
      <link>/posts/%E8%AF%91%E6%96%87/157/</link>
      <pubDate>Fri, 23 Nov 2018 18:26:34 +0000</pubDate>
      
      <guid>/posts/%E8%AF%91%E6%96%87/157/</guid>
      <description>今天的文章是来自 medium 的一篇文章，点赞数有将近 1 万 9，所以翻译出来给大家分享一下，有些概念怕大家不了解，所以我放了一些 维基百科的解释。如果有翻译得不是很好的地方，请看原文：https://hackernoon.com/top-12-things-that-destroy-developer-productivity-2ddf0abc190
正文：
很多文章都涉及技术主管和项目经理的角色。我们经常遇到的一个共同主题是如何提高团队的工作效率。但是在你集中精力来提高生产力之前，你可能首先要考虑是什么在摧毁它，以便建立一个可靠的基础。不幸的是，即使 Peopleware 近 30 年前发布，我们也看到许多团队在一些（消极的）显着方式中遭受巨大的生产力损失！
没有人希望程序员在没有计算机的情况下完成工作，但是有很多公司希望程序员能够在不知情的情况下完成工作。这同样不切实际。
因此，让我们深入探讨我们的 12 个阻止您的开发人员“进入区域”并提高工作效率的事项列表。我将尝试从大多数到最不具影响力的列表中优先考虑此列表。随意评论！
如果您想知道这一切是否值得投资，只需考虑开发商的工资。生产力提高10％甚至更多！
中断和会议 在我看来，中断是开发人员的首要生产力杀手。开发人员在中断之前不能轻易回到他们正确的位置。他们需要进入发展的思维模式，然后慢慢追溯到他们离开的地方。这可能需要超过30分钟。中断越多，挫折越多，工作质量越差，错误就越多 - 而且还在继续。 “The more times you trip me up while I’m trying to get started — the longer between each time I’m going to try. If you fill my morning with interruptions — don’t be surprised when the day is unproductive.。” &amp;ndash;A developer on Reddit
大概意思就是说，每次被打断都要重新开始，如果你的一天里经常被打断，那么当你一天没有任何成果的时候，不要感到惊讶。
会议怎么样？会议和中断之间的唯一区别是会议是计划中断，这会使情况变得更糟。如果开发人员在处理任务时知道他们会中断，则他们无法完成任务。因此，如果他们在一两个小时内召开会议，他们将无法取得任何进展，因为大多数工程任务需要更多时间。
As Paul Graham wrote, “A single meeting can blow a whole afternoon by breaking it into two pieces, each too small to do anything hard in.</description>
    </item>
    
    <item>
      <title>不要再说虚拟 DOM 有多快了</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/124/</link>
      <pubDate>Tue, 20 Nov 2018 12:03:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/124/</guid>
      <description>如果你觉得它很快，那么这篇文章可能就是你所缺少的
我经常听到有人在群里，或者在社区里说的一个很严重的错误，那就是说 React 的 Virtual Dom 是以快出名的，比原生 Dom 快多了，啥啥啥的，每次都一两句话说不清楚，所以下次有谁再说 React 是以快出名的，你就把这篇文章丢给他，下面进入正题。
在过去的几年里，你一直在跟踪 JavaScript 社区的发展，你至少听说过 Virtual DOM（React，Vue.js 2，Riot.js，Angular 2等等）。他们承诺（或者更确切地说，他们的宣传）更快的渲染界面，特别是更新，减少麻烦。你很快的上手了使用虚拟DOM的应用程序，这很好。几个月后，您的应用程序现在变得越来越复杂，你可能从用户交互到屏幕更新只需要一两秒钟的更新。你可能会想，这东西很神奇，应该会比 jQuery 快，但是实际上不是这个样子的。
虽然我同意虚拟 DOM 为我们提供了很多便利，但我将解释为什么我认为根据定义，更快的渲染和更快的更新是不正确的。要付出代价，其利益并不是大多数人想象或至少希望的。
要阅读本文，您需要熟悉DOM。理想情况下，您至少可以使用 DOM API。如果你只使用 DOM API 构建东西，你可能不需要这篇文章，但我仍然希望你阅读它并在评论中留下一点评语。
渲染和更新 让我们来看看手动执行 DOM 节点的创建和更新的鸟瞰图。这对于理解虚拟DOM如何工作以及它解决了哪些问题非常重要。
在谈论 JavaScript Web 应用程序时，用户界面的更改通过 DOM 操作发生。这个过程分为两个阶段：
JS 部分：定义 JavaScript 世界中的变化 DOM 部分：使用 DOM API 函数和属性执行更改 性能是根据整个过程的速度来衡量的，但了解每部分的速度也很重要，以便了解要优化的内容。
有两种方法可以创建和更新DOM树的各个部分。
①字符串方式创建
使用字符串既快速又简单，但在更新方面并不是非常精细。对于字符串，JS部分是它如此之快的原因。您可以在几毫秒内创建一段代表5000个节点的HTML。这是一个例子：
const userList = document.getElementById(&amp;#34;user-list&amp;#34;); // JS 部分 const html = users.map(function (user) { return ` &amp;lt;div id=&amp;#34;${user.id}&amp;#34; class=”user”&amp;gt; &amp;lt;h2 class=&amp;#34;header&amp;#34;&amp;gt;${user.</description>
    </item>
    
    <item>
      <title>浅谈未来几年前端的发展方向</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/117/</link>
      <pubDate>Tue, 13 Nov 2018 16:41:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/117/</guid>
      <description>在知乎上看到这么一个问题，觉得很有意思，以下是原提问者的见解
过去五年前端的发展过程基本上是一个工程化的过程,框架和工程化工具层出不穷。
近两年其实发展已经比较迟滞了。
框架方面:基本就是三大框架鼎立的局面,三大框架都在相互借鉴吸收,而且方向各有侧重,未来短时间内我看格局不可能有什么大变化.
工程化工具:基本上是 webpack 一统江湖的趋势,虽然有 parcel 等来小打小闹,但是生态一旦形成,没有革命性的项目是无法取代 webpack 的,而且 webpack 也在进化.
个人认为前面五年是前端生产力提高的五年,工程化使得前端的生产力得到了极大提升,但是现在也基本上是在已有的格局中修修补补了
我谈谈我对前端未来几年的发展方向的看法。
看未来的发展方向，无非就是看现在的解决方案所存在的痛点。
1. 浏览器的性能问题 做 web 前端的同学都知道，和原生的 App 相比，性能一直一个致命的痛点，如果要追求性能，肯定得用原生 App。那么在性能上，未来几年可能是一个方向。
①前端代码编译为字节码
浏览器这几年在 Chrome 的带动下，性能飞速发展，但毕竟其核心原理没有变化，性能始终难以达到原生 App 的水平，这部分是很有可能出现大的变化的，一个可能的方向就是浏览器变成虚拟机，前端代码编译为字节码，通过这种方式来将性能提升一个等级，虽然还是难以达到原生App的水平，但已经能够满足绝大部分应用的性能需求，类似于Java对比C/C++一样。 &amp;ndash;李运华
因为 js 是边解释边执行的，这肯定是要比编译型语言要慢，为了解决解释器的低效问题，大概在 2008 年的时候，提出了 JIT 的概念，它是使 JavaScript 运行更快的一种手段（JIT，内联缓存和隐藏类）之一，通过监视代码的运行状态，把 hot 代码（重复执行多次的代码）进行优化。通过这种方式，可以使 JavaScript 应用的性能提升很多倍。
但是时至今日，还是觉得不够快，所以各大浏览器厂商开始支持 WebAssembly。WebAssembly 是一种新的字节码格式，主流浏览器都已经支持 WebAssembly。
和 JS 需要解释执行不同的是，WebAssembly 字节码和底层机器码很相似可快速装载运行，因此性能相对于 JS 解释执行大大提升。
也就是说 WebAssembly 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行.
他的优点就是：
体积小：由于浏览器运行时只加载编译成的字节码，一样的逻辑比用字符串描述的 JS 文件体积要小很多； 加载快：由于文件体积小，再加上无需解释执行，WebAssembly 能更快的加载并实例化，减少运行前的等待时间； 目前可以编译成为 WebAssembly 字节码有 ：AssemblyScript(语法跟 TS 差不多，)、c\c++、Rust、Kotlin。</description>
    </item>
    
    <item>
      <title>一篇文章搞定 ES6</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/115/</link>
      <pubDate>Sat, 29 Sep 2018 18:12:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/115/</guid>
      <description>JavaScript ES6 带来了新的语法和新的强大功能，使您的代码更现代，更易读。它允许您编写更少的代码并执行更多操作。 ES6 向我们介绍了许多强大的功能，如箭头函数，模板字符串，对象结构，模块等，让我们来看看。
const and let const 是 ES6 中用于声明变量的新关键字。 const 比 var 更强大。使用后，无法重新分配变量。换句话说，它是一个不可变的变量，除非它与对象一起使用。
这对于定位选择器非常有用。例如，当我们有一个触发事件的按钮时，或者当您想在 JavaScript 中选择 HTML 元素时，请使用 const 而不是 var。这是因为 var 会被提升，当不想重新分配变量时，最好使用 const。
// ES5 var MyBtn = document.getElementId(&amp;#39;mybtn&amp;#39;); // ES6 const MyBtn = document.getElementById(&amp;#39;mybtn&amp;#39;); 在上面的代码中，const 不会更改，也不能重新分配。如果您尝试为其赋予新值，则会返回错误。
let name = &amp;#34;Said&amp;#34;; name = &amp;#34;Rick&amp;#34;; console.log(name); // Rick let 可以重新分配并获得新的价值。它创建了一个可变变量。
let 与 const 相同，因为两者都是块级作用域，这意味着该变量仅在其块级范围内可用。
箭头函数 箭头函数非常棒，使您的代码更具可读性，更具结构性，并且看起来像现代代码，而不是使用这个：
// ES5 function myFunc(name) { return &amp;#39;Hello &amp;#39; + name; } console.</description>
    </item>
    
    <item>
      <title>JavaScript核心概念之执行上下文和栈</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/316/</link>
      <pubDate>Tue, 25 Sep 2018 00:52:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/316/</guid>
      <description>桃翁桃翁，问个问题呢，据说 js 里面有个执行上下文，这个概念是个什么东东哦？据说挺重要的，给我科普科普呗。
Emm… 这个概念非常的抽象，简单来说呢，就是 JS 在执行某段代码的时候做的一些事情。
具体做的事情就是定义了变量或函数有权访问的其他数据决定了它们各自的行为(作用域链)。每个执行环境都有一个与之关联的变量对象（variable object),环境中定义的所有变量和函数都保存在这个对象中(变量包括 this、arguments)。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
哇，还是好抽象啊，你能不能画个图举个栗子呢？
在之前说的执行上下文就是解释器在执行 JS 某段代码的时候做的一些事，那么首先我们把代码分个类。
Global 代码：代码第一次执行时默认的环境。 Function 代码：执行到一个函数中。 Eval 代码：文本在eval函数内部执行。 看到这个图相信现在分清楚各种类型的代码，每种类型代码会都会产生执行上下文，我们把 Global 代码产生的执行环境叫**「全局执行上下文」,把 Function 代码产生的执行环境叫「执行上下文」**吧，Eval 代码不考虑。
那我看这个图似乎有很多执行上下文(execution context)，这个具体是怎么来的呢？
全局执行上下文只有一个，而执行环境的话是每次函数调用都会产生一个执行上下文。注意要调用才会产生哦，不调用是不会产生的。
那这个执行上下文基本知道是个什么东西了，那执行上下文栈又是啥呢？
见名知意，执行上下文栈就是执行上下文（包含全局执行上下文）形成的栈嘛。
那为什么要有这个执行上下文栈呢？
浏览器中 JavaScript 解释器是单线程的，这就是说同一时间代码只会做一件事，那么创建这么多执行上下文，又不能同一时间执行多个上下文，所以就必须要有个顺序，这个顺序就是就是先进后出，这很明显就是一个栈结构嘛。
那我就疑惑了，为啥要先进后出，不先进先出呢？
我们分析一下图一的代码，结合上图，首先我们看图 1，解释代码的时候首先创建的就是全局上下文，然后再创建 person 的执行上下文，然后再创建 firstName 的上下文，然后再执行完毕 firstName ，就把 firstName 的上下文弹出，再 创建 lastName 的上下文，然后执行完毕，再弹出 lastName 的上下文，然后执行完 person 的上下文，再弹出 person 的上下文，再执行全局上下文，然后全局上下文弹出。
如下是一张经典的执行上下文栈的图。
默认进入全局上下文。如果你的全局代码中调用了一个函数，那么程序将会进入这个被调用函数的上下文，创建一个新的执行上下文，并把当前上下文放到栈顶。浏览器总是会把当前执行上下文放到栈的顶部，一旦函数执行完成，这个执行上下文就会从栈中移除，返回到栈中的下一个上下文。
这些大概明白了，不过你说在创建执行上下文做的那些事儿，我还是有点迷糊，能再详细说说吗？
那我们首先看点代码：
// 例1 console.log(a); // 报错，a is not defined // 例2 console.</description>
    </item>
    
    <item>
      <title>JavaScript核心概念(1):类型转换</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/105/</link>
      <pubDate>Tue, 07 Aug 2018 10:34:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/105/</guid>
      <description>看到这个是不是有一种想打人的感觉，垃圾 JavaScript，这特么都什么鬼，相信很多人不管是笔试还是面试，都被 JS 的类型转换难道过，相信认真看完我这篇文章，妈妈再也不用担心类型转换的问题了。
原始值到原始值的转换 原始值转化为布尔值
所有的假值(undefined、null、0、-0、NaN、””)会被转化为 false，其他都会被转为 true
原始值转化为字符串 都相当于 原始值 + &amp;quot;&amp;quot;
原始值转为数字
布尔转数字：true -&amp;gt; 1, false -&amp;gt; 0 字符串转数字：以数字表示的字符串可以直接会转为字符串，如果字符串头尾有空格会忽略，但是空格在中间，转换结果就是 NaN。 +&amp;#34; 66&amp;#34; // 66 +&amp;#34; 6 7 &amp;#34; // NaN 原始值到对象的转换 null 和 undefined 转对象直接抛异常 原始值通过调用 String()、Number()、Boolean()构造函数，转换为他们各自的包装对象 对象到原始值的转换 对象转为布尔都为 true 对象到字符串 如果对象有 toString() 方法，就调用 toString() 方法。如果该方法返回原始值，就讲这个值转化为字符串。 如果对象没有 toString() 方法或者 该方法返回的不是原始值，就会调用该对象的 valueOf() 方法。如果存在就调用这个方法，如果返回值是原始值，就转化为字符串。 否则就报错 对象到数字 对象转化为数字做了跟对象转化为字符串做了想同的事儿，不同的是后者是先调用 valueOf 方法，如果调用失败或者返回不是原始值，就调用 toString 方法。 补充。一些常用内置对象 toString 方法和 valueOf 的转换规则 toString 相关 valueOf 相关 == 运算符如何进行类型转换 如果一个值是null，另一个值是undefined，则相等 如果一个是字符串，另一个值是数字，则把字符串转换成数字，进行比较 如果任意值是true，则把true转换成1再进行比较；如果任意值是false，则把false转换成0再进行比较 如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的 toString 或者 valueOf 方法。 js 核心内置类，会尝试 valueOf 先于 toString（可以理解为对象优先转换成数字）；例外的是 Date，Date 利用的是 toString 转换。非 js 核心的对象，通过自己的实现中定义的方法转换成原始值。 + 运算符如何进行类型转化 如果作为一元运算符就是转化为数字，常常用来将字符串转化为数字 +&amp;ldquo;2&amp;rdquo; // 2 2+false // 0 ```</description>
    </item>
    
    <item>
      <title>拥有自己的知识体系，形成自己解决问题的方法论</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/104/</link>
      <pubDate>Fri, 03 Aug 2018 16:15:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/104/</guid>
      <description>前言 最近在星球里群里都有小伙伴说道自己对未来的路比较迷茫，一旦闲下来就不知道自己改干啥，今天我这篇文章就是让你觉得一天给你 25 个小时你都不够用，觉得睡觉都是浪费时间。 今天我谈的就是关于【构建知识体系，形成自己解决问题的方法论】，这个话题以前我在给在校准备找工作的同学的几个建议这篇文章中谈到过，但是没有将如何去构建自己的知识体系，这次将深入这个话题进行探讨。
什么是知识体系 无论是大到一个星系还是小至一个原子，其本质都是一个个的系统。 那我们如何来掌握这个系统呢？通过“框架”来简化对系统构成元素以及元素间有机联系。因此有目的地运用“框架”来思考、学习，能够让我们更全面、更快速、更深入地分析、解决问题，以及更高效地学习新知识和技能。
简单来说，知识体系就是一个系统构成元素以及元素之间的有机联系的简化体现。
知识体系的重要性 没有完整的个人知识体系框架，即使你在学习单个知识点的时候理解力和速度高于一般人，但你整体的学习效率依然会很低。原因如下：
对知识的理解就不深。大部分知识点之间是有联系的，缺少了完整的知识体系框架，你就好似失去了知识间联系的地图，对知识的理解就不深。平时我们在遇到问题的时候不知道怎么解决，然后问了下大佬给你说用啥，然后怎么用之后，你就发现我知道这个知识点，但是没想到可以这么用。 比如以前刚去实习的时候，遇到一个跨域问题，因为后端的数据是早就稳定了的，我只是要去拿几个接口的数据来做点东西，那么我本地调试的时候由于域名是是 locahost，而后端是 xxx.duokan.com, 所以就会有跨域问题，当时我就问我老大我要用代理来解决这个问题吗?他就跟我说你加一条 host ，把 xxx.duokan.com 绑定到 127.0.0.1 就行了，因为我当时知道 host 这个东西，所以就 get 到他的点了，但是由于知识点没有成系统，是散的，就根本想不到 host 和跨域有关系。
**陷入在被动学习当中。**没有完整的个人知识体系框架，你只能是碰到什么问题就被动地去学什么，零散而无系统，从而不自觉地陷入在了被动学习当中。这就跟我在文章的开头提到的小伙伴一样，刚开始还能被动学习，然后就不知道学什么了。 一旦你形成了知识体系，你就知道自己那些地方要补，那些地方暂时可以不补，就可以主动学习去查漏补缺，就不会再迷茫了，因为你会发现你有太多太多遗漏的东西，根本学不完。
**知识整体积累的速度下降。**知识之间是相关联的，不同的人在经历同一段工作或上同一堂课时会因为知识体系框架的不同，从而导致了不同数量级的经验吸收。 知识体系的好处 知识体系 可以方便地 给出所学知识的 地图全貌。在学习过程中给人进度反馈。 梳理知识体系，可以提炼出知识的主干网络，方便知识的调用。 知识体系提供了可拓展性。新学知识可以有规律地添加在原有体系之中。 知识体系为知识的关联提供的指导，发掘知识点之间的关联，正是创新的核心。 把孤立的知识点关联起来，是避免遗忘的重要手段。 其实知识体系和解决问题的方法论是相辅相成的，在自己解决问题的时候，会用到知识体系的东西，知识体系的形成，也有部分是通过解决问题来添砖加瓦的。
怎么构建自己的知识体系 对于构建知识体系和很多方法论差不多，收集、整理、输出（即思考过程）。
**收集知识点。**现在是互联网很发达的时代，收集知识点，已经完全不是一个问题了，可以通过微信公众号、得到、视频网站、博客、社区等各种路径获取知识，你可以讲这些知识点收集起来后面进行整理，但是我提倡是先看再收藏，而不是收藏了等有空再去看，不然就会造成收藏栏里发现自己收藏了一大堆，然而由于太多就不知道看哪个，最后就不看了。 **整理知识。**整理知识是一个为输出做准备的，在整理的过程你已经有一定的思考了，会建立自己的知识分区，将你认为相似的知识点归为一类，慢慢你也会将你的知识库变得更加丰富。 **输出。**输出是来巩固知识的最佳方法，也许你通过自己的大脑想，觉得很简单，感觉自己会了，其实想通过头脑去想，去检验是否已经掌握了，对于绝大部分人来说都是不可能的，因为一般人的大脑都是无法深入到很多层以及思考全面，但是可以通过训练去让自己思考得越来越深入，越来越全面。 这话可能说得有点抽象，咱们举个例子来说，大家都知道围棋很难吧，难的是什么，下完每一步棋之后可能的结果太多了，而那些大师就是可以预测下别人下一步，甚至下好几步别人会下的棋子来推测自己下的这步棋下在哪里比较好，而新手是往往做不到的，而像柯洁这种20就拿世界冠军的，也许就是因为他对围棋的天赋，天生对围棋就有很好的大局观，加上自己努力。
这上面只是谈到了为什么我们不能用大脑来检验自己掌握知识的程度。所以我们可以通过自己的嘴，来给别人讲明白；或者通过写文章站在读者的角度，把自己讲明白。只有能给别人讲明白的东西，才是你真正掌握的东西。
通过画思维导图来把知识体系形象化。 选择思维导图的软件可以从知乎这个问答里面选择自己喜欢的，合适自己软件。有什么免费的思维导图软件可以推荐？ - 知乎 这是以前流传的一篇 WEB 前端工程师的一篇思维导图，也可以说是作者的知识体系，我在这里不评价好与不好，因为每个人的技术栈都不同，但是我们还可以针对这个进行细化。 比如我们针对我们前端重要的一块 JavaScript，就可以再进行细分， Javascript 需要掌握基本类型、函数、对象、内置对象、DOM、BOM等知识，然后函数要掌握闭包、作用域、this等，对象要掌握原型、new这些等等。
我就不再扩展了，根据自己的知识形成一个知识体系，然后再解决问题的时候就很容易根据自己的知识体系来解决问题，比如可能你遇到了跨域的问题，你从你的大脑搜索整个知识体系的时候，就可以知道跨域有哪几种方法，然后每种方法的适用场景是什么。
在形成自己的知识体系的过程中，你就知道自己对哪些知识了解，哪些知识不了解，然后你就会花时间去补充自己不了解的知识，渐渐完善自己的知识体系。
在形成自己的知识体系之后，你面试就比较胸有成竹，兵来将挡水来土掩。
你的知识体系就像一张网，面试的过程就是来检验你这张网漏洞有多大的过程，而学习的过程就是就像是给这张网空隙给编织细一点，你的最终目的就是使你这张网的空隙越来越小。
一些小要求 需要有一颗爱学习的心。 需要做一个善于总结的人。 需要是一个有执行力的人，不然列了很多知识点，不去查漏补缺，没鸟用。 关注桃翁，关注前端桃园，有问题随时跟我交流。（最后一条纯属扯淡） </description>
    </item>
    
    <item>
      <title>毕业记—我的大学无憾了</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/100/</link>
      <pubDate>Sat, 07 Jul 2018 16:47:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/100/</guid>
      <description>如果玩抖音的同学，我相信对上面这个图片并不陌生，在六月份的时候疯狂刷这个，但是当时并没有任何感觉，直到我那毕业的那天，提起背包离开学校的那天，我才真正的感受到，我要离开学校了。
自己已经不是一个学生了，熟悉的学校，熟悉的班级，熟悉的同学，熟悉的老师，这次，真的说再见了。
还没来得及跟给我传授过知识老师，陪了我四年的大学同学，以及实验室的学弟学妹们好好的说再见，就提着行李，背着书包离开了学校。
在走的那天，突然想到，那些给我传道受业解惑的老师，那些跟我一起学习上课的同学，那些跟我在实验室辛苦奋斗的都学弟学妹们，也许我们以后就见不到了，莫名的一股泪意席卷而来，包括我现在写这篇文章也是这样，这也行就是人与动物之间感情的差别吧。
天下无不散之筵席，想给那些没有好好道别的人说，咱们有缘再见，以后我帮得上忙的随便找我。
之所以在题目取【我的大学无憾了】，主要是因为三件事儿。
**找到了一份满意的工作。**虽然我没能去得了我最想去的腾讯，也因为个人原因没有去实习了半年的小米，但是在现在的蘑菇街工作我还是挺开心，很满意这里的工作氛围以及人文环境。 在大学中找到了心爱的女朋友。 都说程序员比较宅，很难找到女朋友，还好我运气好，在毕业之前找到了心爱的她。 拿到驾照。 大学有时间真的建议把驾照考了，以后工作了时间成本很高。 夸夸自己 我在学习上说是一个学霸呢，但是自我感觉并没有怎么花时间去学习上课的内容，大多数时间都花在专业课上，准确的说是花在敲代码上。
为啥又说是个学霸呢？因为拿的奖状还是挺多的，四年里，拿了两次甲等、一次乙等(跟甲等的最后一个绩点只差 0.1)，大四由于没课，只有一个实习，不知道老师咋打的分，后来没有拿到。
然后在其他方面参加的比赛比较多，各种程序设计大赛，数据库设计大赛，以及优秀班干部等等，估计 20 多张奖状，最后毕业前还去申请了校级的优秀毕业生和市级的优秀毕业生，没想到都通过了，市级优秀毕业生咱们一个院也才 5 个名额，这个时候只想对自己说【优秀】。
吐槽下自己 在这里想吐槽自己的主要是体重，总结下来就是【肥了】。
刚入大学的时候我只有 114 斤，作为一个 174 的男生来说，那还是比较瘦的了，想想那个时候自己肚子稍微硬一下，还能看到几块肌肉呢，大一的时候比较闲，没事儿就出去大大篮球，然后对新事物比较好奇，到处跑啥的，运动的比较多。
到了大二的时候，涨到了 122 左右，因为大二进了学院的创新实验室，从此没有了双休，没有正常的节假日，没有了没有课就是玩的时间。如果早上没有课 8 点 40 之前就得到实验室，晚上一直要干到 10 点 40 才能回寝室，每周要上六天班。每天三点一线，寝室、教室、实验室，周末休息的那天就想着要好好打打游戏，放松下，也没有出去玩，导致体重增加，肚子肥肉增多。
到了大三同样也如此，绝大部分除了睡觉的时间都是在实验室，很少出去运动，只要在体育课的时候才能好好的运动，直到大三结束的那个暑假，已经 126 了，但是还是没有意识到问题的严重性，感觉还是很正常，也不胖。
大三结束的那个暑假，我去小米实习了，虽然在北京消费很高，但是总是吃得很饱，几个玩得好的每周都要出去吃好的，结果越吃越胖，直到有一次去吃完火锅回来在旁边的称称了一下，把自己下了一跳，已经 135 了，那个时候才来北京两个月，竟然涨了 9 斤，准备开始减肥了，然而并没有坚持下来，但是尽量在注意，直到我实习半年再回学校 138 了。
回到学校已经是大四了嘛，就在学校做毕业设计，在学校吃的稍微差点，我也尽量控制自己的食量，现在以及只有 132 了。
结语 希望自己离开了社会，该变的要变，不该变的别变。比如不要忘记初心而随波逐流，既然选择了做程序员这个行业，目前这几年就应该有工匠精神，把技术专研深，专研透，以后看自己的意愿或者社会的发展再看应该干什么。
要该变的是该变自己还是学生的身份，作为一个工作人，应该对工作精益求精，尽量不要犯错误，大学的时候犯点错误还能接受，在公司里犯了错可是要付很大的代价的。
最后感谢大学陪我走过的这些人，可能有些人只是我人生中的过客，但是也给我的人生增添了一份色彩，感谢你们。
那些在大学里面给过我帮助的人，我会永远记住的，【滴水之恩，涌泉相报】。
我希望今天我以学校为荣，以后学校以我为荣。
致我的大学以及青春。</description>
    </item>
    
    <item>
      <title>Javascript 是最好的语言，不服来辩</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/95/</link>
      <pubDate>Thu, 24 May 2018 17:03:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/95/</guid>
      <description>看到这个标题相信很多人就要开始跟我争论了，PHP 才是最好的语言，那就请原谅下，你说是就是，我们来看看就知道了。
有一条 Atwood 定律：any application that can be written in JavaScript, will eventually be written in JavaScript
翻译一下就是：任何可以用 JavaScript 来写的应用，最终都将用 JavaScript 来写
要是没看到过这句话的人可能又要开始说了，Atwood 是谁，他说最终会就会啊。
那我们来了解一下他，说那些多少年的编程经验啊，这些都没啥用，只要说一点，就能知道这个人也不是等闲之辈，他是 stack overflow 的联合创始人，还是牛逼吧，如果你说你不知道 stackoverflow，那么对不起，那么我们不能做朋友了（开玩笑的，不知道的去了解下吧）
Javascript 可以做什么 1. Web 前端 相信这个这个是毫无疑问的，在 Web 前端的地位目前是没有任何语言能撼动它的霸主地位。 2. 后端 Nodejs Node.js 是一个 Javascript 运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl 开发，实质是对 Chrome V8 引擎进行了封装。Node.js 对一些特殊用例进行优化，提供替代的 API，使得V8在非浏览器环境下运行得更好。
使 Javascript 走向了服务端，这使得 Web 应用仅用一种语言即可完成。
3. 桌面应用 代表 Electron ，还有 Node-webkit 、heX
Electron 是由 Github 开发，用 HTML，CSS 和 JavaScript 来构建跨平台桌面应用程序的一个开源库。 Electron 通过将 Chromium 和 Node.</description>
    </item>
    
    <item>
      <title>给在校准备找工作的同学的几个建议</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/91/</link>
      <pubDate>Tue, 22 May 2018 12:23:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/91/</guid>
      <description>了解 vim 养成 git 规范 学深比学广更重要 拥有自己的知识体系，形成解决问题的方法论 了解 vim Vim 被誉为&amp;quot;编辑器之神&amp;quot;，这可不是虚的。
在我用了 vim 半年之后，我建议我身边的每一位程序员都去学习 vim 。
因为一旦你学会了 vim 的操作，你就像中了毒一样，你会讨厌鼠标，讨厌在你敲着敲着键盘，突然又要去移动光标，因为把手从键盘移动到鼠标上的时间远远大于手指在键盘按键的切换。
而且你会希望在所有的编辑器上都装有 vim 插件，不管是 vscode，还是 idea，还是 emacs；不管是自己的电脑还是别人的电脑；不管是敲代码的编辑器还是用来看网页的浏览器。
还好，所希望的都有，每一个可以装插件的编辑器都有 vim 插件，甚至浏览器也有 vimum。
当你真正习惯上了 vim 以后，你会迫不及待的想要一个机械键盘，因为你敲代码大部分时间都用在了键盘上，鼠标已经不再那么重要了。
机械键盘推荐红轴，青轴和茶轴虽然自己敲着很舒服，手感很好，但是比较影响其他人，键盘声太吵了，黑轴就不考虑了，码字太累了，不适合程序员。
我个人用过青轴和红轴，青轴给我的感觉就是码代码是一颗一颗的，听着那声音自己觉得很舒服，敲代码很有感觉。
而红轴给我的感觉就是敲代码的时候你会忘记你手上的键盘，给我一种手、键盘合一的感觉，把精力完全集中在码代码上，感受不到敲键盘的感觉。
最后说的就是先学 vim 的基本操作，然后装个插件在你现在的编辑器上练习就行了，不需要直接用 vim 编辑器。
因为你直接用 vim 编辑器，作为一个新手，不会配置插件，快捷键等，没有提示，没有高亮。你在写项目的时候会很痛苦，你就用你熟悉的编辑器高亮，代码提示这些是你以前搞好了的，所以实际应用起来难度小很多。
为了推荐更多人程序员学习 vim ，我还自己写了一篇入门文章，有兴趣的可以看看。
我周围的人，只要是用 vim 敲过代码的，从没有人说过用 vim 敲代码不好用而放弃用的，只会对 vim 爱得越来越深。
Git 规范 Git 作为我认为最优秀的版本管理工具，那是程序员的利器，必须用得游刃有余。
而我今天要说的不是怎么用好 git，如果需要可以留言给我，我后面写一篇或者一个系列。
我想说的是规范，不要以为 commit 随便写就行了，其实 commit 的规范程度一部分体现了你这个人做事的态度，是否端正，严谨。
我拿我在 某米工作的时候举个例子，我有个朋友那组的有个学姐，她的 commit 很随意，完全不能体现她提交代码的内容，比如，哈哈；放假了，好开心；bug；也不说是什么 bug，导致我那个同学根本不知道她提交了什么代码。</description>
    </item>
    
    <item>
      <title>ES6之路之模块详解</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/88/</link>
      <pubDate>Mon, 14 May 2018 17:09:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/88/</guid>
      <description>简介 何为模块 一个模块只不过是一个写在文件中的 JavaScript 代码块。
模块中的函数或变量不可用，除非模块文件导出它们。
简单地说，这些模块可以帮助你在你的模块中编写代码，并且只公开应该被你的代码的其他部分访问的代码部分。
为什么要使用模块 增加可维护性：由于每个模块都是独立的，每个人写的代码是不会相互影响的，在维护代码的时候很好排查是哪个模块出错。 可复用性：在日常的开发中，特别是大点的项目，代码的可复用性就更重要了，也许你会用复制粘贴的形式，但是直接一个 import 命令就可以搞定，岂不快哉。 避免命名污染：在 javascript 脚本中，所有的 js 文件的顶级作用域创建的变量，会被添加到共享的全局作用域，这就会导致不同的人开发的代码可能会有相同的变量名，导致变量名污染。 如何使用 导出模块 导出模块所用的命令是 export。
前面也提到一个模块就是一个 javascript 文件，在这个模块中定义的变量，外部是无法获取到的，只有通过 export 导出的变量其他模块才可以用
最简单的导出方式就是在声明的变量、函数、类前面加一个 export
// export1.js // 导出变量 export let name = &amp;#39;桃翁&amp;#39;; // 导出函数 export function print() { console.log(&amp;#34;欢迎关注公众号：前端桃园&amp;#34;); } // 导出类 export class Person { constructor(name) { this.name = name; } } // 私有函数 function privateFunction () { console.log(&amp;#39;我是私有函数，外部访问不了我&amp;#39;); } 注意：
被导出的函数或者类，都必须要有名称，意思就是说不能用这种方式导出匿名函数或者匿名类。 privateFunction 函数，没有加 export 命令，被当做这个模块的私有变量，其他模块是访问不到的。 除了上面那种导出方式，还有另外一种</description>
    </item>
    
    <item>
      <title>桃园周刊 2018-5-14</title>
      <link>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/87/</link>
      <pubDate>Mon, 14 May 2018 14:25:07 +0000</pubDate>
      
      <guid>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/87/</guid>
      <description>如何更好的编写 async 函数 虽然 async/await 方式来处理异步请求，已经是比较非常好的方式了，但是有时候新手会乱用导致性能堪忧，这篇文章作者总结了他在项目迁移中更好的编写 aysnc 函数的方法。
实现双向绑定 Proxy 比 defineproperty 优劣如何? 双向绑定其实已经是一个老掉牙的问题了,只要涉及到 MVVM 框架就不得不谈的知识点。
可以实现双向绑定的方法有很多, KnockoutJS 基于观察者模式的双向绑定, Ember 基于数据模型的双向绑定, Angular 基于脏检查的双向绑定,本篇文章我们重点讲面试中常见的基于数据劫持的双向绑定。
深度剖析：如何实现一个 Virtual DOM 算法 本文会在教你怎么用 300~400 行代码实现一个基本的 Virtual DOM 算法，并且尝试尽量把 Virtual DOM 的算法思路阐述清楚。希望在阅读本文后，能让你深入理解 Virtual DOM 算法，给你现有前端的编程提供一些新的思考。</description>
    </item>
    
    <item>
      <title>三板斧使你走上人生巅峰</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/81/</link>
      <pubDate>Fri, 11 May 2018 14:32:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/81/</guid>
      <description>在我目前的认知里，我觉得未来有三个技能是需要掌握的，分别是：写作、编程、理财。我相信如果这三个技能都掌握了，我相信你里财富自由之路已经不远了。
想要走上财富自由，主要看你的「睡后」收入，就是在你睡觉的时候还有的输入，比如你录视频卖、写书、做自媒体写文章、理财等等，程序员如果增加「睡后」输入，请看 Stromzhang 的 这篇文章 。这些都会让你在你睡觉了之后还有收入，跟你上班出售自己的时间相比，你花在这些能增加「睡后」收入的时间可以重复卖这些时间。
比如一个作家花一年的时间写了一本书，可以畅销十年；那些做自媒体的写出一款爆文，到处转发，也可以流行好多天。
所以如何增加「睡后」收入，才是通往财富自由之路的关键。
第一板斧：写作 在那么多的只能加睡后收入的方法里面，为什么我选择了写作？
因为写作是大多数人都可以参与进来的，不需要有太多的专业性技能，而且操作方便，在任何地方都可以写，没有时间空间的限制。
李笑来在他的财富自由之路里面也说过，写作是通往财富自由的必备技能。
下面简单介绍几种写作的好处：
1. 表达能力 写作可以锻炼你的表达能力，因为写作其实就是在把自己所想的用文字表达出来，如果你能通过文字清晰的表达出来，那么我相信通过语言表达出来也不成问题了。
一旦你的表达能力得以提升，那么在人际交往的时候可以清楚的表达自己的观点。与老板沟通的时候可以清楚的把自己所干的活表达出来，让老板知道你的工作量，你用你的时间和工作能力，减少了老板的时间，他才会感激你；与同事交流清楚表达自己的观点，可以让同事们觉得你是一个有条理，很理性的人，等等例子，一旦你表达能力提升了，你的人际关系不会差。
2. 记录世界记录你 「记录世界记录你」是快手的广告，在这里借用一下，很适合给写作打广告。
快手也是日活上亿的一款APP，快手用视频可以记下你生活的点点滴滴，并且与其他人分享。我们用写作可以记录下生活的点滴，可以记录你的日记，以后可以留给你老了之后回忆；可以记录你的随想，让你可能会忘记的东西持久化；可以记录下你学习的笔记或者举一反三的知识，来加深你对知识点的理解……
你可以用写作记录下整个你所出的世界，以及你整个人生所经历的事儿，所想的想法，所学到的知识。这不就是记录世界记录你吗？想想是不是一件很酷的事儿
别想了，开始写吧！
3. 钱，快到兜里来 对于赚钱我相信大家都特别感兴趣吧。
很多人也许误以为只有作家才能通过写作来赚钱吧！那么你就少知道了一个赚钱之道。
你可以通过运营公众号来赚钱，说说三种运营公众号赚钱的方式：
流量主 当你的公众号达到 5000 关注人数的时候，就可以开通广告服务，广告大概一次点击 1 块钱，原创能达到 1.5 元 软文推文 当你的公众号有一定影响力之后，一般就会有一些培训机构来让你帮他写软文打广告。希望大家看到喜欢的公众号有这种广告，不要抵触，有收入才有动力输出。 营销 如果你有一些付费专栏，或者知识星球，或者付费的视频课之类的，也可以做营销。 当然还有很多理由驱使我写作，我就列了几个我觉得对我影响比较大的方面，希望大家早早加入这个圈子，早点财富自由。
第二板斧：编程 作为一个程序员的我，肯定编程对于我来说至关重要，但是为什么鼓励全民学编程呢？
我鼓励大家学编程，但是没鼓励大家都去当程序员。外面都说程序员是『钱多人傻死得早』，可见程序员是多么辛苦的一门职业，其实无论哪门职业，只要你想赚更多的钱，就得花更多的时间。
但是我觉得每个人都应该学点编程，理由如下：
1. 学会一种思考方式 编程可以帮我们完成工作，但没有明确的实用性，重要的是我们把它看做思考的镜子，学习如何思考，你思考的问题清晰与否，对错与否，把代码敲出来运行一下就知道了。
学习编程会叫你如何思考，就像学法律一样，学法律的人未必都成为律师，但法律教你一种思考方式。
2. 编程可以培养冷静和逻辑化思维 要知道程序行为的对错，都是计算机运行错误，不会被个人意志左右，这让你冷静下来思考你赋予给计算机的算法是哪里错了。
在软件的世界里，每个细节都是环环相扣，不可能出现没有原因的问题，没有无因之果，锻炼你的逻辑化思维。
第三板斧：理财 在文章的开头，已经提到了「睡后」收入，理财就是一种很好的方式来增加睡后收入。
因为整个社会是存在着通货膨胀的，也就是说如果你把现金放在家里，甚至是存在银行，你的钱是会贬值的。
据统计，每年的通货膨胀是 6%~12%，根据上表，5 年利率最高的定期存款也才 4%，所以说存银行是没办法跑赢通货膨胀的。
由此可以看到我们就算为了跑赢通货膨胀也要学理财，让钱生钱。
理财的种类有很多种：储蓄、炒金、基金、炒股、国债、债券、外汇、保险、P2P。
每种理财不是每个人都适合，一般风险高的收益高，风险低的收益低，怎么来取舍这就是我们需要学习的。
提示：理财的前提是你本金越多，赚的才有可能更多，所以应该先努力赚钱，赚取更多的本金，然后一边学习理财。在我目前掌握的理财知识来看，指数基金是一种相对适合大多数人的一种理财方式。
最后，如果想获取写作的资料（包括书籍、视频），可以关注公众号 前端桃园，回复「写作」免费领取，或者加微信 lijian1076629390 免费领取。</description>
    </item>
    
    <item>
      <title>桃园周刊 2018-5-5</title>
      <link>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/74/</link>
      <pubDate>Sat, 05 May 2018 19:18:00 +0000</pubDate>
      
      <guid>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/74/</guid>
      <description>### Mvvm 前端数据流框架精讲 带大家了解什么是 mvvm，mvvm 的原理，以及近几年产生了哪些演变。
同时借 mvvm 这个话题拓展到对各类前端数据流方案的思考，形成对前端数据流整体认知，帮助大家在团队中更好的做技术选型。
译-RxJS 游戏之贪吃蛇 众所周知，Web 发展的很快。如今，响应式编程和 Angular 或 React 这样的框架一样，已经是 Web 开发领域中最热门的话题之一。响应式编程变得越来越流行，尤其是在当今的 JavaScript 世界。从命令式编程范式到响应式编程范式，社区已经发生了巨大的变化。然而，许多开发者还是十分纠结，常常因为响应式编程的复杂度(大量 API)、思维转换(从命令式到响应式)和众多概念而畏缩。
该应用使用 HTML5、JavaScript 和 RxJS 来将编程事件循环 (programmatic-event-loop) 的应用转变成响应事件驱动 (reactive-event-driven) 的应用。
前端性能优化之浏览器渲染优化 —— 打造60FPS页面 该文仅针对高性能渲染进行分析。详细的讲解了 CSS 优化 和 Javascript 的优化，一篇非常深入的文章</description>
    </item>
    
    <item>
      <title>ES6之路之块级作用域</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/70/</link>
      <pubDate>Thu, 19 Apr 2018 21:24:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/70/</guid>
      <description>作用域 作用域指变量所作用的范围，在 Javascript 中有两种作用域：
全局作用域 函数作用域 变量提升 变量提升（Hoisting）被认为是， Javascript 中执行上下文 （特别是创建和执行阶段）工作方式的一种认识。具体表现就是所有通过 var 声明的变量会提升到当前作用域的最前面。
function foo() { console.log(temp); } function bar() { console.log(temp); var temp; } foo(); // ReferenceError: temp is not defined bar(); // undefined 可以看到用 var 声明了的并不会报错。因为其实函数 bar 等同于
function bar() { var temp; console.log(temp); } 大多数类 C 语言语法的语言都拥有块级作用域。在一个代码块（括在一对花括号中的一组语句）中定义的所有变量在代码块的外部是不可见的。定义在代码块中的变量在代码块被执行结束后会变释放掉。这是件好事。
糟糕的是，尽管 Javascript 的代码貌似支持块级作用域，但实际上 Javascript 并不支持（就是因为有变量提升）。这个混淆之处可能成为错误之源。
所以在 ES6 中规定了 let 和 const 来支持块级作用域。但是，是不是真的提升就不存在了呢，可以看下面暂时性死区这部分。
let let 可以理解为『更完美的 var』，使用方法很简单；
let foo = 3; 使用方法基本和 var 相同，而且声明的变量只在其块和子块中可用，这点也与 var 相同。 二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。</description>
    </item>
    
    <item>
      <title>你不知道的黑客</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/68/</link>
      <pubDate>Fri, 13 Apr 2018 22:32:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/68/</guid>
      <description>前言 我相信大家对于『黑客』这个词并不陌生，特别是对我们搞计算机的人来说，那是相当的熟悉。
在一般人的眼里『黑客』（hacker）就是入侵计算机的人，就是『计算机犯罪』的同义词。但是，它的原意并非如此。
起源 在 20 世纪 60 年代初，麻省理工学院有一个学生团体叫做『铁路模型技术俱乐部』，他们把难题的解决方法称为 hack。
这里，hack作为名词有两个意思，既可以指很巧妙或很便捷的解决方法，也可以指比较笨拙、不那么优雅的解决方法。两者都能称为hack，不同的是，前者是漂亮的解决方法（cool hack 或 neat hack），后者是丑陋的解决方法（ugly hack 或 quick hack）。hack 的字典解释是砍（木头），在这些学生看来，解决一个计算机难题就好像砍倒一棵大树。那么相应地，完成这种 hack 的过程就被称为 hacking，而从事 hacking 的人就是 hacker，也就是黑客。
所以在 20 世纪 60 年代，『黑客』这个词是一种能力的象征，而且自称黑客的人他们比如包含着高度的革新、独树一帜的风格、精湛的技艺，也就是说在其他人的眼中，他们就是大佬。
自由软件基金会创始人理查德·斯托尔曼认为黑客的行为必须同时满足，好玩、高智商、探索精神三个特点才是真正的黑客。这也是黑客所追求的三种价值，而不是实用性或金钱。
从这个意思出发，我们有时也会用到这个，比如我平时在实现某一个功能的时候，用常规的方法解决不了（或者说当时想不到科学的解决方法），用了一半不是那么科学的方法(或者不知道为什么这种方法就可以解决这个问题)的时候，我们也许会说我们用了一种 hack 的方式来解决了这个问题，并且会在这个方法写上一个注释标识是 hack，因为有可能其他人不知道为什么要这么用。
黑客精神 在史蒂文·利维出版的黑客著作 &amp;mdash;- 《黑客：计算机革命的英雄》中，将黑客的价值观总结为六条『黑客伦理』：
使用计算机以及所有有助于了解这个世界本质的食物都不应该收到任何限制。任何事情都应该亲手尝试。 信息应该全部免费 不信任权威，提倡去中心化 判断一名黑客的水平应该看他的技术能力，而不是看他的学历、年龄或地位等其他标准 你可以用计算机创造美和艺术 计算机使生活更美好 根据这六条『黑客理论』，黑客价值的核心原则可以概括为：分享、开放、民主、计算机的自由使用、进步。
历史上一些最优秀的程序员都是『黑客』。包括 Unix 创始人丹尼斯·里奇和肯·汤普森，Linux 创始人莱纳斯·托瓦兹，『开源运动』创始人埃里克·雷蒙德，微软公司创始人比尔·盖茨等等。正式黑客把计算机推向了更高的高度。
『黑客』被误解的原因 根据『黑客伦理』，黑客就是不服从管教，具有叛逆精神，根据史蒂文·利维描述的就是：“对于黑客来说，关着门就是一种挑衅，而锁着门就是一种侮辱。 ······ 黑客相信，只有有助于改进现状、探索未知，人们就应该被允许自由地使用各种工具和信息。当一个黑客需要一样东西来帮助自己创造、探索或者改正某种设备时，他不会自找麻烦，不会接受那些财产专有权的荒谬概念。”
他们侵入计算机系统的原因不是为了自己利益，而是为了自由，跟那些计算机罪犯是不同的。
然而，在 20 世纪 80年代初，一帮青少年黑客入侵了美国和加拿大的一些计算机系统，被《新闻周刊》封面报道的标题就是『小心：黑客在行动』，这件事被广泛报道，在报道时媒体就把黑客的行为注意在一个很窄的方面：入侵系统。同时，那些入侵计算机的程序员也自称『黑客』，从此黑客在大众心中就成了有害人群。
结语 真正的黑客致力于改变世界，让世界运转得更好。
我们把传统意义上的黑客称之为 hacker，而那些而已入侵计算机系统的人应该称为 cracker（入侵者）。
作为程序员的我们都应该以传统意义的黑客为目标努力，也许你就是下一个黑客，下一个改变世界的人。
整篇文章大部分内容来自于《黑客与画家》，可以推荐给大家都去看下这本书，感受一下那个时代正真的黑客精神。 ** 最后，大家可以在评论里面留言，你心目中最伟大的黑客都有谁。**
大家好，我是桃翁，我为自己代言！</description>
    </item>
    
    <item>
      <title>像素相关概念：PPI、DPI、设备像素、独立像素</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/146/</link>
      <pubDate>Fri, 30 Mar 2018 15:19:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/146/</guid>
      <description>欢迎访问我的个人站点
前言 我相信对于像素，英文「pixel」，缩写「px」，这个概念并不陌生吧，不管是设计师设计图片用的单位 px，还是前端工程师在 css 里面的单位 px等等，很多领域都会用到这个单位，但是当我问他们一些问题的时候，基本上都答得不好。
比如：
iPhone 6 的分辨率是 750 x 1334 像素，然而我们我们在写 css 的时候是以 375 x 667 来调的； 为什么我们做的一个网页在 pc 端可以正常显示，在移动端也可以正常显示，但是有时候又不正常显示； 我们如果在 pc 端把浏览器的宽度调到只有 200px 宽，里面写一个 100px 宽的 div ，然后再调整浏览器的放大为 200%，然后这个 div 可以充满整个显示器。 如果都能答上来，已经很不错了哦！
像素 定义：是指在由一个数字序列表示的图像中的一个最小单位，称为像素。 &amp;mdash;- 百度百科
注意: 我觉得这里最关键的是『单位』，像素是一个单位，而不是一个点，我认为理解为一个长度单位比较好理解，后面我会解释为什么我会觉得是一个长度单位比较好理解。
我在很多文章里看到的定义是，像素就是组成图像的一个一个的点，这会让人感觉像素是个面积单位，我觉得这样有点不妥，并不是不对，要根据上下文而定。
比如 设备像素比(device pixels ratio)，简称 DPR，DPR = 设备像素 / 设备独立像素。现在我们就拿 iPhone 6 来做例子，我们可以通过 window.devicePixelRatio 获取设备的 DPR 为 2，设备独立像素，在这里可以认为是 css 像素，整个 iPhone 6 的像素点就有 375 * 667 个。</description>
    </item>
    
    <item>
      <title>如何将多个 maven 项目统一管理</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/51/</link>
      <pubDate>Thu, 22 Mar 2018 10:21:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/51/</guid>
      <description>简介 在我们一个人采用微服务构架的时候，我们会创建很多个 maven 项目。然后如果从 IDE 里面导入项目就要导入很多次，为了方便统一管理，我们可以将多个 maven 放在一个 项目里统一管理，然后我们导入项目的时候就可以直接导入一个项目就 OK。
操作方法 在多个项目的父目录建立一个文件夹，创建一个 pox.xml 文件 代码规则 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001-XMLSchema-instance&amp;#34;xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;&amp;lt;groupId&amp;gt;com.lxr&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;maiba_be&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;&amp;lt;!-- packaging 把 jar 改成 pox --&amp;gt;&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;&amp;lt;!-- 这里面放每个微服务的 artifactId--&amp;gt;&amp;lt;modules&amp;gt;&amp;lt;module&amp;gt;goodsService&amp;lt;/module&amp;gt;&amp;lt;/modules&amp;gt;&amp;lt;!-- 为了解决依赖版本问题 --&amp;gt;&amp;lt;dependencyManagement&amp;gt;&amp;lt;dependencies&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;Camden.SR3&amp;lt;/version&amp;gt;&amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;&amp;lt;/dependencyManagement&amp;gt;&amp;lt;properties&amp;gt;&amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;&amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;&amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;&amp;lt;/properties&amp;gt;&amp;lt;parent&amp;gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;1.4.2.RELEASE&amp;lt;/version&amp;gt;&amp;lt;/parent&amp;gt;&amp;lt;build&amp;gt;&amp;lt;plugins&amp;gt;&amp;lt;plugin&amp;gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;&amp;lt;/plugin&amp;gt;&amp;lt;/plugins&amp;gt;&amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt; 每个微服务项目的 pox.</description>
    </item>
    
    <item>
      <title>vim 入门指南</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/50/</link>
      <pubDate>Tue, 20 Mar 2018 23:28:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/50/</guid>
      <description>个人站点：桃园
0. 前言 0.1 简介 vim 被誉为『编辑器之神』，与之同时代的 emacs 被誉为『神之编辑器』。可以看得出 vim 在编辑器的地位是很高的，得益于 vim 的指法，敲起代码来如行云流水。特别膜拜创始人创始出这么方便的敲代码的指法，这篇文章就是来带你入坑 vim 指法操作。
0.2 前端的我为什么要学习 vim 在当今前端开发工具百花齐放的时代（VS Code、Sublime、Atom 以及 IDE Webstorm），我为什么还要介绍 20 多年前开发的一个老古董呢？在这里我想说的是出身虽然老，但是所带来的价值并没有减,一旦习惯了 vim 的指法之后，你会觉得不用 vim 操作写代码会觉得很不习惯，甚至不知道怎么操作。然而用在支持 vim 指法的编辑上写代码你会觉得如行云流水，如果再配个机械键盘，简直是享受，特别符合极客的风格。
一旦学会了 vim 的指法，会让你终身受益，至少在你敲代码的年代会收益，毫无夸张, 它会让你摆脱烦人的，在敲代码的时候频繁的移动鼠标，这也是 vim 的设计理念之一 &amp;ndash; 脱离鼠标。
0.3 文章适用读者 本篇文章比较适合前端开发者，因为我也只是用 vim 在前端领域做过一些开发，其他领域我没有发言权。
0.4 Q&amp;amp;A Q：你推荐 vim 是要我们完全放弃以前的编辑器而投入 vim 的怀抱吗？
A：当然不是。首先 vim 的学习成本还是很高的，因为他跟平时我们用的编辑器敲代码的方式根本不同，因为它是不用鼠标的，纯键盘操作。你想想如果你在你的 vs code 上不用鼠标操作，你上下左右全靠方向键，那敲代码的速度得有多慢。而且初学者想把 vim 打造成一个自己的 IDE 还是很有难度的。所以我这里推荐的是，不管是你的 vs code、sublime等，装一个 vim 插件。我在 vs code 上试过，很爽，只不过现在投身到 emacs 的怀抱了。</description>
    </item>
    
    <item>
      <title>JavaScript数据结构之数组栈队列</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/42/</link>
      <pubDate>Wed, 14 Mar 2018 09:53:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/42/</guid>
      <description>1. 数组 数组是平时使用最常用的数据结构，在JavaScript中数组是动态的分配大小,在这里我不会介绍JavaScript里面数组的所有的方法，而是针对数据结构这个方向谈谈所用到的方法。
1.1 创建和初始化数组 //创建空数组var array = new Array();//[]//初始化数组var array = new Array(1,2,3); var array = Array.of(1,2,3);//ES6的方法//[1,2,3]//创建大小为5的数组var array = new Array();//ES6的方法//[undefined,undefined,undefined,undefined,undefined]//给数组赋值var array = new Array();array[0] = 1 ;array[1] = 2 ;array[2] = 3 ;//[1,2,3] 1.2 添加元素 1.2.1往数组后添加元素 var number = [1,2,3];number[number.length] = 4;//[1,2,3,4]//或者var number = [1,2,3];number.push(4);//[1,2,3,4] 1.2.2往数组前面添加元素 var number = [1,2,3];number.</description>
    </item>
    
    <item>
      <title>ES6之路--Symbol</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/41/</link>
      <pubDate>Wed, 14 Mar 2018 09:49:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/41/</guid>
      <description>欢迎访问我的个人站点
1. 概述 简介 Symbol 是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用，表示独一无二的值。Symbol 对象是一个 symbol primitive data type 的隐式对象包装器。它是JavaScript语言的第七种数据类型，前6种分别是：Undefined、Null、Boolean、String、Number、Object。
语法 Symbol([description])
Parameters description : 可选的字符串。可用于调试但不访问符号本身的符号的说明。如果不加参数，在控制台打印的都是Symbol，不利于区分。
demo var s1 = Symbol(&#39;symbol1&#39;);s1 //Symbol(symbol1); 因为Symbol函数返回的值都是独一无二的，所以Symbol函数返回的值都是不相等的。
//无参数var s1 = Symbol();var s2 = Symbol();s1 === s2 // false//有参数var s1 = Symbol(&#39;symbol&#39;);var s2 = Symbol(&#39;symbol&#39;);s1 === s2 //false2. 作为属性名的Symbol 由于每一个Symbol值都是不相等的，那么作为属性标识符是一种非常好的选择。
定义方式： let symbolProp = Symbol();var obj = {};obj[symbolProp] = &#39;hello Symbol&#39;;//或者var obj = {[symbolProp] : &#39;hello Symbol&#39;;}//或者var obj = {};Object.</description>
    </item>
    
    <item>
      <title>在spacemacs中支持editorconfig</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/37/</link>
      <pubDate>Mon, 29 Jan 2018 16:15:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/37/</guid>
      <description>editorconfig 是在项目存储库中有一个名为 .editorconfig 的文件，这样参与的开发者的编辑和 ide 可以自动调整。
有一个 emacs/spacemacs 模式，可以很容易地在以下步骤中进行集成：
将 editorconfig 添加到 dotspacemacs-additional-packages。 将（editorconfig-mode 1）添加到 dotspacemacs/user-config。 更多的细节记录在插件库的 README。
源码片段 第一步：添加插件到 additional packages:
dotspacemacs-additional-packages &amp;#39;( editorconfig ) 第二步：从你的 user-config 激活插件：
(defun dotspacemacs/user-config () (editorconfig-mode 1) ) </description>
    </item>
    
    <item>
      <title>ES6之对象的扩展</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/24/</link>
      <pubDate>Fri, 05 Jan 2018 20:21:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/24/</guid>
      <description>&lt;h3 id=&#34;1-属性的简洁表示法&#34;&gt;1. 属性的简洁表示法&lt;/h3&gt;
&lt;p&gt;ES6允许直接写入变量和函数作为对象的属性和方法。意思就是说允许在对象中只写属性名，不用写属性值。这时，属性值等于属性名称所代表的变量。下面分别举一个例子来说明：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一个例子来谈react的两大优势</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/20/</link>
      <pubDate>Fri, 05 Jan 2018 20:12:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/20/</guid>
      <description>&lt;p&gt;今天我想谈的react的优势有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明式写法更符合人性&lt;/li&gt;
&lt;li&gt;减少dom操作使性能得以提升&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在我们就写一个最简单的计数例子来比较传统的jquery和react。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>数据库基础知识</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/19/</link>
      <pubDate>Fri, 05 Jan 2018 19:43:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/19/</guid>
      <description>&lt;p&gt;数据库基础知识&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>函数式编程笔记</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/18/</link>
      <pubDate>Fri, 05 Jan 2018 19:25:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/18/</guid>
      <description>&lt;p&gt;过去编程方式主要是以命令式编程为主，什么意思呢？简单说电脑的思维方式和我们人类的思考方式是不一样的。我们人类的大脑擅长的是分析问题，提出一个解决问题的方案，电脑则是生硬的执行指令，命令式编程就像是给电脑下达命令，让电脑去执行一样，现在主要的编程语言（比如：Java，C，C++等）都是由命令式编程构建起来的。
​ 而函数式编程就不一样了，这是模仿我们人类的思维方式发明出来的。例如：操作某个数组的每一个元素然后返回一个新数组，如果是计算机的思考方式，会这样想：创建一个新数组=&amp;gt;遍历旧数组=&amp;gt;给新数组赋值。如果是人类的思考方式，会这样想：创建一个数组方法，作用在旧数组上，返回新数组。这样此方法可以被重复利用。而这就是函数式编程了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>cenos下安装node.js和mongodb</title>
      <link>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/17/</link>
      <pubDate>Fri, 05 Jan 2018 19:20:00 +0000</pubDate>
      
      <guid>/posts/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/17/</guid>
      <description>&lt;h2 id=&#34;nodejs安装&#34;&gt;node.js安装&lt;/h2&gt;
&lt;p&gt;下载源码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; /usr/local/src/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget https://nodejs.org/dist/v8.6.0/node-v8.6.0.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>2017文章汇总</title>
      <link>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/16/</guid>
      <description>&lt;p&gt;2017年微信收藏的文章&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2020 年你应该知道的 React 库</title>
      <link>/posts/%E8%AF%91%E6%96%87/300/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E8%AF%91%E6%96%87/300/</guid>
      <description>声明：本文为译文，原文链接：https://www.robinwieruch.de/react-libraries
React 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经习惯了框架包含了所需要的所有功能，
然而对于 React 来说，它的核心并不是完善所有的可选库。 这是优势还是劣势取决于你自己。 当我从 Angular 切换到 React，我绝对经历了它作为 React 的优势。
只有通过 React，您才能使用函数组件和 props 构建组件驱动的用户界面。 它带有一些内置的解决方案，例如，用于本地状态和副作用的 React Hooks。
下面的文章将向您提供一些自己总结的方法，以便从补充库中进行选择，从而构建一个全面的 React 应用程序。
如何开始 React 如果你是一个完全不熟悉 React 的初学者想创建一个 React 项目，加入 React 的世界。有许多工具包项目可以选择，每个项目都试图满足不同的需求。 React 社区的现状是通过 Facebook 的 create-react-app(CRA)。 它提供了一个零配置的设置，并给你一个开箱即用并且简单的启动和运行的 React 应用程序。 所有的工具都对您隐藏起来了，但是最终要由您来更改这些工具。
如果你已经熟悉 React，你可以选择它流行的入门工具包之一: Next.js 和 Gatsby.js。 这两个框架都建立在 React 之上，因此你应该已经熟悉 React 的基本原理。 Next.js 用于服务器端渲染(如动态 web 应用程序) ，Gatsby.js 用于静态站点生成(如博客、登陆页面)。
如果您只是想了解这些初学者工具包是如何工作的，那么可以尝试从头开始设置 React 项目。 你将从一个基本的 HTML 和 JavaScript 项目开始，然后自己添加 React 和它的支持工具。</description>
    </item>
    
    <item>
      <title>2021 年度总结</title>
      <link>/posts/2022/2021-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/2022/2021-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</guid>
      <description>当我起笔写总结的第一感受就是 2021 在写作这件事儿上，我变懒了，对外输出才 8 篇文章。
我翻了下前几年的年度终结，每年好像都觉得自己输出不够多，所以打心底里还是很想把写作这个事情做好的，但是由于自己思维的懒惰，总是没有落实下去。
工作 最近几年自己把工作的地位还是放得很高的，特别是来了蚂蚁之后，一个是因为工作任务比较重，暂用比较多的时间；二是因为在现在的财富积累上绝大部分来自于这份工作。
今年对我而言工作状态终于从忙碌回归到了正常，从来蚂蚁到 2021 年上半年，我基本上都处于一个满负荷的状态，工作日的时间百分之 90 的精力在工作上，准确的说是在业务上。
这种满负荷(业务压力)让我没跟太多的时间去思考自己如何成长、业务应该怎么去发展等，所以之前多次跟女朋友说想换一份工作，干着太累，自己也没太多成长。
后面由于业务调整加上自己终于在公司内找到一个技术发力点，所以心态回到正常，业务压力也从忙碌到正常，现在的状态还是比较满意。
另外有点就是渐渐的对业务价值这个词有了更深的感触，对我们老板说的一句话印象比较深刻：
公司招我们来不是让我们成长的，而是给公司创造业务价值的，所以你在公司不管造多牛逼的轮子，一定是要为业务服务的。所以最好的情况就是我们基于业务造的轮子，即给业务带来了帮助，也让自己技术得到了成长，双赢，这当然也是公司希望的。
所以作为技术人员一定要去了解业务，然后才知道我们的业务怎么赚钱的，或者他们怎么帮公司赚钱的，这样我们才能更有机会创造业务价值。
开源 一、开源最重要的是维护。
我很开心自己在蚂蚁体验技术部这个部门，这个部门应该是国内开源氛围最好的部门之一。组内也有多个非常优秀的开源项目，今年自己有幸参与了一点点 ahooks 和 antd mobile 。
让我开心的不是提了多少个 PR，而是了解了维护一个开源项目有多么的难，参与其中之后了解了开源项目的维护过程，了解了其中的艰辛，很多从公司开源出去的项目真的是纯靠爱发电，并不会纳入个人 KPI 里。
另外一个老板说过一句话：前端的绝大部分的技术项目，打的是维护，并没有太多的技术壁垒。
真的，这认识，太到位了，做开源最重要的持续不断的维护，而不是某个 KPI 项目。有部分阿里开源的东西，可能后期不怎么维护了，所以现在很多一看到阿里开源的，担心的这是不是 KPI 项目，会一直维护吗？可见一直维护才是最重要的一环。
二、尽量的去参与开源。
想起以前上大学的时候，一直在用 antd，从未想过能有机会给流行的开源项目提 PR，但是现在感觉提 PR 跟平时写代码一样了。
我觉得主要是两个原因：
一个是自己身边有很多这样的机会，身边同事都搞开源，想加入进去会变得很容易。 二是因为自己工作多年了，水平比以前高不少，代码也能看懂，自己写的代码也还行，能顺利的参与进去。 所以如果现在想参与开源项目，但是觉得自己还没有能力的，不要着急，打磨一下，让自己稍微厉害一点了来，另外就是要多找机会，看到你想参与的开源项目，有 issue 你可以解决的，你可以主动去提 PR，如果没有被合进去也没关系，一般作者是会给你建议的，这也是你提升的机会。
三、开源其实没那么难。
以前总觉得要去创造一个开源项目，想着要去做一个技术难度很高的开源项目，但是一直想不到，就觉得开源太难了。
今年在了解很多开源项目，以及开源项目背后的发展过程之后，其实自己以前的思路不太多，总想着要去做创新，做很牛逼的东西，做出来直接提效翻倍啥的。
如果没有这样的能力或者机会，我建议如果想做开源可以从集合类的库开始做，或者说一些最佳实践，demo、模板等。
什么叫集合类的库，我举几个例子就明白了。 ahooks（多个常用的自定义 hooks 集合）、antd（中后台组件集合）、lodash（工具函数集合）等等，这种项目你看，每一个集合里的元素都不是很难，写一个 hook、写一个组件、写一个函数有啥难的嘛，平时写项目公用组件，或者 common 文件夹里不也有么。**难的是要多、好用、长期维护。**可能你一个元素使用的人不多，但是当你的集合越来越多，就会跟越来越多人的需求匹配之后，就有用了。
最佳实践，demo 、模板类是什么样的呢？这种项目用户更多的可能是新手、或者小公司，刚接触某个技术栈的时候不知道怎么上手，不知道怎么写一个项目，不知道怎么写好一个项目，你就可以写一份 demo、或者最佳实践，让别人参考，或者快速搭建自己的项目。
这种项目比如：antd pro，你是不是也可以去写一个 antd mobile pro？或者 element pro ？或者 xx pro。类似的最佳实践还有很多很多，自己可以发散一下。</description>
    </item>
    
    <item>
      <title>4个你从未听说过的强大的 JavaScript 运算符</title>
      <link>/posts/%E8%AF%91%E6%96%87/339/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E8%AF%91%E6%96%87/339/</guid>
      <description>你有没有花一个下午的时间浏览过 Mozilla 文档？如果你有，你会很清楚网上有很多关于 JavaScript 的信息。这使得人们很容易忽略一些不同寻常的 JavaScript 操作符。
然而，仅仅因为这些操作符不常见并不意味着它们不强大！它们在语法上看起来都很相似，但是当它们以不同的方式工作时，请务必阅读它们。
让我们开始吧！
译者注：nullish 代表 null 或者 undefined
1. ?? 操作符 在 JavaScript 中，?? 操作符被称为nullish 合并操作符。如果第一个参数不是 null/undefined，这个运算符将返回第一个参数，否则，它将返回第二个参数。让我们看一个例子。
null ?? 5 // =&amp;gt; 5 3 ?? 5 // =&amp;gt; 3 当为一个变量分配默认值时，JavaScript 开发人员传统上依赖于逻辑 OR 操作符，如下所示。
var prevMoney = 1 var currMoney = 0 var noAccount = null var futureMoney = -1 function moneyAmount(money) { return money || `You currently do not own an account in the bank` } console.</description>
    </item>
    
    <item>
      <title>5 点可以让你提高面试通过率建议(干货)</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/323/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/323/</guid>
      <description>自从我发过几篇关于面试经历的文章，由于我面试结果还不错，所有很多人来询问我一些面试相关的问题， 我这里给到 5 点建议，希望对大家有帮助。
1. 简历里应该惜字如金 简历简历，可以分为简和历。简，简单简洁之意，历，经历，总体就是简单的表达自己的经历。
我看到一些人的简历写了四、五页，甚至十来页的都有，每个项目把细节都写出来了，甚至还把项目截图给贴在了简历里面，生怕面试官不能理解需求，我建议最多不超过 2 页，亮点能写两页就已经很牛逼了。
我相信有很多人工作了很多年，经历的项目很多，其实不需要把所有的项目都列出来，简历里是要展示自己的亮点，牛逼的点，这个亮点、牛逼的点事相对的，相对于自己所做的东西里面的，不是客观的牛逼(如果有当然更好，那必然也是你相对的里面的亮点，不冲突)。
这句话意味着两层意思：
很多人觉得自己的项目没有亮点的问题，因为你是那这别人更高的标准来衡量自己，所以你相对于别人没有亮点，这样你就写不出一份简历。 多个亮点类似的项目合并，或者只写一个，因为都是为了给面试官展示这一个亮点，写多了就是浪费空间，简历上面的字很珍贵。 第一层让你的简历有东西可写(增加)，第二层是让你把简历写得更优质(减少)。
2. 简历应该是你设计过的 「设计简历」可能对这个词有点迷惑，可能你第一感觉是设计得好看一点，其实我想表达的设计是一种「圈套」，给面试设计的「圈套」，下面我会举例子让你明白这个「圈套」是什么。
我举两个点：技术要点和项目经历。
技术要点(就是自己会哪些技术)和项目经历相信是简历里面必不可少的内容，但是也许你可能忽略了哪些应该写。
之前我给别人看简历的时候，我就会问他们写的技术点三个问题
你对这个技术点的掌握程度是什么样的？ 你对这个技术点准备了哪些问题？ 当问到了相关技术点的时候，你能回答到哪个层次？仅仅了解、用过一两次、熟练使用、还是掌握原理。。。 当你能清楚的回答完这三个问题之后，你对你自己的水平就有了一定的认识，同时你对自己是否符合这个岗位有了一定的判断。我的目的就是让你了解自己的水平，然后才能针对性的去复习，查漏补缺，自己心里要有一杆秤，自己把这个知识点掌握到这个程度，能不能胜任这个岗位。
当你了解了之后，然后根据你自己是否有充足的复习时间，你就可以去设计你的技术要点部分了，只写你准备好了的技术点，这个准备好了不是说掌握得很深才叫准备好了，就算是只能回答几个简单的问题也算是准备好了，就是你想准备，然后自己也去复习了的，这就叫准备好了，这样你在面试的时候才会胸有成竹。
这就是在套路面试官问你准备好的问题，因为技术官基本只会问你简历里面提到的技术点，所以自己要对自己简历里面的技术点有充足的准备(把一些常见的面试题刷一些也是非常有帮助的)。
第二点设计就是对于项目经历部分。项目经历这部分没有人比你更熟悉，所以如果问到项目经历应该是你的地盘，是你给面试官展示你的项目有多牛逼，你在里面发挥了多大的价值，带来了多大的成果，你要非常自信的去给他讲解。
你的自信来源于什么？你非常了解这个项目的需求(为什么要做这个项目)、项目价值(做了之后怎么样了)，以及整个项目的技术方案，架构体系(怎么做的)，最重要的是你负责的或者参与的。
同时，你再把你在项目中遇到的一些**难点，和解决方案总结下来，**那么项目这块就是你的主战场了。
划重点：上面我所说的，最好最好是要准备，也就是说最好你要写下来，然后可以没事儿自己问自己上面的这些问题，然后自己去回答。
你可能会说，哇，那要准备好多东西哦，所以说啊，项目不用写太多，就把觉得自己最牛逼的、最熟悉的两、三个项目总结下来就够了，在项目这块比的不是数量，而是质量。 **
项目经历这块在面试的时候面试官会问你一些问题，比如一些其他的解决方案，如果当时想到了，或者面完了想到了，记得补充进去。
3. 选常用的东西去准备 前端的技能要求很多，就算解决同一个问题的解决方案也会有很多个，比如解决视图的，就有 React、Vue，构建的就有 Webpack、Rollup、Parcel ，React 状态管理也有 Redux、Mbox、unstate 等。
如果你的脑袋里面都装着这些东西，那么你肯定是复习不完的了，我的建议是把你项目用常用的东西好好准备，尽量不要让面试官把你常用的东西还问倒了，如果你平时用的东西你都没有掌握得好，你觉得面试官会觉得你平时不用的东西掌握好了吗？
4. 准备一份自我介绍 准备一份自我介绍，不是简简单单的准备，而是自己要写下来，然后对着稿子练习一下。可能你会觉得很麻烦，有必要吗？我说两点：
自我介绍是每个面试官，每场面试都会问的，没有哪个面试题有如此高的频率，100% 中的面试题不值得去好好准备吗？ 上面我说了简历是去套路面试官问哪些东西？而自我介绍就是去套路面试官怎么去问的一个很好的方式，因为往往面试官会在你自我介绍之后，会问几个你自我介绍里面所包含的东西，自我介绍的结尾，也许就是面试题的开始。 这个一个很好的引导面试官怎么问的方式。
5. 职业规划 职业规划这个，其实也是一个高频面试题，不管是面试官还是 HR，都喜欢问的一个问题，这个题没有标准答案，我说一下我的一些看法。
职业规划我觉得可以从三个方面去谈：
我想做什么？(兴趣、价值观等方面) 我能做什么？(你的知识、技术、经历等方面来支持) 环境支持我做什么(意味着未来)？(外部环境，公司、团队) 大致你可以像这样去回答，我的兴趣是 XXX，优势是 XXX，因此我选择了前端，这是一个可以将我的兴趣和工作结合起来的行业，是我非常喜欢的，所以我会很用心对待这个工作。我之前做过 XX，有了 XX 的经验，然后觉得很有意思，想继续深挖(当然你也可以说，我之前一直在做 XXX，以后想换一种 XXX 技术)。近期我打算研究 XXX，后续可以在 XXX 上独当一面，独立负责 XXXX 事务,解决 XXXX 问题。谈到远期规划，我会根据环境的变化，工作内容的变化，以及我自身能力的变化，不断进行调整的。</description>
    </item>
    
    
    <item>
      <title>clip-path 实战</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/15/</guid>
      <description>&lt;h3 id=&#34;demo演示&#34;&gt;demo演示&lt;/h3&gt;
&lt;h4 id=&#34;多边形图&#34;&gt;多边形图&lt;/h4&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://upload-images.jianshu.io/upload_images/2974893-23031feaabbb7c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34;  /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>css实现图片剪裁</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/6/</guid>
      <description>&lt;p&gt;也许，你会遇到这样的情况，UI给你一张图片，然而根据实际情况，比如需要适配XXX手机，或者需要把图片形状搞好看一点，会让前端人员进行图片剪裁工作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>css计数器教程</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/288/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/288/</guid>
      <description>前言 CSS 里面的伪元素其实是非常好用的，但是经常容易被大家忽略，伪元素里面常用到的 content 属性，可能现在很多人仅仅以为 content 属性的值只支持字符串，除了字符串外常用到的还有 uri、counter ，今天所要介绍的就是 conter(计数器)。
先看如下的例子：
&amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;桃翁&amp;lt;/h3&amp;gt; &amp;lt;h3&amp;gt;介绍&amp;lt;/h3&amp;gt; &amp;lt;h3&amp;gt;css 计数器&amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; 根据如上的 HTML 你是否有办法不通过 JavaScript ，仅仅用 CSS 在 title 前面增加 Title number: 呢？
CSS 计数器基本概念 如果仅仅增加一个 Title，大家都知道通过伪元素(:before或者:after)，设置 content 为 Title，但是如何自动根据 h3 出现的顺序来展示自动编号可能很多人就不知道了。
自动编号在 CSS 2.1 中是通过两个属性控制的，&amp;lsquo;counter-increment&amp;rsquo;和&amp;lsquo;counter-reset&amp;rsquo;。通过这些属性定义的计数器用于&amp;lsquo;content’属性的 counter() 和 counters() 函数
初始化计数器 在使用计数器的时候需要先初始化这个计数器，并且设置一个计数器的名字(变量)。下面是例子，title 就是名字，conter-reset 就是用来初始化的，这个属性是必须设置的，否则没办法用计数器。
&amp;lsquo;counter-reset&amp;rsquo;属性也含有一列一个或多个计数器，每个后面可以跟一个可选的整数。该整数给定了每次出现该元素时给计数器设置的值，默认为 0
counter-reset: 计数器名称[, 默认值number]; /* 重置计数器成0 */ 计数器自增 有了一个计数器的变量后，然后可以让这个变量进行自增：
&amp;lsquo;counter-increment&amp;rsquo;属性接受一个或多个计数器名（标识符），每个后面都可以跟一个可选的整数。这个整数表示每次出现该元素时计数器递增几。默认增量是 1，可以接受 0 和负数
counter-increment: 计数器名称[, 增量]; /* 增加计数器值 */ 显示计数器 最后就是现实计数器的值，获取计数器的值有两个函数：counter() 和 counters() ，如上面的例子：</description>
    </item>
    
    <item>
      <title>Deep In React 之浅谈 React Fiber 架构（一）</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/262/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/262/</guid>
      <description>文章首发于个人博客
前言 2016 年都已经透露出来的概念，这都 9102 年了，我才开始写 Fiber 的文章，表示惭愧呀。不过现在好的是关于 Fiber 的资料已经很丰富了，在写文章的时候参考资料比较多，比较容易深刻的理解。
React 作为我最喜欢的框架，没有之一，我愿意花很多时间来好好的学习他，我发现对于学习一门框架会有四种感受，刚开始没使用过，可能有一种很神奇的感觉；然后接触了，遇到了不熟悉的语法，感觉这是什么垃圾东西，这不是反人类么；然后当你熟悉了之后，真香，设计得挺好的，这个时候它已经改变了你编程的思维方式了；再到后来，看过他的源码，理解他的设计之后，设计得确实好，感觉自己也能写一个的样子。
所以我今年(对，没错，就是一年)就是想完全的学透 React，所以开了一个 Deep In React 的系列，把一些新手在使用 API 的时候不知道为什么的点，以及一些为什么有些东西要这么设计写出来，与大家共同探讨 React 的奥秘。
我的思路是自上而下的介绍，先理解整体的 Fiber 架构，然后再细挖每一个点，所以这篇文章主要是谈 Fiber 架构的。
介绍 在详细介绍 Fiber 之前，先了解一下 Fiber 是什么，以及为什么 React 团队要话两年时间重构协调算法。
React 的核心思想 内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中。
React 16 之前的不足 首先我们了解一下 React 的工作过程，当我们通过render() 和 setState() 进行组件渲染和更新的时候，React 主要有两个阶段：
调和阶段(Reconciler)：官方解释。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。
渲染阶段(Renderer)：遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。</description>
    </item>
    
    
    <item>
      <title>三个比它们等效 ES5 速度慢的 ES 6 函数</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/226/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/226/</guid>
      <description>[Meting] [Music server=&amp;ldquo;tencent&amp;rdquo; id=&amp;ldquo;000AwJtd3Wp27b&amp;rdquo; type=&amp;ldquo;song&amp;rdquo;/] [/Meting]
我在 medium 上看到一篇 3 JavaScript Performance Mistakes You Should Stop Doing 文章(点击阅读全文可以查看原文，需要科学上网)，大概意思就是说有 3 个 JavaScript 性能错误，你不应该再去写了。很多“歪果仁”也是一看到这个标题就开始**“喷”**作者了，下文会详细说。我先介绍下这篇文章的主要内容
文章主要内容： 当 ES5 发布的时候，JavaScript 引入了很多新的数组函数。其中包括 forEach，reduce，map，filter - 它们让我们感觉语言在不断增长，功能越来越强大，编写代码变得更加有趣和流畅，结果更易于阅读和理解。
大约在同一时间，一个新的环境&amp;ndash;Node.js，它使我们能够从前端到后端平稳过渡，同时真正重新定义完整的全栈开发。
所以作者就测试了一下新提供的这些方法是否会影响我们程序的性能。他在 macOS 上对Node.js v10.11.0 和 Chrome 浏览器执行了以下测试。
1. 循环数组
他想到的第一次很常见的场景，就是计算一下 10k 项的总和。然后比较了使用 for，for of，while，forEach 和 reduce 的随机 10k 项的总和。运行测试 10,000 次返回以下结果：
For Loop, average loop time: ~10 microsecondsFor-Of, average loop time: ~110 microsecondsForEach, average loop time: ~77 microsecondsWhile, average loop time: ~11 microsecondsReduce, average loop time: ~113 microseconds 在谷歌搜索如何对数组求和时，reduce 是最好的解决方案，但它是最慢的。即使是最新的（ES6）也提供了较差的性能。事实证明，老的 for 循环提供了迄今为止最好的性能 - 超过 10 倍以上！</description>
    </item>
    
    <item>
      <title>为 VSCode 添加上程序员专用字体 Fira Code</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/290/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/290/</guid>
      <description>简介 推荐一款号称程序员的字体 Fira Code，Fira 是 Mozilla 主推的字体系列，Fira Code 是基于 Fira Mono 等宽字体的一个扩展，主要特点是加入了编程连字特性（ligatures）。
Fira Code 就是利用这个特性对编程中的常用符号进行优化，比如把输入的「!=」直接显示成「≠」或者把「&amp;gt;=」变成「≥ 」等等，以此来提高代码的可读性。
效果如下：
经过我体验一周来看，这款字体还是不错的。
更多请前往GitHub地址查看。
设置步骤 Step 1. 下载 前往 Fira Code 字体的 GitHub 地址，clone 或者 download字体文件，主要有 5 个 .ttf 字体文件，地址https://github.com/tonsky/FiraCode/tree/master/distr/ttf
Step 2. 安装 安装刚刚下载的 5 个字体文件：选择文件后点击鼠标右键，点击安装命令即可安装字体。
Step 3. 修改设置 打开 VS Code，如果在安装字体之前已经打开了，**一定要重启 **VS Code，否则识别不到新字体。
打开菜单File &amp;gt; Preferences &amp;gt; Settings，或者点击 File 后使用快捷键 Ctrl+,即可打开，然后打开 settings.json 文件，找到 editor.fontFamily字段，然后再把 Fira Code 添加到第一个，并且加上 &amp;quot;editor.fontLigatures&amp;quot;: true 。
&amp;#34;editor.fontFamily&amp;#34;: &amp;#34;&amp;#39;Fira Code&amp;#39;, Menlo, Monaco, &amp;#39;Courier New&amp;#39;, monospace&amp;#34;, &amp;#34;editor.</description>
    </item>
    
    <item>
      <title>为什么javascript经常被黑？</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/96/</guid>
      <description>前言 这个问题是知乎上有人邀我回答的，感觉挺有意思的，所以发出来大家讨论下
1. 语言自身问题 Javascript 之父在花 10 天设计出来的，再牛逼的人，10 天设计出来的肯定会有很多设计不合理的东西，哪些不合理的东西，可以去看《JavaScript语言精粹》，导致这本语言一直是最具争论的一门语言。
但是背负着这么大的舆论，那么多很烂的特性，还要兼容各种浏览器，js 还能发展得这么好，web前端，移动，服务端，桌面端，甚至游戏，物联网，机器学习等，可见那些好的特性还是非常好的，具体可以看我的这篇文章&amp;ndash;Javascript 是最好的语言，不服来辩。
2. 开发者水平差距太大 js 这门语言虽然能做的事儿很多，主要还是用在写前端上，对于前端这门职业，相对其他方向比较简单，容易上手，不需要太多计算机基础知识，导致刚培训出来的，或者自学的同学，可能见的世面比较少，学了点 node，会用 express 了，就说自己是全栈，所以就黑前端，前端一想就是 js 不好
3. javascript 相对还是比较简单 有没有发现，越简单的越容易被人黑，比如 vue，vue 被黑的次数比 react 多多了，说 vue 是新手玩的，没水平，就连正妹也说过类似的话，我记得是在哪里看到过他在某个群里说过的，如果是p的就忽略。但是简单就不代表不好，简单能达到同样功能不应该更伟大吗？
4. 门槛低 社区高水平的不多，或者说门槛太低，什么人都有。
这个我就拿 emacs 社区举例，emacs 社区是真的好，文档质量超高，目前是我见到社区质量最好的，因为门槛高，学 emacs 的大部分都是真正喜欢敲代码的，而不是喜欢撕逼的，跟第二点一样，前端圈水平低的太多，导致 js 被黑。
5. 前端发展太快 前端发展太快， js 框架层出不穷，然后经常会有各种框架之间的撕逼，某某框架好啥啥啥的，才会有大漠老师事件等，这种机会让其他圈看笑话了，说我们前端圈是真的乱，好好敲代码不好嘛，争哪个框架好有啥意义，又不是你写的，争赢了自己脸上又不贴金，在此引用狼叔说的，少抱怨，多做事。有本事自己写一个框架然后说服别人你这框架比尤大的 vue 好。
结束语 最后我觉得 javascript 挺好的，然后希望作为前端的我们，静下心来好好学习，别让其他圈的看我们的笑话，最后还是想说， Javascript 是最好的语言，不服来辩。</description>
    </item>
    
    <item>
      <title>函数式编程之组合</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/253/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/253/</guid>
      <description>该系列文章不是针对前端新手，需要有一定的编程经验，而且了解 JavaScript 里面作用域，闭包等概念
组合函数 组合是一种为软件的行为，进行清晰建模的一种简单、优雅而富于表现力的方式。通过组合小的、确定性的函数，来创建更大的软件组件和功能的过程，会生成更容易组织、理解、调试、扩展、测试和维护的软件。
对于组合，我觉得是函数式编程里面最精髓的地方之一，所以我迫不及待的把这个概念拿出来先介绍，因为在整个学习函数式编程里，所遇到的基本上都是以组合的方式来编写代码，这也是改变你从一个面向对象，或者结构化编程思想的一个关键点。
我这里也不去证明组合比继承好，也不说组合的方式写代码有多好，我希望你看了这篇文章能知道以组合的方式去抽象代码，这会扩展你的视野，在你想重构你的代码，或者想写出更易于维护的代码的时候，提供一种思路。
组合的概念是非常直观的，并不是函数式编程独有的，在我们生活中或者前端开发中处处可见。
比如我们现在流行的 SPA (单页面应用)，都会有组件的概念，为什么要有组件的概念呢，因为它的目的就是想让你把一些通用的功能或者元素组合抽象成可重用的组件，就算不通用，你在构建一个复杂页面的时候也可以拆分成一个个具有简单功能的组件，然后再组合成你满足各种需求的页面。
其实我们函数式编程里面的组合也是类似，函数组合就是一种将已被分解的简单任务组织成复杂的整体过程。
现在我们有这样一个需求：给你一个字符串，将这个字符串转化成大写，然后逆序。
你可能会这么写。
// 例 1.1 var str = &amp;#39;function program&amp;#39; // 一行代码搞定 function oneLine(str) { var res = str.toUpperCase().split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;) return res; } // 或者 按要求一步一步来，先转成大写，然后逆序 function multiLine(str) { var upperStr = str.toUpperCase() var res = upperStr.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;) return res; } console.log(oneLine(str)) // MARGORP NOITCNUF console.log(multiLine(str)) // MARGORP NOITCNUF 可能看到这里你并没有觉得有什么不对的，但是现在产品又突发奇想，改了下需求，把字符串大写之后，把每个字符拆开之后组装成一个数组，比如 ’aaa‘ 最终会变成 [A, A, A]。
那么这个时候我们就需要更改我们之前我们封装的函数。这就修改了以前封装的代码，其实在设计模式里面就是破坏了开闭原则。
那么我们如果把最开始的需求代码写成这个样子，以函数式编程的方式来写。
// 例 1.</description>
    </item>
    
    <item>
      <title>函数式编程资料</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/197/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/197/</guid>
      <description>Eric Elliott 函数式教程 征服 JavaScript 面试: 什么是函数式编程？ 组合软件：1. 函数式编程的兴衰 为什么用 JavaScript 学习函数式编程？（软件编写）（第二部分） 函数式程序员的 JavaScript 简介 (软件编写)（第三部分） 高阶函数（软件编写）（第四部分） Reduce（软件编写）（第五部分） Functor 与 Category （软件编写）（第六部分） 函数式 Mixin（软件编写）（第七部分） 为什么在使用了类之后会使得组合变得愈发困难（软件编写）（第九部分） 借助函数完成可组合的数据类型（软件编写）（第十部分） JavaScript 让 Monad 更简单（软件编写）（第十一部分） JavaScript 轻量级函数式编程 JavaScript 轻量级函数式编程
Starkwang.log JavaScript函数式编程（一）
JavaScript函数式编程（二）
JavaScript函数式编程（三）
如果你想成为函数式编程爱好者 如何成为一位函数式编程爱好者(Part 1) 如何成为一位函数式编程爱好者(Part 2) 如何成为一位函数式编程爱好者(Part 3) 如何成为一位函数式编程爱好者(Part 4) 如何成为一位函数式编程爱好者(Part 5) 如何成为一位函数式编程爱好者(Part 6) 书籍 《JavaScript 函数式编程指南》推荐 《JavaScript 函数式编程思想》推荐 《JavaScript ES6 函数式入门经典》看了上面两本这本就不用买了 《JavaScript 函数式编程》 相关库 https://folktale.origamitower.com/ https://github.com/fantasyland/fantasy-land http://ramda.cn/ http://lodash.think2011.net/ </description>
    </item>
    
    <item>
      <title>前端桃园周刊第五期</title>
      <link>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/292/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/292/</guid>
      <description>文章 1. Thinking in React Hooks 当从 React 类组件切换到函数组件 + hook 时，基本的思维模式发生了什么变化。
2. Ant Design 1.0 背后的故事：把艺术变成技术 我以前一直不喜欢读历史，今年了解吴军老师比较多，听他的硅谷来信，看他的书：《浪潮之巅》、《文明之光》才决定历史背景原来那么重要，了解历史你会发现现在很多的东西都是必然会出现的。 Ant Desgin 这么伟大的东西，了解一个产品背后的故事，我觉得还是很有必要的，看看为什么别人能做出伟大的东西，而我们不能。
3. 前端API层架构，也许你做得还不够 架构设计是一条永远走不完的路，没有最好，只有更好。这个道理适用于软件设计的各个场景，前端API 层的设计也不例外，如果您觉得在调用接口时还存在诸多槽点，那就说明您的接口层架构还待优化。作者以 vue + axios 为例，为大家梳理下我的一些经历和设想。
4. 你的 Mac 用对了吗？推荐一些 Mac 上比较好用的软件 这些 mac 软件都挺好用的，强烈推荐。
5. 再谈编程范式—程序语言背后的思想 详细讲述了命令式、过程式、说明式、面向对象、函数式、泛型编程各个编程范式的特性。
6. 少讲大道理，多解决小问题 二爷这篇文章以很多亲身体验的例子来阐述了多做事，少废话的道理，非常值得一读。
挖宝 1. vscode 字体 fira code 一款为程序员专属的字体。
2. 大四学生开源文言文编程语言 这一项目并不是简单的将程序中的英文字符换成了中文，而是利用 NLP 的一些技术，将文言文程序语法转换到 JavaScript 或 Python 运行，有一定的技术难度。
如果读者想快速试一试，你也可以玩一玩在线 IDE，上面有很多预定义的函数。即使在手机上，我们也能编辑并运行「文言文代码」。
3. lutaonan.com 一款很简洁的博客，文章阅读页的样式准备参考他的。
4. 方凳雅集 方凳雅集是阿里B系前端技术团队的专属公众号，内容来自1688、阿里巴巴国际站、零售通、AliExpress、企业金融、考拉等多个BU的前端团队，涵盖阿里原创技术、精彩翻译和公司文化、职业成长等内容。
最近关注到的质量比较高的前端公众号了，不过不太适合初级工程师，文章话题一般比较高大上，都是他们团队内部的一些解决方案，而不是基础知识。
5. 第十四届D2前端技术论坛「创心」 12 月 14 日，第十四届 D2 前端技术论坛在杭州圆满举办。来自全国各地的近千名开发者齐聚杭州，聆听 3 大会场、来自 24 位海内外嘉宾的 21 个主题分享。</description>
    </item>
    
    <item>
      <title>前端桃园周刊第六期</title>
      <link>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/294/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/294/</guid>
      <description>小知识 伪类before/after中的图片大小是不是不能设置的? 文章 编写组件的 10 个原则 一篇英文文章，之前面试被面到过设计组件的时候要注意哪些，当时我大脑空白，根本答不出来，看了这篇文章之后，也许知道怎么答了。
深入解析ES Module（二）：彻底禁用default export 文章介绍了 export default object 这种方式所带来的问题，主要是在转换的时候不兼容 cjs，当然这篇文章也有助于更深刻的理解 ES Module。
「圣诞特辑」纯前端实现人脸识别自动佩戴圣诞帽 通过使用 TensorFlow.js 来进行人脸识别，然后自动佩戴圣诞帽，我最近也在学习机器学习相关的，当然也绕不开 TensorFlow.js ，学完课程之后再来看这篇文章。
那些你用错了的 React 生命周期 这篇文章的中心思想跟我之前在 React 官方博客里面看到那篇「你也许不需要派生 State」基本类似，主要是 componentWillReceiveProps 和getDerivedStateFromProps 这两个声明周期可能会写成反模式。
独家 | 阿里张勇湖畔分享：领导者如何“落子无悔” 张勇的演讲全文，看到很多大佬推荐这篇文章，先 mark 一波。</description>
    </item>
    
    <item>
      <title>前端桃园周刊第四期</title>
      <link>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/289/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/289/</guid>
      <description>一句话知识 npm v packageName versions npm v packageName versions 查看包的所有版本，不加s 获取新版本。用途，安装了包但是 package.json 里面没有包，需要手动填入的时候。
typeof null 为什么返回 &amp;ldquo;object&amp;rdquo;？ 不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。
in 和 hasOwnProperty 区别 in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。相比之下， hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。
for in 和 for of 的区别 for in 用于对象的遍历，会遍历原型上可以枚举的属性
for of 用于遍历可迭代的对象，比如数组，因为数组里面是有迭代器的，凡是有迭代器的对象都可以用 for of 来遍历
对 constructor 的误解 对象的 constructor 实际上不是对象创建的时候有的，而是通过委托到 prototype 上找的。
function Foo() { /* .</description>
    </item>
    
    <item>
      <title>另一个视角看待这次 antd</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/191/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/191/</guid>
      <description>公众号相信大家今天都已经知道了 antd 这次的事故了，不知道的简单回顾一下。
今天圣诞节，所以在 type 是 primary 的 Button 上都加上了雪花。
就是在 antd 3.9.3 的时候增加了一个定时器，到 12 月 25 的时候增加一个 christmas 的 css 类，还给 title 改为了 Ho Ho Ho。具体 commit 见：https://github.com/ant-design/ant-design/commit/00aebeb9756afecc884ad48486084836b9a2707a
然后就导致今天开发者早上一来看，就觉得莫名其妙，还以为是病毒啥的，还有人因此被解雇(issue 上说的，不知道是否是真)，总之，这个事情还是挺严重的。
作为一个有温度的前端号，肯定不是带你们吃瓜的，要是带你们吃瓜，肯定大早上的这篇文章就出来了，我们从另外的角度来看下这个问题。
功不抵过
开源及责任
批评没有任何好处
功不抵过 Antd 作为全世界最好的 React 前端组件库之一，目前将近 4 万的 star，国内外很多企业都会使用 antd 做前端开发。
我估计最近几年大部分人接触 React 的人，使用的 UI 库都会是 antd，Vue 的话可能 Element UI 和 iView 还可以拼杀一下，但是 antd 在 React 界是绝对的老大，这是 antd 的功。
但是这一次彩蛋事件，就导致很多人因此而放弃它。
然后网上骂声一片。
这是为什么呢？
因为这次失误触犯了使用者的底线，本来使用 antd 就是因为他的稳定，用起来放心。
结果这个彩蛋，出其不意，在没有给用户任何提示的情况下，悄悄的代码里面加一些“副作用”，导致让用户感觉用 antd 不再放心，担心下次加点获取用户信息啥的。</description>
    </item>
    
    <item>
      <title>我不喜欢这世界，我只喜欢你</title>
      <link>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E7%AC%94%E8%AE%B0%E6%9C%AC/3/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;我这人运气一向不好，我这辈子最幸运的事大概就是遇见你，所以我特别特别珍惜，长这么大唯一坚持下来的事情就是爱你。&lt;/li&gt;
&lt;li&gt;反正得听你啰嗦一辈子，习惯就好。&lt;/li&gt;
&lt;li&gt;因为只有在我面前，她可以不用坚强。&lt;/li&gt;
&lt;li&gt;但我知道，一想到能和你共度余生，我就对余生充满期待。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>我也想做自己喜欢做的事儿</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/301/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/301/</guid>
      <description>我今天看到一视频，给了我非常大感触。是 B 站上的一个视频，标题名叫：《这有可能是我最后一期视频了，再见了 B 站》， 视频链接可以点击「原文链接」得到。
这个视频大概讲的是这样：
一个富二代，大学毕业以后没有去家里帮爸妈，由于自己非常喜欢游戏，所以就想做自媒体，自己赚钱养自己，做了差不多一年半，在 B 站拥有不多不少的 25 万粉丝，由于他自己喜欢的是单机游戏，但是国内喜欢单机游戏的人太少，所以在 B 站涨粉缓慢，慢慢的，迫于生计，不得追求快速涨粉，不至于入不敷出。
所以就开始做一些自己不喜欢的视频，比如热点视频，电影娱乐等，因为这些看的人多，涨粉相对较快，但是自己并不喜欢这些视频。以前自己做的游戏视频做完之后会回味好几遍，但是现在做的这些视频自己非常不喜欢，做完之后完全没有动力去看。
突然有一天他的爸妈给他买了一套 1600 万的房子，加上装修可能 1700 万左右，但是他爸妈只付了首付(他爸妈能全款买得起)，剩下的贷款要让他自己还，目的就是要让他回去帮家里的忙，因为他做自媒体根本换不起这个贷款。
一个月贷款要还 3 万多，他做 B 站一年半才赚了 10 万，他爸妈就质问他，你觉得你做现在这个职业有前途吗？能还得起这个房贷吗？如果将来你的儿子想住这么大的房子你买得起吗？
他就开始思考当初的初心，自己做自媒体是为了赚钱，现在家里有四个厂，家里父母也 50 了，回去帮忙岂不是能花更少的时间赚更多的钱。
所以他就关了自己的工作室，不再做自己不喜欢的视频，并且回家去继承家业。
看完这段视频莫名的感到了一丝心酸和无奈。
心酸的是很多做自媒体(包括我自己)的刚开始都是做自己喜欢的东西，后来慢慢的为了粉丝向营销号靠拢，远离了自己的初心，这视频作者可以回家继承家产，而剩下的那些远离了初心的人又会何去何从呢？
无奈的是即使家里这么有钱，不想靠着父母打拼出一番事业，但是在房贷的压力下，以及对自己能力确实不太能够打拼出一番事业，最后只能回家靠父母的无奈。
这种富二代他们一次一次的失败之后，还是会有退路(回家继承家产)，但是对于我们普通人来说，就没有退路，只能向前冲，就得努力赚钱。
但是在自己能力还没到的时候，做自己想做的事的时候，又赚不了那么多钱，所以只能违背这自己的初心，去赚一些合法的钱。
在这种金钱和自己喜欢的东西做斗争的时候，我无法给出应该选择哪种的建议。可能站在局外人来说，当然做自己喜欢的事儿呀，把事情做好，然后赚钱是自然的。
道理谁都懂，但是我觉得这是在考验人性的时候，当这件事儿发生在你的身上可能就不一定会这么做，因为我遇到太多太多这样的人了，只有非常少数的人能坚持自己的原则，这种人往往就缺少一个贵人，等待一个爆发期，但是在爆发期来临之前，又有多少人能坚持下来呢，很难说。
最后想说的是还是想做那个最初想做的人，把这个公众号做成自己喜欢的样子，提供一些在其他地方看不到的稀缺的有价值的东西，跟我公众号的 slogon 一样：成为自己想成为的那个样子。 每天花一小时来写文章，而不是花半个小时来找一篇好的文章。
其实我很希望你们可以给我多留言，多跟我交流你们的想法，而不是向我提一些问题，让我解答，两者之间的区别在于我们两是否在同一个水平，是否双方都会受益。
所以我喜欢你在请教我一些东西的时候，你已经做好了功课，咱们在此次对话中花了这么多时间，都能得到一些价值。
虽然我不是一个大 V，但是我还是很忙，有我自己的事儿，每天向我请教的人又特别多，我目前不想专门开一个付费的知识星球来回答问题，然后出售我的时间。
如果你希望和我交流，可以在公众号后台回复「微信」，联系到我。
最后如果你还愿意继续关注我的话，可以留个言，点个好看，甚至帮我多转发文章。</description>
    </item>
    
    <item>
      <title>根据 React 历史来聊如何理解虚拟 DOM</title>
      <link>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/293/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/293/</guid>
      <description>最近我发现很多面试题里面都有「如何理解虚拟 DOM」这个题，我觉得这个题应该没有想象中那么好答，因为很多人没有真正理解虚拟 DOM 它的价值所在，我这篇从虚拟 DOM 的诞生过程来引出它的价值以及历史地位，帮助你深入的理解它。
什么是虚拟DOM 本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述。
对，就是这么简单！
就是一个复杂一点的对象而已，没什么好说的，重点是为什么要有这个东西，以及有了这个描述有什么好处才是我们今天要介绍的内容。
为什么要有虚拟DOM 再谈为什么要用虚拟 DOM 之前，先来聊一聊 React 是怎么诞生的，毕竟在了解历史背景，再去思考他的诞生，就知道是必然会出现的。
再查了很多关于 React 的历史相关的文章，这篇文章我感觉比较值得令我信服：React 是怎样炼成的。
众所周知，Facebook 是 PHP 大户，所以 React 最开始的灵感就来至于 PHP。
字符串拼接时代 - 2004 在 2004 年这个时候，大家都还在用 PHP 的字符串拼接来开发网站：
$str = &amp;#39;&amp;lt;ul&amp;gt;&amp;#39;; foreach ($talks as $talk) { $str += &amp;#39;&amp;lt;li&amp;gt;&amp;#39; . $talk-&amp;gt;name . &amp;#39;&amp;lt;/li&amp;gt;&amp;#39;; } $str += &amp;#39;&amp;lt;/ul&amp;gt;&amp;#39;; 这种方式代码写出来不好看不说，还容易造成 XSS 等安全问题。
应对方法是对用户的任何输入都进行转义（Escape）。但是如果对字符串进行多次转义，那么反转义的次数也必须是相同的，否则会无法得到原内容。如果又不小心把 HTML 标签（Markup）给转义了，那么 HTML 标签会直接显示给用户，从而导致很差的用户体验。
XHP 时代 - 2010 到了 2010 年，为了更加高效的编码，同时也避免转义 HTML 标签的错误，Facebook 开发了 XHP 。XHP 是对 PHP 的语法拓展，它允许开发者直接在 PHP 中使用 HTML 标签，而不再使用字符串。</description>
    </item>
    
    <item>
      <title>认识函数式编程</title>
      <link>/posts/%E6%8A%80%E6%9C%AF/190/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%8A%80%E6%9C%AF/190/</guid>
      <description>最开始接触函数式编程的时候是在小米工作的时候，那个时候看老大以前写的代码各种 compose，然后一些 ramda 的一些工具函数，看着很吃力，然后极力吐槽函数式编程，现在回想起来，那个时候的自己真的是见识短浅，只想说,&amp;lsquo;真香&amp;rsquo;。
最近在研究函数式编程，真的是在学习的过程中感觉自己的思维提升了很多，抽象能力大大的提高了，让我深深的感受到了函数式编程的魅力。所以我打算后面用 5 到 8 篇的篇幅，详细的介绍一下函数式编程的思想，基础、如何设计、测试等。
今天这篇文章主要介绍函数式编程的思想。
函数式编程有用吗？ 什么是函数式编程？ 函数式编程的优点。 面向对象编程(OOP)通过封装变化使得代码更易理解。 函数式编程(FP)通过最小化变化使得代码更易理解。 &amp;ndash; Michacel Feathers（Twitter）
总所周知 JavaScript 是一种拥有很多共享状态的动态语言，慢慢的，代码就会积累足够的复杂性，变得笨拙难以维护。面向对象设计能帮我们在一定程度上解决这个问题，但是还不够。
由于有很多的状态，所以处理数据流和变化的传递显得尤为重要，不知道你们知道响应式编程与否，这种编程范式有助于处理 JavaScript 的异步或者事件响应。总之，当我们在设计应用程序的时候，我们应该考虑是否遵守了以下的设计原则。
可扩展性&amp;ndash;我是否需要不断地重构代码来支持额外的功能？ 易模块化&amp;ndash;如果我更改了一个文件，另一个文件是否会受到影响？ 可重用性&amp;ndash;是否有很多重复的代码？ 可测性&amp;ndash;给这些函数添加单元测试是否让我纠结？ 易推理性&amp;ndash;我写的代码是否非结构化严重并难以推理？ 我这能这么跟你说，一旦你学会了函数式编程，这些问题迎刃而解，本来函数式编程就是这个思想，一旦你掌握了函数式，然后你再学习响应式编程那就比较容易懂了，这是我亲身体会的。我之前在学 Rxjs 的时候是真的痛苦，说实话，Rxjs 是我学过最难的库了，没有之一。在经历过痛苦的一两个月之后，有些东西还是不能融会贯通，知道我最近研究函数式编程，才觉得是理所当然。毫无夸张，我也尽量在后面的文章中给大家介绍一下 Rxjs，这个话题我也在公司分享过。
什么是函数式编程？ 简单来说，函数式编程是一种强调以函数使用为主的软件开发风格。看到这句我想你还是一脸懵逼，不知道函数式编程是啥，不要着急，看到最后我相信你会明白的。
还有一点你要记住，函数式编程的目的是使用函数来抽象作用在数据之上的控制流和操作，从而在系统中消除副作用并减少对状态的改变。
下面我们通过例子来简单的演示一下函数式编程的魅力。
现在的需求就是输出在网页上输出 “Hello World”。
可能初学者会这么写。
document.querySelector(&amp;#39;#msg&amp;#39;).innerHTML = &amp;#39;&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;&amp;#39; 这个程序很简单，但是所有代码都是死的，不能重用，如果想改变消息的格式、内容等就需要重写整个表达式，所以可能有经验的前端开发者会这么写。
function printMessage(elementId, format, message) { document.querySelector(elementId).innerHTML = `&amp;lt;${format}&amp;gt;${message}&amp;lt;/${format}&amp;gt;` } printMessage(&amp;#39;msg&amp;#39;, &amp;#39;h1&amp;#39;, &amp;#39;Hello World&amp;#39;) 这样确实有所改进，但是任然不是一段可重用的代码，如果是要将文本写入文件，不是非 HTML，或者我想重复的显示 Hello World。
那么作为一个函数式开发者会怎么写这段代码呢？
const printMessage = compose(addToDom(&amp;#39;msg&amp;#39;), h1, echo) printMessage(&amp;#39;Hello World&amp;#39;) 解释一下这段代码，其中的 h1 和 echo 都是函数，addToDom 很明显也能看出它是函数，那么我们为什么要写成这样呢？看起来多了很多函数一样。</description>
    </item>
    
  </channel>
</rss>
