<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2020 年你应该知道的 React 库 | 桃园</title><meta name=keywords content="react,译文"><meta name=description content="声明：本文为译文，原文链接：https://www.robinwieruch.de/react-libraries
React 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经习惯了框架包含了所需要的所有功能，
然而对于 React 来说，它的核心并不是完善所有的可选库。 这是优势还是劣势取决于你自己。 当我从 Angular 切换到 React，我绝对经历了它作为 React 的优势。
只有通过 React，您才能使用函数组件和 props 构建组件驱动的用户界面。 它带有一些内置的解决方案，例如，用于本地状态和副作用的 React Hooks。
下面的文章将向您提供一些自己总结的方法，以便从补充库中进行选择，从而构建一个全面的 React 应用程序。
如何开始 React 如果你是一个完全不熟悉 React 的初学者想创建一个 React 项目，加入 React 的世界。有许多工具包项目可以选择，每个项目都试图满足不同的需求。 React 社区的现状是通过 Facebook 的 create-react-app(CRA)。 它提供了一个零配置的设置，并给你一个开箱即用并且简单的启动和运行的 React 应用程序。 所有的工具都对您隐藏起来了，但是最终要由您来更改这些工具。
如果你已经熟悉 React，你可以选择它流行的入门工具包之一: Next.js 和 Gatsby.js。 这两个框架都建立在 React 之上，因此你应该已经熟悉 React 的基本原理。 Next.js 用于服务器端渲染(如动态 web 应用程序) ，Gatsby.js 用于静态站点生成(如博客、登陆页面)。
如果您只是想了解这些初学者工具包是如何工作的，那么可以尝试从头开始设置 React 项目。 你将从一个基本的 HTML 和 JavaScript 项目开始，然后自己添加 React 和它的支持工具。"><meta name=author content="桃翁"><link rel=canonical href=/posts/%E8%AF%91%E6%96%87/300/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.355db47b48ce042e543348876cce64165399cee8651ce7514d3c4b076b02f0aa.css integrity="sha256-NV20e0jOBC5UM0iHbM5kFlOZzuhlHOdRTTxLB2sC8Ko=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="2020 年你应该知道的 React 库"><meta property="og:description" content="声明：本文为译文，原文链接：https://www.robinwieruch.de/react-libraries
React 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经习惯了框架包含了所需要的所有功能，
然而对于 React 来说，它的核心并不是完善所有的可选库。 这是优势还是劣势取决于你自己。 当我从 Angular 切换到 React，我绝对经历了它作为 React 的优势。
只有通过 React，您才能使用函数组件和 props 构建组件驱动的用户界面。 它带有一些内置的解决方案，例如，用于本地状态和副作用的 React Hooks。
下面的文章将向您提供一些自己总结的方法，以便从补充库中进行选择，从而构建一个全面的 React 应用程序。
如何开始 React 如果你是一个完全不熟悉 React 的初学者想创建一个 React 项目，加入 React 的世界。有许多工具包项目可以选择，每个项目都试图满足不同的需求。 React 社区的现状是通过 Facebook 的 create-react-app(CRA)。 它提供了一个零配置的设置，并给你一个开箱即用并且简单的启动和运行的 React 应用程序。 所有的工具都对您隐藏起来了，但是最终要由您来更改这些工具。
如果你已经熟悉 React，你可以选择它流行的入门工具包之一: Next.js 和 Gatsby.js。 这两个框架都建立在 React 之上，因此你应该已经熟悉 React 的基本原理。 Next.js 用于服务器端渲染(如动态 web 应用程序) ，Gatsby.js 用于静态站点生成(如博客、登陆页面)。
如果您只是想了解这些初学者工具包是如何工作的，那么可以尝试从头开始设置 React 项目。 你将从一个基本的 HTML 和 JavaScript 项目开始，然后自己添加 React 和它的支持工具。"><meta property="og:type" content="article"><meta property="og:url" content="/posts/%E8%AF%91%E6%96%87/300/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="og:site_name" content="桃园"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="2020 年你应该知道的 React 库"><meta name=twitter:description content="声明：本文为译文，原文链接：https://www.robinwieruch.de/react-libraries
React 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经习惯了框架包含了所需要的所有功能，
然而对于 React 来说，它的核心并不是完善所有的可选库。 这是优势还是劣势取决于你自己。 当我从 Angular 切换到 React，我绝对经历了它作为 React 的优势。
只有通过 React，您才能使用函数组件和 props 构建组件驱动的用户界面。 它带有一些内置的解决方案，例如，用于本地状态和副作用的 React Hooks。
下面的文章将向您提供一些自己总结的方法，以便从补充库中进行选择，从而构建一个全面的 React 应用程序。
如何开始 React 如果你是一个完全不熟悉 React 的初学者想创建一个 React 项目，加入 React 的世界。有许多工具包项目可以选择，每个项目都试图满足不同的需求。 React 社区的现状是通过 Facebook 的 create-react-app(CRA)。 它提供了一个零配置的设置，并给你一个开箱即用并且简单的启动和运行的 React 应用程序。 所有的工具都对您隐藏起来了，但是最终要由您来更改这些工具。
如果你已经熟悉 React，你可以选择它流行的入门工具包之一: Next.js 和 Gatsby.js。 这两个框架都建立在 React 之上，因此你应该已经熟悉 React 的基本原理。 Next.js 用于服务器端渲染(如动态 web 应用程序) ，Gatsby.js 用于静态站点生成(如博客、登陆页面)。
如果您只是想了解这些初学者工具包是如何工作的，那么可以尝试从头开始设置 React 项目。 你将从一个基本的 HTML 和 JavaScript 项目开始，然后自己添加 React 和它的支持工具。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"2020 年你应该知道的 React 库","item":"/posts/%E8%AF%91%E6%96%87/300/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2020 年你应该知道的 React 库","name":"2020 年你应该知道的 React 库","description":"声明：本文为译文，原文链接：https://www.robinwieruch.de/react-libraries\nReact 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经习惯了框架包含了所需要的所有功能，\n然而对于 React 来说，它的核心并不是完善所有的可选库。 这是优势还是劣势取决于你自己。 当我从 Angular 切换到 React，我绝对经历了它作为 React 的优势。\n只有通过 React，您才能使用函数组件和 props 构建组件驱动的用户界面。 它带有一些内置的解决方案，例如，用于本地状态和副作用的 React Hooks。\n下面的文章将向您提供一些自己总结的方法，以便从补充库中进行选择，从而构建一个全面的 React 应用程序。\n如何开始 React 如果你是一个完全不熟悉 React 的初学者想创建一个 React 项目，加入 React 的世界。有许多工具包项目可以选择，每个项目都试图满足不同的需求。 React 社区的现状是通过 Facebook 的 create-react-app(CRA)。 它提供了一个零配置的设置，并给你一个开箱即用并且简单的启动和运行的 React 应用程序。 所有的工具都对您隐藏起来了，但是最终要由您来更改这些工具。\n如果你已经熟悉 React，你可以选择它流行的入门工具包之一: Next.js 和 Gatsby.js。 这两个框架都建立在 React 之上，因此你应该已经熟悉 React 的基本原理。 Next.js 用于服务器端渲染(如动态 web 应用程序) ，Gatsby.js 用于静态站点生成(如博客、登陆页面)。\n如果您只是想了解这些初学者工具包是如何工作的，那么可以尝试从头开始设置 React 项目。 你将从一个基本的 HTML 和 JavaScript 项目开始，然后自己添加 React 和它的支持工具。","keywords":["react","译文"],"articleBody":" 声明：本文为译文，原文链接：https://www.robinwieruch.de/react-libraries\nReact 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经习惯了框架包含了所需要的所有功能，\n然而对于 React 来说，它的核心并不是完善所有的可选库。 这是优势还是劣势取决于你自己。 当我从 Angular 切换到 React，我绝对经历了它作为 React 的优势。\n只有通过 React，您才能使用函数组件和 props 构建组件驱动的用户界面。 它带有一些内置的解决方案，例如，用于本地状态和副作用的 React Hooks。\n下面的文章将向您提供一些自己总结的方法，以便从补充库中进行选择，从而构建一个全面的 React 应用程序。\n如何开始 React 如果你是一个完全不熟悉 React 的初学者想创建一个 React 项目，加入 React 的世界。有许多工具包项目可以选择，每个项目都试图满足不同的需求。 React 社区的现状是通过 Facebook 的 create-react-app(CRA)。 它提供了一个零配置的设置，并给你一个开箱即用并且简单的启动和运行的 React 应用程序。 所有的工具都对您隐藏起来了，但是最终要由您来更改这些工具。\n如果你已经熟悉 React，你可以选择它流行的入门工具包之一: Next.js 和 Gatsby.js。 这两个框架都建立在 React 之上，因此你应该已经熟悉 React 的基本原理。 Next.js 用于服务器端渲染(如动态 web 应用程序) ，Gatsby.js 用于静态站点生成(如博客、登陆页面)。\n如果您只是想了解这些初学者工具包是如何工作的，那么可以尝试从头开始设置 React 项目。 你将从一个基本的 HTML 和 JavaScript 项目开始，然后自己添加 React 和它的支持工具。\n如果你想选择一个自定义样板项目，试着缩小你的要求。 样板文件应该是最小的，不要试图解决所有问题。 它应该针对你的问题。 例如，gatsby-Firebase-authentication 样板文件只在 Gatsby.js 中为您提供了完整的 Firebase 身份验证机制，但是其他所有内容都被省略了。\n建议：\ncreate-react-app for React beginners/advanced Gatsby.js for static websites in React Next.js for server-side rendered React custom React project to understand the underlying tools React 状态管理 React 带有内置的 hooks 来管理局部状态: useState、 useReducer 和 useContext。 所有这些都可以在 React 中用于复杂的本地状态管理。 它甚至可以模拟 Redux(Redux 是 React 的一个流行的状态管理库)。\n所有 React 的内置 hooks 都非常适合本地状态管理。 当涉及到远程数据的状态管理时，如果远程数据带有 GraphQL 端点，我建议使用 Apollo Client。Apollo Client 的替代方案是 urql 和 Relay。\n如果远程数据不是来自 GraphQL 端点，请尝试使用 React 的 Hooks 来管理它。 如果不行，像 Redux 或者 MobX/Mobx State tree 这样的解决方案可能会有所帮助。\n如果你想了解更多细节，请访问我的综合状态管理反应教程。\n推荐：\n局部状态: React 的 useState, useReducer, useContext Hooks 通过 Graph QL 的远程状态: Apollo Client 通过 REST 的远程状态: React Hooks or Redux/MobX/Mobx State Tree 使用 React 路由 路由在 React 中起着重要作用。 毕竟，React 可以帮助您实现在客户端处理路由的单页应用程序。 当介绍一个复杂的路由 的时候，有好几个路由解决方案。 最值得推荐的解决方案是 React Router。\n在您引入路由以前，您可以先尝试 React 的条件渲染，它虽然不是路由的合理替代，但是小型应用中以及足够用了。\n建议:\nReact Router React 中的样式库 虽然关于 React 样式处理有很多解决方法，但是作为一个 React 初学者，刚开始使用内联样式和基本 CSS 是很好的。\nimport './Headline.css'; const Headline = ({ title }) =\u003e \u003ch1 className=\"headline\" style={{ color: 'blue' }}\u003e {title} \u003c/h1\u003e 虽然内联样式可以用 JavaScript 在 React 中动态地添加样式，但是一个外部的 CSS 文件可以拥有 React 应用程序的所有剩余样式。 一旦您的应用程序增长，还有许多其他样式方案选择。\n首先，我建议您研究一下 CSS Modules，将其作为 CSS-in-CSS 解决方案之一。 CSS Modules 受到 create-react-app 的支持，并为您提供了将 CSS 封装到模块中的方法。 这样，它就不会意外地泄漏到其他人的样式中。 尽管应用程序的某些部分仍然可以共享样式，但其他部分不必访问它。 在 React 中，CSS Modules 通常将 CSS 文件与 React 组件文件共存。\nimport styles from './style.css'; const Headline = ({ title }) =\u003e \u003ch1 className={styles.headline}\u003e {title} \u003c/h1\u003e 其次，我想推荐的是被称作为 styled components，作为 React 的 CSS-in-JS 解决方案之一。 这个方法是由一个名为 styled-components 的库提供的，它将样式与 JavaScript 共享到 React 组件的旁边:\nimport styled from 'styled-components'; const BlueHeadline = styled.h1` color: blue; `; const Headline = ({ title }) =\u003e \u003cBlueHeadline\u003e {title} \u003c/BlueHeadline\u003e 第三，我想推荐 Tailwind CSS 作为一个函数式的 CSS 解决方案:\nconst Headline = ({ title }) =\u003e \u003ch1 className=\"text-blue-700\"\u003e {title} \u003c/h1\u003e 是否选择 CSS in CSS、 CSS in js 或函数式 CSS 取决于您。 所有的策略都适用于大型的 React 应用程序。\n建议:\nCSS-in-CSS with CSS Modules CSS-in-JS with Styled Components Functional CSS with Tailwind CSS React UI 库 如果您不想从头开始构建所有必要的 React UI 组件，您可以选择 React UI Library 来完成这项工作。 所有这些都有一些基本的组件，比如按钮，下拉菜单，对话框和列表。 有很多 UI 库可供 React 选择:\nAnt Design Chakra UI Tailwind UI Semantic UI Material UI React Bootstrap 1. React Bootstrap React 动画 任何 web 应用程序中的动画都是从 CSS 开始的。 最终你会发现 CSS 动画并不能满足你的需求。 通常开发人员会检查 React Transition Group，这样他们就可以使用 React 组件执行动画。 其他著名的 React 动画库有:\nreact-motion react-spring Framer Motion Animated (React Native) 建议:\nReact Transition Group React 可视化和图表库 如果你真的想自己从头开始构建图表，你没办法不去学习 D3 。 这是一个底层的可视化库，它为你提供了创建令人惊叹的图表所需的一切。 然而，学习 D3 是一个完全不同的冒险，因此许多开发人员只是想选择一个 React 图表库，它可以为他们做任何事情，以换取灵活性。 以下是一些流行的解决方案:\nnivo Victory react-vis Recharts Chart Parts React 中的表单库 在 React 中最流行的表单库是 Formik。 它提供了从验证到提交到形成状态管理所需的一切。另外一个选择是 React Hook Form。 如果您开始使用更复杂的表单，这两种方法对于 React 应用程序都是有效的解决方案。\n建议:\nFormik React Hook Form React 中的数据获取库 很快，您就必须向远程 API 发出请求，以便在 React 中获取数据。 现代浏览器带有本地获取 API 来执行异步数据请求:\nfunction App() { React.useEffect(() =\u003e { const result = fetch(my/api/domain) .then(response =\u003e response.json()) .then(result =\u003e { // do success handling // e.g. store in local state }); setData(result.data); }); return ( ... ); } 基本上，你不需要添加任何其他库来完成这项工作。 但是，有时候不仅需要提供复杂的异步请求，还需要它们具有更强大的功能，而且只是一个轻量级的库。 我推荐的这些库之一称为 axios。 当您的应用程序增大时，可以使用它来代替本地获取 API。\n如果您有足够的时间来处理 GraphQL API，我建议您使用 Apollo Client。 可供选择的 GraphQL 客户端将是 urql 或 Relay。\n建议:\n浏览器的本地 fetch API axios Apollo Client React 类型检查 幸运的是 React 有自己的类型检查能力。 使用 PropTypes，你可以为你的 React 组件定义传入的 props。 无论何时向组件传递了错误的类型，在运行应用程序时都会收到错误消息。 但是这种形式的类型检查只应该用于较小的应用程序。\nimport PropTypes from 'prop-types'; const List = ({ list }) =\u003e \u003cdiv\u003e {list.map(item =\u003e \u003cdiv key={item.id}\u003e{item.title}\u003c/div\u003e)} \u003c/div\u003e List.propTypes = { list: PropTypes.array.isRequired, }; 在较大的 React 应用程序中，TypeScript 为整个应用程序增加了类型安全性，而不是使用 React PropTypes。 当使用这样的类型检查器时，您可以在开发期间获得错误。 您不必启动应用程序就可以找到本可以通过这种类型检查防止的 bug。 这样一来，类型检查器就可以提高您的开发人员体验，避免首先引入 bug。\n建议:\nTypeScript React 代码风格 对于代码风格，基本上有三个选项可以用的。\n第一种方法是遵循一个被社区所接受的风格指南。 一个流行的 Airbnb 开源的React style guide 。 即使你没有刻意遵循这些样式指南，但是读一读它们，在 React 中获得常见代码样式的要点是有意义的。\n第二种方法是使用 linter，比如 ESLint。 虽然样式指南只给出建议，但是 linter 在应用程序中强制执行这个建议。 例如，你可以要求遵循流行的 Airbnb 样式指南，你的 IED/编辑器会告诉你每一个错误。\n第三种也是最流行的方法是使用 Prettier。 它是一个强制的代码格式化程序。 您可以将其集成到编辑器或 IDE 中，使其在每次保存文件时格式化您的代码。 也许它并不总是符合您的口味，但至少您不必再担心自己或团队代码库中的代码格式。 虽然 Prettier 不能取代 ESLint，但是它与 ESLint 的集成非常好。\n建议:\nESLint Prettier React 认证 在较大的 React 应用程序中，您可能希望引入具有注册、登录和退出功能的身份验证。 此外，密码重置和密码更改功能往往是需要的。 这些特性远远超出了 React，因为后端应用程序为您管理这些事情。\n通常的方法是使用自定义身份验证实现自己的自定义后端应用程序。 如果您不想启动自己的身份验证，可以考虑类似 Passport.js 的东西。\n如果你根本不想关心后端，以下三种解决方案可能适合你:\nFirebase Auth0 AWS Cognito 如果您正在寻找身份验证 + 数据库的一体化解决方案，请坚持使用 Firebase 或 AWS。\n建议:\nDIY: Custom Backend Get it off the shelf: Firebase React 主机 您可以像其他 web 应用程序一样部署和托管 React 应用程序。 如果你想拥有完全的控制权，选择像Digital Ocean这样的。 如果你希望有人来处理所有的事情，如果你已经在使用第三方的身份验证/数据库，Netlify 是一个很受欢迎的解决方案，比如 Firebase，你可以检查他们是否也提供主机服务(比如 Firebase Hosting)。 您还可以使用 S3的静态站点与 Cloudfront 一起托管。\nReact 测试 如果您想深入了解 React 中的测试，请阅读以下内容: How to test components in React。 要点如下: 测试 React 应用程序的主干是 Jest。 它提供了测试运行程序、断言库和监视(spying)/模拟(mocking)/stubbing 功能， 一个全面的测试框架中需要的所有东西。\n至少，您可以使用 React-test-renderer 在 Jest 测试中渲染 React 组件。 这已经足以用 jest 来执行所谓的快照测试了。 快照测试的工作方式如下: 运行测试之后，将创建 React 组件中渲染的 DOM 元素的快照。 当您在某个时间点再次运行测试时，将创建另一个快照，用作前一个快照的差异。 如果 diff 不完全相同，则 Jest 将报错，您要么必须接受快照，要么必须更改组件的实现。\n最终，您会发现自己在使用 Enzyme 或 React Testing Library (这两个都在 Jest 测试环境中使用)来进行更详细的测试功能集。 这两个库使得在 HTML 元素上呈现组件和模拟事件成为可能。 然后，Jest 用于 DOM 节点上的断言。\n如果您正在为 React-to-end (E2E)测试寻找测试工具，Cypress 是最受欢迎的选择。\n建议:\nUnit/Integration/Snapshot Tests: Jest + React Testing Library E2E Tests: Cypress 2e test: Cypress 用于 React 的工具库 Javascript 为处理数组、对象、数字、对象和字符串提供了大量内置功能。 React 中最常用的 JavaScript 内置功能之一是内置 map() 数组。 为什么？ 因为您总是必须呈现组件中的列表。 由于 JSX 是 HTML 和 JavaScript 的混合物，所以您可以使用 JavaScript 在数组上进行映射并返回 JSX。 使用 React 创建列表组件变得简单:\nconst List = ({ list }) =\u003e \u003cdiv\u003e {list.map(item =\u003e \u003cdiv key={item.id}\u003e{item.title}\u003c/div\u003e)} \u003c/div\u003e 但是，您可能需要选择一个实用程序库来提供更详细的功能。 您甚至可能希望在将这些实用函数链接起来时更加灵活，甚至可以将它们动态地组合在一起。 这时，您将引入一个实用程序库: Lodash 或 Ramda。 对于每一个 JavaScript 开发者来说，Lodash 是一个更加实际的库，而 Ramda 在函数式编程中有一个强大的核心。 请记住，现代 JavaScript 提供了很多开箱即用的特性，现在使用实用程序库的必要性已经降低了。\n建议:\nJavaScript Lodash react 和不可变的数据机构 原生 JavaScript 提供了大量内置工具来处理数据结构，就像它们是不可变的一样。 但是，如果您和您的团队认为有必要实施不可变的数据结构，最流行的选择之一是 Immer。 就我个人而言，我不使用它，但是任何时候有人问到 JS 中的不变性(immutability)，大家都会指出 Immer，并且这可以加上 redux 或 React hooks。\nReact 国际化 当涉及到 React 应用程序的国际化 时，您不仅需要考虑翻译，还需要考虑多元化、日期和货币的格式化，以及其他一些事项。 以下是最受欢迎的处理该问题的库:\nreact-i18next react-intl LinguiJS FBT 建议:\nreact-i18next React 富文本编辑器 当涉及到在 React 中的富文本编辑器时，我只能想到以下内容，因为我没有在 React 中使用任何其他内容:\nDraft.js Slate React 中的支付 和其他网络应用一样，最常见的支付提供商是 Stripe 和 PayPal。 两者都可以整齐地集成到 React 中。\nPayPal Stripe Elements 或 Stripe Checkout React 中的时间 如果你的 React 应用程序正在处理大量的日期和时区，你应该引入一个库来为你管理这些事情。 最受欢迎的库是 moment.js。 更轻量级的替代品是 date-fns 和 Day.js。\nReac 桌面应用 Electron 是跨平台桌面应用程序的首选框架。 不过，也有其他选择，例如:\nNW.js Neutralino.js React 的移动开发 我想把 React 从网络带到移动设备的首选解决方案仍然是 React Native。 如果您是 React Native 开发人员，想要创建一个 Web 应用程序，您应该查看 React Native Web。\nREACT VR/AR 实话说，我们很有可能用 React 深入虚拟现实或者增强现实中，我没有使用过这些库中的任何一个，但是它们是我在谈到 React AR/VR 时从大脑闪过的就是：\nReact 360 react-viro react-native-arkit 为 React 设计原型 如果您来自 UI/UX 背景，那么您可能希望使用一个工具为新的 React 组件、布局或 UI/UX 概念进行快速原型设计。 我以前用过 Sketch，但最近转到了 Figma。 尽管我两者都喜欢，但我现在并不后悔使用 Figma。 另一个流行的工具是 Framer。\n为 React 书写文档 如果你负责为你的软件、 UI 库或者其他东西编写文档，那么你可以使用一些简洁的 React 文档工具。 我已经广泛地使用了 Storybook，我可以说他非常好用，但是我也听说了其他解决方案的好处:\nStyleguidist docz Docusaurus 总结 所以最终，React 生态系统可以看作是一个 React 的框架，但它保持灵活性。 它是一个灵活的框架，您可以自己决定选择哪些库。 您可以从小型开始，只添加库来解决特定的问题。 当应用程序增长时，您可以沿途扩展构建块。 否则你可以通过使用普通的 React 来保持轻量级。 因此，这里再次列出了可以补充 React 作为应用程序关于不同项目大小的核心的库。 请记住，这个列表是我的个人看法，我也渴望得到你的反馈。\n小型应用程式 样板: create-react-app 样式库: basic CSS and inline style 异步请求: fetch or axios 代码风格: 无 类型检查: 无 状态管理: React Hooks 路由: 无 or React Router 身份验证: Firebase 数据库: Firebase UI 库: none 表单库: 无 测试库: Jest 实用程序库: JavaScript 国际化: react-i18next React 桌面: Electron 中型应用 样板文件: Next.js or Gatsby.js 样式库: CSS Modules or Styled Components 异步请求: fetch or axios 代码风格: Prettier，ESLint 类型检查: 无 或 TypeScript 状态管理: React Hooks and/or Apollo 路由: React Router 身份验证: Firebase 数据库: Firebase Ui 库: none 或 UI 组件库 表单库: none 或 Formik 或 React Hook Form 测试库: Jest with React Testing Library 实用程序库: JavaScript 国际化: react-i18next React 桌面: Electron 大型应用程序 样板文件: Next.js, Gatsby.js, custom setup 样式库: CSS Modules or Styled Components 异步请求: axios 或 Apollo Client 代码风格: Prettier，ESLint 类型检查: TypeScript 状态管理: React Hooks and/或者 Apollo/Redux/MobX 路由: React Router 认证: Node.js 服务 + Passport.js 数据库: 自己用SQL/NoSQL DB 提供 Node.js 服务 Ui 库: UI 组件库或者您自己的 UI 组件 **表单库:**none 或者 Formik 或者 React Hook Form 测试库: Jest with React Testing Library and Cypress 实用程序库: JavaScript 的 api，Lodash 国际化: react-i18next React 桌面: Electron 以前的建议是个人的。 您可以为理想的 React 应用程序选择自己的灵活框架。 每一个“理想”的 React 设置都是主观的，取决于开发人员和项目的需求。 毕竟，没有理想的 React 应用程序设置。\n","wordCount":"1109","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"桃翁"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E8%AF%91%E6%96%87/300/"},"publisher":{"@type":"Organization","name":"桃园","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/archives/ title=Archives><span>Archives</span></a></li><li><a href=/categories/ title=Categories><span>Categories</span></a></li><li><a href=search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>2020 年你应该知道的 React 库</h1><div class=post-meta>6 min&nbsp;·&nbsp;1109 words&nbsp;·&nbsp;桃翁&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/%e8%af%91%e6%96%87/2020-02-18-2020_%e5%b9%b4%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e9%81%93%e7%9a%84_React_%e5%ba%93.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%a6%82%e4%bd%95%e5%bc%80%e5%a7%8b-react aria-label="如何开始 React">如何开始 React</a></li><li><a href=#react-%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86 aria-label="React 状态管理">React 状态管理</a></li><li><a href=#%e4%bd%bf%e7%94%a8-react-%e8%b7%af%e7%94%b1 aria-label="使用 React 路由">使用 React 路由</a></li><li><a href=#react-%e4%b8%ad%e7%9a%84%e6%a0%b7%e5%bc%8f%e5%ba%93 aria-label="React 中的样式库">React 中的样式库</a></li><li><a href=#react-ui-%e5%ba%93 aria-label="React UI 库">React UI 库</a></li><li><a href=#react-%e5%8a%a8%e7%94%bb aria-label="React 动画">React 动画</a></li><li><a href=#react-%e5%8f%af%e8%a7%86%e5%8c%96%e5%92%8c%e5%9b%be%e8%a1%a8%e5%ba%93 aria-label="React 可视化和图表库">React 可视化和图表库</a></li><li><a href=#react-%e4%b8%ad%e7%9a%84%e8%a1%a8%e5%8d%95%e5%ba%93 aria-label="React 中的表单库">React 中的表单库</a></li><li><a href=#react-%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e8%8e%b7%e5%8f%96%e5%ba%93 aria-label="React 中的数据获取库">React 中的数据获取库</a></li><li><a href=#react-%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5 aria-label="React 类型检查">React 类型检查</a></li><li><a href=#react-%e4%bb%a3%e7%a0%81%e9%a3%8e%e6%a0%bc aria-label="React 代码风格">React 代码风格</a></li><li><a href=#react-%e8%ae%a4%e8%af%81 aria-label="React 认证">React 认证</a></li><li><a href=#react-%e4%b8%bb%e6%9c%ba aria-label="React 主机">React 主机</a></li><li><a href=#react-%e6%b5%8b%e8%af%95 aria-label="React 测试">React 测试</a></li><li><a href=#%e7%94%a8%e4%ba%8e-react-%e7%9a%84%e5%b7%a5%e5%85%b7%e5%ba%93 aria-label="用于 React 的工具库">用于 React 的工具库</a></li><li><a href=#react-%e5%92%8c%e4%b8%8d%e5%8f%af%e5%8f%98%e7%9a%84%e6%95%b0%e6%8d%ae%e6%9c%ba%e6%9e%84 aria-label="react 和不可变的数据机构">react 和不可变的数据机构</a></li><li><a href=#react-%e5%9b%bd%e9%99%85%e5%8c%96 aria-label="React 国际化">React 国际化</a></li><li><a href=#react-%e5%af%8c%e6%96%87%e6%9c%ac%e7%bc%96%e8%be%91%e5%99%a8 aria-label="React 富文本编辑器">React 富文本编辑器</a></li><li><a href=#react-%e4%b8%ad%e7%9a%84%e6%94%af%e4%bb%98 aria-label="React 中的支付">React 中的支付</a></li><li><a href=#react-%e4%b8%ad%e7%9a%84%e6%97%b6%e9%97%b4 aria-label="React 中的时间">React 中的时间</a></li><li><a href=#reac-%e6%a1%8c%e9%9d%a2%e5%ba%94%e7%94%a8 aria-label="Reac 桌面应用">Reac 桌面应用</a></li><li><a href=#react-%e7%9a%84%e7%a7%bb%e5%8a%a8%e5%bc%80%e5%8f%91 aria-label="React 的移动开发">React 的移动开发</a></li><li><a href=#react-vrar aria-label="REACT VR/AR">REACT VR/AR</a></li><li><a href=#%e4%b8%ba-react-%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%9e%8b aria-label="为 React 设计原型">为 React 设计原型</a></li><li><a href=#%e4%b8%ba-react-%e4%b9%a6%e5%86%99%e6%96%87%e6%a1%a3 aria-label="为 React 书写文档">为 React 书写文档</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a><ul><li><a href=#%e5%b0%8f%e5%9e%8b%e5%ba%94%e7%94%a8%e7%a8%8b%e5%bc%8f aria-label=小型应用程式>小型应用程式</a></li><li><a href=#%e4%b8%ad%e5%9e%8b%e5%ba%94%e7%94%a8 aria-label=中型应用>中型应用</a></li><li><a href=#%e5%a4%a7%e5%9e%8b%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f aria-label=大型应用程序>大型应用程序</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>声明：本文为译文，原文链接：https://www.robinwieruch.de/react-libraries</p></blockquote><p>React 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经习惯了框架包含了所需要的所有功能，</p><p>然而对于 React 来说，它的核心并不是完善所有的可选库。 这是优势还是劣势取决于你自己。 <a href=https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/>当我从 Angular 切换到 React</a>，我绝对经历了它作为 React 的优势。</p><p>只有通过 React，您才能使用<a href=https://www.robinwieruch.de/react-function-component>函数组件</a>和 <a href=https://www.robinwieruch.de/react-pass-props-to-component>props</a> 构建组件驱动的用户界面。 它带有一些内置的解决方案，例如，用于本地状态和副作用的 React Hooks。</p><p>下面的文章将向您提供一些自己总结的方法，以便从补充库中进行选择，从而构建一个全面的 React 应用程序。</p><h2 id=如何开始-react>如何开始 React<a hidden class=anchor aria-hidden=true href=#如何开始-react>#</a></h2><p>如果你是一个完全不熟悉 React 的初学者想创建一个 React 项目，加入 React 的世界。有许多工具包项目可以选择，每个项目都试图满足不同的需求。 React 社区的现状是通过 Facebook 的 <a href=https://github.com/facebookincubator/create-react-app>create-react-app(CRA)</a>。 它提供了一个零配置的设置，并给你一个开箱即用并且简单的启动和运行的 React 应用程序。 所有的工具都对您隐藏起来了，但是最终要由您来更改这些工具。</p><p>如果你已经熟悉 React，你可以选择它流行的入门工具包之一: Next.js 和 Gatsby.js。 这两个框架都建立在 React 之上，因此你应该已经熟悉 React 的基本原理。 Next.js 用于服务器端渲染(如动态 web 应用程序) ，Gatsby.js 用于静态站点生成(如博客、登陆页面)。</p><p>如果您只是想了解这些初学者工具包是如何工作的，那么可以尝试<a href=https://www.robinwieruch.de/minimal-react-webpack-babel-setup>从头开始设置 React 项目</a>。 你将从一个基本的 HTML 和 JavaScript 项目开始，然后自己添加 React 和它的支持工具。</p><p>如果你想选择一个自定义样板项目，试着缩小你的要求。 样板文件应该是最小的，不要试图解决所有问题。 它应该针对你的问题。 例如，<a href=https://github.com/rwieruch/gatsby-firebase-authentication>gatsby-Firebase-authentication</a> 样板文件只在 Gatsby.js 中为您提供了完整的 Firebase 身份验证机制，但是其他所有内容都被省略了。</p><p><strong>建议：</strong></p><ul><li>create-react-app for React beginners/advanced</li><li>Gatsby.js for static websites in React</li><li>Next.js for server-side rendered React</li><li>custom React project to understand the underlying tools</li></ul><h2 id=react-状态管理>React 状态管理<a hidden class=anchor aria-hidden=true href=#react-状态管理>#</a></h2><p>React 带有内置的 hooks 来管理局部状态: useState、 useReducer 和 useContext。 所有这些都可以在 React 中用于复杂的本地状态管理。 它甚至可以模拟 Redux(Redux 是 React 的一个流行的状态管理库)。</p><p>所有 React 的内置 hooks 都非常适合本地状态管理。 当涉及到远程数据的状态管理时，如果远程数据带有 GraphQL 端点，我建议使用 Apollo Client。Apollo Client 的替代方案是 <a href=https://github.com/FormidableLabs/urql>urql</a> 和 <a href=https://relay.dev/>Relay</a>。</p><p>如果远程数据不是来自 GraphQL 端点，请尝试使用 React 的 Hooks 来管理它。 如果不行，像 <a href=https://www.robinwieruch.de/react-redux-tutorial>Redux</a> 或者 <a href=https://mobx.js.org/>MobX</a>/<a href=https://mobx-state-tree.js.org/>Mobx State tree</a> 这样的解决方案可能会有所帮助。</p><p>如果你想了解更多细节，请访问我的<a href=https://www.robinwieruch.de/react-state>综合状态管理反应教程</a>。</p><p><strong>推荐：</strong></p><ul><li>局部状态: React 的 useState, useReducer, useContext Hooks</li><li>通过 Graph QL 的远程状态: Apollo Client</li><li>通过 REST 的远程状态: React Hooks or Redux/MobX/Mobx State Tree</li></ul><h2 id=使用-react-路由>使用 React 路由<a hidden class=anchor aria-hidden=true href=#使用-react-路由>#</a></h2><p>路由在 React 中起着重要作用。 毕竟，React 可以帮助您实现在客户端处理路由的单页应用程序。 当介绍一个复杂的路由 的时候，有好几个路由解决方案。 最值得推荐的解决方案是 <a href=https://github.com/ReactTraining/react-router>React Router</a>。</p><p>在您引入路由以前，您可以先尝试 <a href=https://www.robinwieruch.de/conditional-rendering-react>React 的条件渲染</a>，它虽然不是路由的合理替代，但是小型应用中以及足够用了。</p><p><strong>建议:</strong></p><ul><li>React Router</li></ul><h2 id=react-中的样式库>React 中的样式库<a hidden class=anchor aria-hidden=true href=#react-中的样式库>#</a></h2><p>虽然关于 React 样式处理有很多解决方法，但是作为一个 React 初学者，刚开始使用内联样式和基本 CSS 是很好的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>import</span> <span class=s1>&#39;./Headline.css&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>Headline</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>title</span> <span class=p>})</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>h1</span> <span class=nx>className</span><span class=o>=</span><span class=s2>&#34;headline&#34;</span> <span class=nx>style</span><span class=o>=</span><span class=p>{{</span> <span class=nx>color</span><span class=o>:</span> <span class=s1>&#39;blue&#39;</span> <span class=p>}}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span><span class=nx>title</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span></code></pre></div><p>虽然内联样式可以用 JavaScript 在 React 中动态地添加样式，但是一个外部的 CSS 文件可以拥有 React 应用程序的所有剩余样式。 一旦您的应用程序增长，还有许多其他样式方案选择。</p><p>首先，我建议您研究一下 CSS Modules，将其作为 CSS-in-CSS 解决方案之一。 CSS Modules 受到 create-react-app 的支持，并为您提供了将 CSS 封装到模块中的方法。 这样，它就不会意外地泄漏到其他人的样式中。 尽管应用程序的某些部分仍然可以共享样式，但其他部分不必访问它。 在 React 中，CSS Modules 通常将 CSS 文件与 React 组件文件共存。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>import</span> <span class=nx>styles</span> <span class=nx>from</span> <span class=s1>&#39;./style.css&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>Headline</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>title</span> <span class=p>})</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nx>h1</span> <span class=nx>className</span><span class=o>=</span><span class=p>{</span><span class=nx>styles</span><span class=p>.</span><span class=nx>headline</span><span class=p>}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nx>title</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span></code></pre></div><p>其次，我想推荐的是被称作为 styled components，作为 React 的 CSS-in-JS 解决方案之一。 这个方法是由一个名为 <a href=https://www.robinwieruch.de/react-styled-components>styled-components</a> 的库提供的，它将样式与 JavaScript 共享到 React 组件的旁边:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>import</span> <span class=nx>styled</span> <span class=nx>from</span> <span class=s1>&#39;styled-components&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>BlueHeadline</span> <span class=o>=</span> <span class=nx>styled</span><span class=p>.</span><span class=nx>h1</span><span class=sb>`
</span></span></span><span class=line><span class=cl><span class=sb>  color: blue;
</span></span></span><span class=line><span class=cl><span class=sb>`</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>Headline</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>title</span> <span class=p>})</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nx>BlueHeadline</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nx>title</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=err>/BlueHeadline&gt;</span>
</span></span></code></pre></div><p>第三，我想推荐 <a href=https://tailwindcss.com/>Tailwind CSS</a> 作为一个函数式的 CSS 解决方案:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>Headline</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>title</span> <span class=p>})</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nx>h1</span> <span class=nx>className</span><span class=o>=</span><span class=s2>&#34;text-blue-700&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nx>title</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span></code></pre></div><p>是否选择 CSS in CSS、 CSS in js 或函数式 CSS 取决于您。 所有的策略都适用于大型的 React 应用程序。</p><p><strong>建议:</strong></p><ul><li>CSS-in-CSS with CSS Modules</li><li>CSS-in-JS with Styled Components</li><li>Functional CSS with Tailwind CSS</li></ul><h2 id=react-ui-库>React UI 库<a hidden class=anchor aria-hidden=true href=#react-ui-库>#</a></h2><p>如果您不想从头开始构建所有必要的 React UI 组件，您可以选择 React UI Library 来完成这项工作。 所有这些都有一些基本的组件，比如按钮，下拉菜单，对话框和列表。 有很多 UI 库可供 React 选择:</p><ul><li><a href=https://ant.design/>Ant Design</a></li><li><a href=https://chakra-ui.com/>Chakra UI</a></li><li><a href=https://www.tailwindui.com/>Tailwind UI</a></li><li><a href=https://www.robinwieruch.de/react-semantic-ui-tutorial>Semantic UI</a></li><li><a href=https://material-ui.com/>Material UI</a></li><li><a href=https://react-bootstrap.github.io/>React Bootstrap 1. React Bootstrap</a></li></ul><h2 id=react-动画>React 动画<a hidden class=anchor aria-hidden=true href=#react-动画>#</a></h2><p>任何 web 应用程序中的动画都是从 CSS 开始的。 最终你会发现 CSS 动画并不能满足你的需求。 通常开发人员会检查 <a href=https://reactcommunity.org/react-transition-group/>React Transition Group</a>，这样他们就可以使用 React 组件执行动画。 其他著名的 React 动画库有:</p><ul><li><a href=https://github.com/chenglou/react-motion>react-motion</a></li><li><a href=https://github.com/react-spring/react-spring>react-spring</a></li><li><a href=https://www.framer.com/motion/>Framer Motion</a></li><li><a href=https://facebook.github.io/react-native/docs/animated>Animated</a> (React Native)</li></ul><p><strong>建议:</strong></p><ul><li>React Transition Group</li></ul><h2 id=react-可视化和图表库>React 可视化和图表库<a hidden class=anchor aria-hidden=true href=#react-可视化和图表库>#</a></h2><p>如果你真的想自己从头开始构建图表，你没办法不去学习 <a href=https://d3js.org/>D3</a> 。 这是一个底层的可视化库，它为你提供了创建令人惊叹的图表所需的一切。 然而，学习 D3 是一个完全不同的冒险，因此许多开发人员只是想选择一个 React 图表库，它可以为他们做任何事情，以换取灵活性。 以下是一些流行的解决方案:</p><ul><li><a href=https://nivo.rocks/>nivo</a></li><li><a href=https://formidable.com/open-source/victory/>Victory</a></li><li><a href=https://uber.github.io/react-vis/>react-vis</a></li><li><a href=http://recharts.org/>Recharts</a></li><li><a href=https://microsoft.github.io/chart-parts/>Chart Parts</a></li></ul><h2 id=react-中的表单库>React 中的表单库<a hidden class=anchor aria-hidden=true href=#react-中的表单库>#</a></h2><p>在 React 中最流行的表单库是 <a href=https://github.com/jaredpalmer/>Formik</a>。 它提供了从验证到提交到形成状态管理所需的一切。另外一个选择是 <a href=https://react-hook-form.com/>React Hook Form</a>。 如果您开始使用更复杂的表单，这两种方法对于 React 应用程序都是有效的解决方案。</p><p><strong>建议:</strong></p><ul><li>Formik</li><li>React Hook Form</li></ul><h2 id=react-中的数据获取库>React 中的数据获取库<a hidden class=anchor aria-hidden=true href=#react-中的数据获取库>#</a></h2><p>很快，您就必须向远程 API 发出请求，以便在 React 中获取数据。 现代浏览器带有本地获取 API 来执行异步数据请求:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>React</span><span class=p>.</span><span class=nx>useEffect</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>fetch</span><span class=p>(</span><span class=nx>my</span><span class=o>/</span><span class=nx>api</span><span class=o>/</span><span class=nx>domain</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>response</span> <span class=p>=&gt;</span> <span class=nx>response</span><span class=p>.</span><span class=nx>json</span><span class=p>())</span>
</span></span><span class=line><span class=cl>      <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do success handling
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// e.g. store in local state
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=nx>setData</span><span class=p>(</span><span class=nx>result</span><span class=p>.</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>基本上，你不需要添加任何其他库来完成这项工作。 但是，有时候不仅需要提供复杂的异步请求，还需要它们具有更强大的功能，而且只是一个轻量级的库。 我推荐的这些库之一称为 axios。 当您的应用程序增大时，可以使用它来代替本地获取 API。</p><p>如果您有足够的时间来处理 GraphQL API，我建议您使用 Apollo Client。 可供选择的 GraphQL 客户端将是 urql 或 Relay。</p><p><strong>建议:</strong></p><ul><li>浏览器的本地 fetch API</li><li>axios</li><li>Apollo Client</li></ul><h2 id=react-类型检查>React 类型检查<a hidden class=anchor aria-hidden=true href=#react-类型检查>#</a></h2><p>幸运的是 React 有自己的类型检查能力。 使用 PropTypes，你可以为你的 React 组件定义传入的 props。 无论何时向组件传递了错误的类型，在运行应用程序时都会收到错误消息。 但是这种形式的类型检查只应该用于较小的应用程序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>import</span> <span class=nx>PropTypes</span> <span class=nx>from</span> <span class=s1>&#39;prop-types&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>List</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>list</span> <span class=p>})</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nx>list</span><span class=p>.</span><span class=nx>map</span><span class=p>(</span><span class=nx>item</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>div</span> <span class=nx>key</span><span class=o>=</span><span class=p>{</span><span class=nx>item</span><span class=p>.</span><span class=nx>id</span><span class=p>}</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>item</span><span class=p>.</span><span class=nx>title</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/div&gt;)}</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>List</span><span class=p>.</span><span class=nx>propTypes</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>list</span><span class=o>:</span> <span class=nx>PropTypes</span><span class=p>.</span><span class=nx>array</span><span class=p>.</span><span class=nx>isRequired</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在较大的 React 应用程序中，TypeScript 为整个应用程序增加了类型安全性，而不是使用 React PropTypes。 当使用这样的类型检查器时，您可以在开发期间获得错误。 您不必启动应用程序就可以找到本可以通过这种类型检查防止的 bug。 这样一来，类型检查器就可以提高您的开发人员体验，避免首先引入 bug。</p><p><strong>建议:</strong></p><ul><li>TypeScript</li></ul><h2 id=react-代码风格>React 代码风格<a hidden class=anchor aria-hidden=true href=#react-代码风格>#</a></h2><p>对于代码风格，基本上有三个选项可以用的。</p><p>第一种方法是遵循一个被社区所接受的风格指南。 一个流行的 Airbnb 开源的<a href=https://github.com/airbnb/javascript/tree/master/react>React style guide</a> 。 即使你没有刻意遵循这些样式指南，但是读一读它们，在 React 中获得常见代码样式的要点是有意义的。</p><p>第二种方法是使用 linter，比如 ESLint。 虽然样式指南只给出建议，但是 linter 在应用程序中强制执行这个建议。 例如，你可以要求遵循流行的 Airbnb 样式指南，你的 IED/编辑器会告诉你每一个错误。</p><p>第三种也是最流行的方法是使用 Prettier。 它是一个强制的代码格式化程序。 您可以将其集成到编辑器或 IDE 中，使其在每次保存文件时格式化您的代码。 也许它并不总是符合您的口味，但至少您不必再担心自己或团队代码库中的代码格式。 虽然 Prettier 不能取代 ESLint，但是它与 ESLint 的集成非常好。</p><p><strong>建议:</strong></p><ul><li>ESLint</li><li>Prettier</li></ul><h2 id=react-认证>React 认证<a hidden class=anchor aria-hidden=true href=#react-认证>#</a></h2><p>在较大的 React 应用程序中，您可能希望引入具有注册、登录和退出功能的身份验证。 此外，密码重置和密码更改功能往往是需要的。 这些特性远远超出了 React，因为后端应用程序为您管理这些事情。</p><p>通常的方法是使用自定义身份验证实现自己的自定义后端应用程序。 如果您不想启动自己的身份验证，可以考虑类似 <a href=http://www.passportjs.org/>Passport.js</a> 的东西。</p><p>如果你根本不想关心后端，以下三种解决方案可能适合你:</p><ul><li><a href=https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial/>Firebase</a></li><li><a href=https://auth0.com/>Auth0</a></li><li><a href=https://aws.amazon.com/cognito/>AWS Cognito</a></li></ul><p>如果您正在寻找身份验证 + 数据库的一体化解决方案，请坚持使用 Firebase 或 AWS。</p><p>建议:</p><ul><li>DIY: Custom Backend</li><li>Get it off the shelf: Firebase</li></ul><h2 id=react-主机>React 主机<a hidden class=anchor aria-hidden=true href=#react-主机>#</a></h2><p>您可以像其他 web 应用程序一样部署和托管 React 应用程序。 如果你想拥有完全的控制权，选择像<a href=https://m.do.co/c/fb27c90322f3>Digital Ocean</a>这样的。 如果你希望有人来处理所有的事情，如果你已经在使用第三方的身份验证/数据库，Netlify 是一个很受欢迎的解决方案，比如 Firebase，你可以检查他们是否也提供主机服务(比如 Firebase Hosting)。 您还可以使用 S3的静态站点与 Cloudfront 一起托管。</p><h2 id=react-测试>React 测试<a hidden class=anchor aria-hidden=true href=#react-测试>#</a></h2><p>如果您想深入了解 React 中的测试，请阅读以下内容: <a href=https://www.robinwieruch.de/react-testing-tutorial>How to test components in React</a>。 要点如下: 测试 React 应用程序的主干是 Jest。 它提供了测试运行程序、断言库和监视(spying)/模拟(mocking)/stubbing 功能， 一个全面的测试框架中需要的所有东西。</p><p>至少，您可以使用 <a href=https://reactjs.org/docs/test-renderer.html>React-test-renderer</a> 在 Jest 测试中渲染 React 组件。 这已经足以用 jest 来执行所谓的<a href=https://www.robinwieruch.de/react-testing-jest>快照测试</a>了。 快照测试的工作方式如下: 运行测试之后，将创建 React 组件中渲染的 DOM 元素的快照。 当您在某个时间点再次运行测试时，将创建另一个快照，用作前一个快照的差异。 如果 diff 不完全相同，则 Jest 将报错，您要么必须接受快照，要么必须更改组件的实现。</p><p>最终，您会发现自己在使用 Enzyme 或 React Testing Library (这两个都在 Jest 测试环境中使用)来进行更详细的测试功能集。 这两个库使得在 HTML 元素上呈现组件和模拟事件成为可能。 然后，Jest 用于 DOM 节点上的断言。</p><p>如果您正在为 React-to-end (E2E)测试寻找测试工具，Cypress 是最受欢迎的选择。</p><p>建议:</p><ul><li>Unit/Integration/Snapshot Tests: Jest + React Testing Library</li><li>E2E Tests: Cypress 2e test: Cypress</li></ul><h2 id=用于-react-的工具库>用于 React 的工具库<a hidden class=anchor aria-hidden=true href=#用于-react-的工具库>#</a></h2><p>Javascript 为处理数组、对象、数字、对象和字符串提供了大量内置功能。 React 中最常用的 JavaScript 内置功能之一是内置 <code>map()</code> 数组。 为什么？ 因为您总是必须呈现组件中的列表。 由于 JSX 是 HTML 和 JavaScript 的混合物，所以您可以使用 JavaScript 在数组上进行映射并返回 JSX。 使用 React 创建列表组件变得简单:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>List</span> <span class=o>=</span> <span class=p>({</span> <span class=nx>list</span> <span class=p>})</span> <span class=p>=&gt;</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nx>list</span><span class=p>.</span><span class=nx>map</span><span class=p>(</span><span class=nx>item</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>div</span> <span class=nx>key</span><span class=o>=</span><span class=p>{</span><span class=nx>item</span><span class=p>.</span><span class=nx>id</span><span class=p>}</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>item</span><span class=p>.</span><span class=nx>title</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/div&gt;)}</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span></code></pre></div><p>但是，您可能需要选择一个实用程序库来提供更详细的功能。 您甚至可能希望在将这些实用函数链接起来时更加灵活，甚至可以将它们动态地组合在一起。 这时，您将引入一个实用程序库: Lodash 或 Ramda。 对于每一个 JavaScript 开发者来说，Lodash 是一个更加实际的库，而 Ramda 在函数式编程中有一个强大的核心。 请记住，现代 JavaScript 提供了很多开箱即用的特性，现在使用实用程序库的必要性已经降低了。</p><p><strong>建议:</strong></p><ul><li>JavaScript</li><li>Lodash</li></ul><h2 id=react-和不可变的数据机构>react 和不可变的数据机构<a hidden class=anchor aria-hidden=true href=#react-和不可变的数据机构>#</a></h2><p>原生 JavaScript 提供了大量内置工具来处理数据结构，就像它们是不可变的一样。 但是，如果您和您的团队认为有必要实施不可变的数据结构，最流行的选择之一是 Immer。 就我个人而言，我不使用它，但是任何时候有人问到 JS 中的不变性(immutability)，大家都会指出 Immer，并且这可以加上 redux 或 React hooks。</p><h2 id=react-国际化>React 国际化<a hidden class=anchor aria-hidden=true href=#react-国际化>#</a></h2><p>当涉及到 <a href=https://www.robinwieruch.de/react-internationalization>React 应用程序的国际化</a> 时，您不仅需要考虑翻译，还需要考虑多元化、日期和货币的格式化，以及其他一些事项。 以下是最受欢迎的处理该问题的库:</p><ul><li><a href=https://github.com/i18next/react-i18next>react-i18next</a></li><li><a href=https://github.com/formatjs/react-intl>react-intl</a></li><li><a href=https://lingui.js.org/index.html>LinguiJS</a></li><li><a href=https://github.com/facebookincubator/fbt>FBT</a></li></ul><p><strong>建议:</strong></p><ul><li>react-i18next</li></ul><h2 id=react-富文本编辑器>React 富文本编辑器<a hidden class=anchor aria-hidden=true href=#react-富文本编辑器>#</a></h2><p>当涉及到在 React 中的富文本编辑器时，我只能想到以下内容，因为我没有在 React 中使用任何其他内容:</p><ul><li><a href=https://draftjs.org/>Draft.js</a></li><li><a href=https://github.com/ianstormtaylor/slate>Slate</a></li></ul><h2 id=react-中的支付>React 中的支付<a hidden class=anchor aria-hidden=true href=#react-中的支付>#</a></h2><p>和其他网络应用一样，最常见的支付提供商是 Stripe 和 PayPal。 两者都可以整齐地集成到 React 中。</p><ul><li><a href=https://developer.paypal.com/docs/checkout/>PayPal</a></li><li><a href=https://github.com/stripe/react-stripe-elements>Stripe Elements</a> 或 <a href=https://stripe.com/docs/payments/checkout>Stripe Checkout</a></li></ul><h2 id=react-中的时间>React 中的时间<a hidden class=anchor aria-hidden=true href=#react-中的时间>#</a></h2><p>如果你的 React 应用程序正在处理大量的日期和时区，你应该引入一个库来为你管理这些事情。 最受欢迎的库是 <a href=https://momentjs.com/>moment.js</a>。 更轻量级的替代品是 <a href=https://github.com/date-fns/date-fns>date-fns</a> 和 <a href=https://github.com/iamkun/dayjs>Day.js</a>。</p><h2 id=reac-桌面应用>Reac 桌面应用<a hidden class=anchor aria-hidden=true href=#reac-桌面应用>#</a></h2><p>Electron 是跨平台桌面应用程序的首选框架。 不过，也有其他选择，例如:</p><ul><li><a href=https://nwjs.io/>NW.js</a></li><li><a href=https://github.com/neutralinojs/neutralinojs>Neutralino.js</a></li></ul><h2 id=react-的移动开发>React 的移动开发<a hidden class=anchor aria-hidden=true href=#react-的移动开发>#</a></h2><p>我想把 React 从网络带到移动设备的首选解决方案仍然是 React Native。 如果您是 React Native 开发人员，想要创建一个 Web 应用程序，您应该查看 <a href=https://github.com/necolas/react-native-web>React Native Web</a>。</p><h2 id=react-vrar>REACT VR/AR<a hidden class=anchor aria-hidden=true href=#react-vrar>#</a></h2><p>实话说，我们很有可能用 React 深入虚拟现实或者增强现实中，我没有使用过这些库中的任何一个，但是它们是我在谈到 React AR/VR 时从大脑闪过的就是：</p><ul><li><a href=https://facebook.github.io/react-360/>React 360</a></li><li><a href=https://www.npmjs.com/package/react-viro>react-viro</a></li><li><a href=https://github.com/react-native-ar/react-native-arkit>react-native-arkit</a></li></ul><h2 id=为-react-设计原型>为 React 设计原型<a hidden class=anchor aria-hidden=true href=#为-react-设计原型>#</a></h2><p>如果您来自 UI/UX 背景，那么您可能希望使用一个工具为新的 React 组件、布局或 UI/UX 概念进行快速原型设计。 我以前用过 Sketch，但最近转到了 <a href=https://www.framer.com/>Figma</a>。 尽管我两者都喜欢，但我现在并不后悔使用 Figma。 另一个流行的工具是 Framer。</p><h2 id=为-react-书写文档>为 React 书写文档<a hidden class=anchor aria-hidden=true href=#为-react-书写文档>#</a></h2><p>如果你负责为你的软件、 UI 库或者其他东西编写文档，那么你可以使用一些简洁的 React 文档工具。 我已经广泛地使用了 Storybook，我可以说他非常好用，但是我也听说了其他解决方案的好处:</p><ul><li><a href=https://react-styleguidist.js.org/>Styleguidist</a></li><li><a href=https://www.docz.site/>docz</a></li><li><a href=https://docusaurus.io/>Docusaurus</a></li></ul><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>所以最终，React 生态系统可以看作是一个 React 的框架，但它保持灵活性。 它是一个灵活的框架，您可以自己决定选择哪些库。 您可以从小型开始，只添加库来解决特定的问题。 当应用程序增长时，您可以沿途扩展构建块。 否则你可以通过使用普通的 React 来保持轻量级。 因此，这里再次列出了可以补充 React 作为应用程序关于不同项目大小的核心的库。 请记住，这个列表是我的个人看法，我也渴望得到你的反馈。</p><h3 id=小型应用程式>小型应用程式<a hidden class=anchor aria-hidden=true href=#小型应用程式>#</a></h3><ul><li><strong>样板</strong>: create-react-app</li><li><strong>样式库:</strong> basic CSS and inline style</li><li><strong>异步请求</strong>: fetch or axios</li><li><strong>代码风格:</strong> 无</li><li><strong>类型检查:</strong> 无</li><li><strong>状态管理:</strong> React Hooks</li><li><strong>路由:</strong> 无 or React Router</li><li><strong>身份验证:</strong> Firebase</li><li><strong>数据库:</strong> Firebase</li><li><strong>UI 库:</strong> none</li><li><strong>表单库:</strong> 无</li><li><strong>测试库:</strong> Jest</li><li><strong>实用程序库:</strong> JavaScript</li><li><strong>国际化:</strong> react-i18next</li><li><strong>React 桌面:</strong> Electron</li></ul><h3 id=中型应用>中型应用<a hidden class=anchor aria-hidden=true href=#中型应用>#</a></h3><ul><li><strong>样板文件:</strong> Next.js or Gatsby.js</li><li><strong>样式库:</strong> CSS Modules or Styled Components</li><li><strong>异步请求:</strong> fetch or axios</li><li><strong>代码风格:</strong> Prettier，ESLint</li><li><strong>类型检查:</strong> 无 或 TypeScript</li><li><strong>状态管理:</strong> React Hooks and/or Apollo</li><li><strong>路由:</strong> React Router</li><li><strong>身份验证:</strong> Firebase</li><li><strong>数据库:</strong> Firebase</li><li><strong>Ui 库:</strong> none 或 UI 组件库</li><li><strong>表单库:</strong> none 或 Formik 或 React Hook Form</li><li><strong>测试库:</strong> Jest with React Testing Library</li><li><strong>实用程序库:</strong> JavaScript</li><li><strong>国际化:</strong> react-i18next</li><li><strong>React 桌面:</strong> Electron</li></ul><h3 id=大型应用程序>大型应用程序<a hidden class=anchor aria-hidden=true href=#大型应用程序>#</a></h3><ul><li><strong>样板文件:</strong> Next.js, Gatsby.js, custom setup</li><li><strong>样式库:</strong> CSS Modules or Styled Components</li><li><strong>异步请求:</strong> axios 或 Apollo Client</li><li><strong>代码风格:</strong> Prettier，ESLint</li><li><strong>类型检查:</strong> TypeScript</li><li><strong>状态管理:</strong> React Hooks and/或者 Apollo/Redux/MobX</li><li><strong>路由:</strong> React Router</li><li><strong>认证:</strong> Node.js 服务 + Passport.js</li><li><strong>数据库:</strong> 自己用SQL/NoSQL DB 提供 Node.js 服务</li><li><strong>Ui 库:</strong> UI 组件库或者您自己的 UI 组件</li><li>**表单库:**none 或者 Formik 或者 React Hook Form</li><li><strong>测试库:</strong> Jest with React Testing Library and Cypress</li><li><strong>实用程序库:</strong> JavaScript 的 api，Lodash</li><li><strong>国际化:</strong> react-i18next</li><li><strong>React 桌面:</strong> Electron</li></ul><p>以前的建议是个人的。 您可以为理想的 React 应用程序选择自己的灵活框架。 每一个“理想”的 React 设置都是主观的，取决于开发人员和项目的需求。 毕竟，没有理想的 React 应用程序设置。</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/react/>react</a></li><li><a href=/tags/%E8%AF%91%E6%96%87/>译文</a></li></ul><nav class=paginav><a class=prev href=/posts/%E6%A1%83%E5%9B%AD%E5%91%A8%E5%88%8A/16/><span class=title>« Prev</span><br><span>2017文章汇总</span></a>
<a class=next href=/posts/2022/2021-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/><span class=title>Next »</span><br><span>2021 年度总结</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 2020 年你应该知道的 React 库 on twitter" href="https://twitter.com/intent/tweet/?text=2020%20%e5%b9%b4%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e9%81%93%e7%9a%84%20React%20%e5%ba%93&url=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f300%2f&hashtags=react%2c%e8%af%91%e6%96%87"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2020 年你应该知道的 React 库 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f300%2f&title=2020%20%e5%b9%b4%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e9%81%93%e7%9a%84%20React%20%e5%ba%93&summary=2020%20%e5%b9%b4%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e9%81%93%e7%9a%84%20React%20%e5%ba%93&source=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f300%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2020 年你应该知道的 React 库 on reddit" href="https://reddit.com/submit?url=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f300%2f&title=2020%20%e5%b9%b4%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e9%81%93%e7%9a%84%20React%20%e5%ba%93"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2020 年你应该知道的 React 库 on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f300%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2020 年你应该知道的 React 库 on whatsapp" href="https://api.whatsapp.com/send?text=2020%20%e5%b9%b4%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e9%81%93%e7%9a%84%20React%20%e5%ba%93%20-%20%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f300%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2020 年你应该知道的 React 库 on telegram" href="https://telegram.me/share/url?text=2020%20%e5%b9%b4%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e9%81%93%e7%9a%84%20React%20%e5%ba%93&url=%2fposts%2f%25E8%25AF%2591%25E6%2596%2587%2f300%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href>桃园</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>